\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename swift-reference.info
@settitle The Swift Programming Reference (Swift 5.1)
@documentencoding UTF-8
@documentlanguage en
@syncodeindex vr cp
@syncodeindex fn cp
@syncodeindex ky cp
@c %**end of header

@dircategory Emacs
@direntry
* Swift Reference: (swift-reference). The Swift programming language reference.
@end direntry

@finalout
@titlepage
@title The Swift Programming Reference (Swift 5.1)
@author Apple Inc.
@end titlepage

@contents

@ifnottex
@node Top
@top The Swift Programming Reference (Swift 5.1)
@end ifnottex

@menu
* Language Reference::
* About the Language Reference::
* Lexical Structure::
* Types::
* Expressions::
* Statements::
* Declarations::
* Attributes::
* Patterns::
* Generic Parameters and Arguments::
* Summary of the Grammar::
* Index::

@detailmenu
--- The Detailed Node Listing ---

About the Language Reference

* How to Read the Grammar::

Lexical Structure

* Whitespace and Comments::
* Identifiers::
* Keywords and Punctuation::
* Literals::
* Operators::

Literals

* Integer Literals::
* Floating-Point Literals::
* String Literals::

Types

* Type Annotation::
* Type Identifier::
* Tuple Type::
* Function Type::
* Array Type::
* Dictionary Type::
* Optional Type::
* Implicitly Unwrapped Optional Type::
* Protocol Composition Type::
* Metatype Type::
* Type Inheritance Clause::
* Type Inference::

Function Type

* Restrictions for Nonescaping Closures::

Expressions

* Prefix Expressions::
* Binary Expressions::
* Primary Expressions::
* Postfix Expressions::

Prefix Expressions

* Try Operator::

Binary Expressions

* Assignment Operator::
* Type-Casting Operators::

Primary Expressions

* Literal Expression::
* Self Expression::
* Superclass Expression::
* Closure Expression::
* Implicit Member Expression::
* Parenthesized Expression::
* Tuple Expression::
* Wildcard Expression::
* Key-Path Expression::
* Selector Expression::
* Key-Path String Expression::

Postfix Expressions

* Function Call Expression::
* Initializer Expression::
* Explicit Member Expression::
* Postfix Self Expression::
* Subscript Expression::
* Forced-Value Expression::
* Optional-Chaining Expression::

Statements

* Loop Statements::
* Labeled Statement::
* Control Transfer Statements::
* Defer Statement::
* Do Statement::
* Compiler Control Statements::
* Availability Condition::

Loop Statements

* For-In Statement::
* While Statement::
* Repeat-While Statement::
* Branch Statements::
* If Statement::
* Guard Statement::

Control Transfer Statements

* Break Statement::
* Continue Statement::
* Fallthrough Statement::
* Return Statement::
* Throw Statement::

Compiler Control Statements

* Conditional Compilation Block::
* Line Control Statement::
* Compile-Time Diagnostic Statement::

Declarations

* Top-Level Code::
* Code Blocks::
* Import Declaration::
* Constant Declaration::
* Variable Declaration::
* Type Alias Declaration::
* Function Declaration::
* Enumeration Declaration::
* Structure Declaration::
* Class Declaration::
* Protocol Declaration::
* Initializer Declaration::
* Deinitializer Declaration::
* Extension Declaration::
* Subscript Declaration::
* Operator Declaration::
* Precedence Group Declaration::
* Declaration Modifiers::

Variable Declaration

* Stored Variables and Stored Variable Properties::
* Computed Variables and Computed Properties::
* Stored Variable Observers and Property Observers::
* Type Variable Properties::

Function Declaration

* Parameter Names::
* In-Out Parameters::
* Special Kinds of Parameters::
* Special Kinds of Methods::
* Throwing Functions and Methods::
* Rethrowing Functions and Methods::
* Functions that Never Return::

Enumeration Declaration

* Enumerations with Cases of Any Type::
* Enumerations with Cases of a Raw-Value Type::
* Accessing Enumeration Cases::

Protocol Declaration

* Protocol Property Declaration::
* Protocol Method Declaration::
* Protocol Initializer Declaration::
* Protocol Subscript Declaration::
* Protocol Associated Type Declaration::

Initializer Declaration

* Failable Initializers::

Extension Declaration

* Conditional Conformance::
* Protocol Conformance Must Not Be Redundant::

Declaration Modifiers

* Access Control Levels::

Attributes

* Declaration Attributes::
* Type Attributes::
* Switch Case Attributes::

Declaration Attributes

* available::
* discardableResult::
* dynamicCallable::
* dynamicMemberLookup::
* GKInspectable::
* inlinable::
* nonobjc::
* NSApplicationMain::
* NSCopying::
* NSManaged::
* objc::
* objcMembers::
* requires@math{_stored}@math{_property}@math{_inits}::
* testable::
* UIApplicationMain::
* usableFromInline::
* warn@math{_unqualified}@math{_access}::
* Declaration Attributes Used by Interface Builder::

Type Attributes

* autoclosure::
* convention::
* escaping::

Switch Case Attributes

* unknown::

Patterns

* Wildcard Pattern::
* Identifier Pattern::
* Value-Binding Pattern::
* Tuple Pattern::
* Enumeration Case Pattern::
* Optional Pattern::
* Type-Casting Patterns::
* Expression Pattern::

Generic Parameters and Arguments

* Generic Parameter Clause::
* Generic Argument Clause::

Generic Parameter Clause

* Generic Where Clauses::

Summary of the Grammar

* Lexical Structure: Lexical Structure 1.
* Types: Types 1.
* Expressions: Expressions 1.
* Statements: Statements 1.
* Declarations: Declarations 1.
* Attributes: Attributes 1.
* Patterns: Patterns 1.
* Generic Parameters and Arguments: Generic Parameters and Arguments 1.

@end detailmenu
@end menu

@node Language Reference
@chapter Language Reference

@itemize
@item
@ref{About the Language Reference}
@item
@ref{Lexical Structure}
@item
@ref{Types}
@item
@ref{Expressions}
@item
@ref{Statements}
@item
@ref{Declarations}
@item
@ref{Attributes}
@item
@ref{Patterns}
@item
@ref{Generic Parameters and Arguments, , Generic Parameters and
Arguments}
@item
@ref{Summary of the Grammar}
@end itemize

@node About the Language Reference
@chapter About the Language Reference

This part of the book describes the formal grammar of the Swift
programming language. The grammar described here is intended to help you
understand the language in more detail, rather than to allow you to
directly implement a parser or compiler.

The Swift language is relatively small, because many common types,
functions, and operators that appear virtually everywhere in Swift code
are actually defined in the Swift standard library. Although these
types, functions, and operators are not part of the Swift language
itself, they are used extensively in the discussions and code examples
in this part of the book.

@menu
* How to Read the Grammar::
@end menu

@node How to Read the Grammar
@section How to Read the Grammar

The notation used to describe the formal grammar of the Swift
programming language follows a few conventions:

@itemize
@item
An arrow (→) is used to mark grammar productions and can be read as
“can consist of.”

@item
Syntactic categories are indicated by @emph{italic} text and appear on both
sides of a grammar production rule.

@item
Literal words and punctuation are indicated by boldface
@samp{constant width} text and appear only on the right-hand side of a
grammar production rule.

@item
Alternative grammar productions are separated by vertical bars (|).
When alternative productions are too long to read easily, they are
broken into multiple grammar production rules on new lines.

@item
In a few cases, regular font text is used to describe the right-hand
side of a grammar production rule.

@item
Optional syntactic categories and literals are marked by a trailing
subscript, @emph{opt}.
@end itemize

As an example, the grammar of a getter-setter block is defined as
follows:

Grammar of a getter-setter block

→ @samp{@{}
getter-clause
setter-clause
_@{opt@} @samp{@}} | @samp{@{}
setter-clause
getter-clause
@samp{@}}

This definition indicates that a getter-setter block can consist of a
getter clause followed by an optional setter clause, enclosed in braces,
@emph{or} a setter clause followed by a getter clause, enclosed in braces.
The grammar production above is equivalent to the following two
productions, where the alternatives are spelled out explicitly:

Grammar of a getter-setter block

getter-setter-block
→ @samp{@{}
getter-clause
setter-clause
_@{opt@} @samp{@}}

getter-setter-block
→ @samp{@{}
setter-clause
getter-clause
@samp{@}}

@node Lexical Structure
@chapter Lexical Structure

The @emph{lexical structure} of Swift describes what sequence of characters
form valid tokens of the language. These valid tokens form the
lowest-level building blocks of the language and are used to describe
the rest of the language in subsequent chapters. A token consists of an
identifier, keyword, punctuation, literal, or operator.

In most cases, tokens are generated from the characters of a Swift
source file by considering the longest possible substring from the input
text, within the constraints of the grammar that are specified below.
This behavior is referred to as @emph{longest match} or @emph{maximal munch}.

@menu
* Whitespace and Comments::
* Identifiers::
* Keywords and Punctuation::
* Literals::
* Operators::
@end menu

@node Whitespace and Comments
@section Whitespace and Comments

Whitespace has two uses: to separate tokens in the source file and to
help determine whether an operator is a prefix or postfix (see
@ref{Operators}), but is otherwise ignored.
The following characters are considered whitespace: space (U+0020), line
feed (U+000A), carriage return (U+000D), horizontal tab (U+0009),
vertical tab (U+000B), form feed (U+000C) and null (U+0000).

Comments are treated as whitespace by the compiler. Single line comments
begin with @samp{//} and continue until a line feed (U+000A) or carriage
return (U+000D). Multiline comments begin with @samp{/*} and end with @samp{*/}.
Nesting multiline comments is allowed, but the comment markers must be
balanced.

Comments can contain additional formatting and markup, as described in
@uref{https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html, Markup
Formatting Reference}
[@uref{https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html}].

Grammar of whitespace

whitespace →
whitespace-item
whitespace
_@{opt@}

whitespace-item →
line-break

whitespace-item →
comment

whitespace-item →
multiline-comment

whitespace-item →
U+0000, U+0009, U+000B, U+000C, or U+0020

line-break → U+000A

line-break → U+000D

line-break → U+000D
followed by U+000A

comment → @samp{//}
comment-text
line-break

multiline-comment →
@samp{/*}
multiline-comment-text
@samp{*/}

comment-text →
comment-text-item
comment-text
_@{opt@}

comment-text-item →
Any Unicode scalar value except U+000A or U+000D

multiline-comment-text
→
multiline-comment-text-item
multiline-comment-text
_@{opt@}

multiline-comment-text-item
→
multiline-comment

multiline-comment-text-item
→
comment-text-item

multiline-comment-text-item
→ Any Unicode scalar value except @samp{/*} or @samp{*/}

@node Identifiers
@section Identifiers

@emph{Identifiers} begin with an uppercase or lowercase letter A through Z,
an underscore (@samp{_}), a noncombining alphanumeric Unicode character in
the Basic Multilingual Plane, or a character outside the Basic
Multilingual Plane that isn't in a Private Use Area. After the first
character, digits and combining Unicode characters are also allowed.

To use a reserved word as an identifier, put a backtick (@samp{`}) before and
after it. For example, @samp{class} is not a valid identifier, but @samp{`class`}
is valid. The backticks aren't considered part of the identifier; @samp{`x`}
and @samp{x} have the same meaning.

Inside a closure with no explicit parameter names, the parameters are
implicitly named @samp{$0}, @samp{$1}, @samp{$2}, and so on. These names are valid
identifiers within the scope of the closure.

Grammar of an identifier

identifier →
identifier-head
identifier-characters
_@{opt@}

identifier → @samp{`}
identifier-head
identifier-characters
_@{opt@} @samp{`}

identifier →
implicit-parameter-name

identifier-list →
identifier
@multitable {}
@item
@end multitable
identifier
@samp{,}
identifier-list

identifier-head →
Upper- or lowercase letter A through Z

identifier-head →
@samp{_}

identifier-head →
U+00A8, U+00AA, U+00AD, U+00AF, U+00B2--U+00B5, or U+00B7--U+00BA

identifier-head →
U+00BC--U+00BE, U+00C0--U+00D6, U+00D8--U+00F6, or U+00F8--U+00FF

identifier-head →
U+0100--U+02FF, U+0370--U+167F, U+1681--U+180D, or U+180F--U+1DBF

identifier-head →
U+1E00--U+1FFF

identifier-head →
U+200B--U+200D, U+202A--U+202E, U+203F--U+2040, U+2054, or
U+2060--U+206F

identifier-head →
U+2070--U+20CF, U+2100--U+218F, U+2460--U+24FF, or U+2776--U+2793

identifier-head →
U+2C00--U+2DFF or U+2E80--U+2FFF

identifier-head →
U+3004--U+3007, U+3021--U+302F, U+3031--U+303F, or U+3040--U+D7FF

identifier-head →
U+F900--U+FD3D, U+FD40--U+FDCF, U+FDF0--U+FE1F, or U+FE30--U+FE44

identifier-head →
U+FE47--U+FFFD

identifier-head →
U+10000--U+1FFFD, U+20000--U+2FFFD, U+30000--U+3FFFD, or
U+40000--U+4FFFD

identifier-head →
U+50000--U+5FFFD, U+60000--U+6FFFD, U+70000--U+7FFFD, or
U+80000--U+8FFFD

identifier-head →
U+90000--U+9FFFD, U+A0000--U+AFFFD, U+B0000--U+BFFFD, or
U+C0000--U+CFFFD

identifier-head →
U+D0000--U+DFFFD or U+E0000--U+EFFFD

identifier-character
→ Digit 0 through 9

identifier-character
→ U+0300--U+036F, U+1DC0--U+1DFF, U+20D0--U+20FF, or U+FE20--U+FE2F

identifier-character
→
identifier-head

identifier-characters
→
identifier-character
identifier-characters
_@{opt@}

implicit-parameter-name
→ @samp{$}
decimal-digits

@node Keywords and Punctuation
@section Keywords and Punctuation

The following keywords are reserved and can't be used as identifiers,
unless they're escaped with backticks, as described above in
@ref{Identifiers}. Keywords other than
@samp{inout}, @samp{var}, and @samp{let} can be used as parameter names in a function
declaration or function call without being escaped with backticks. When
a member has the same name as a keyword, references to that member don't
need to be escaped with backticks, except when there's ambiguity between
referring to the member and using the keyword---for example, @samp{self},
@samp{Type}, and @samp{Protocol} have special meaning in an explicit member
expression, so they must be escaped with backticks in that context.

@itemize
@item
Keywords used in declarations: @samp{associatedtype}, @samp{class}, @samp{deinit},
@samp{enum}, @samp{extension}, @samp{fileprivate}, @samp{func}, @samp{import}, @samp{init}, @samp{inout},
@samp{internal}, @samp{let}, @samp{open}, @samp{operator}, @samp{private}, @samp{protocol},
@samp{public}, @samp{static}, @samp{struct}, @samp{subscript}, @samp{typealias}, and @samp{var}.

@item
Keywords used in statements: @samp{break}, @samp{case}, @samp{continue}, @samp{default},
@samp{defer}, @samp{do}, @samp{else}, @samp{fallthrough}, @samp{for}, @samp{guard}, @samp{if}, @samp{in},
@samp{repeat}, @samp{return}, @samp{switch}, @samp{where}, and @samp{while}.

@item
Keywords used in expressions and types: @samp{as}, @samp{Any}, @samp{catch}, @samp{false},
@samp{is}, @samp{nil}, @samp{rethrows}, @samp{super}, @samp{self}, @samp{Self}, @samp{throw}, @samp{throws},
@samp{true}, and @samp{try}.

@item
Keywords used in patterns: @samp{_}.

@item
Keywords that begin with a number sign (@samp{#}): @samp{#available},
@samp{#colorLiteral}, @samp{#column}, @samp{#else}, @samp{#elseif}, @samp{#endif}, @samp{#error},
@samp{#file}, @samp{#fileLiteral}, @samp{#function}, @samp{#if}, @samp{#imageLiteral}, @samp{#line},
@samp{#selector}, @samp{#sourceLocation}, and @samp{#warning}.

@item
Keywords reserved in particular contexts: @samp{associativity},
@samp{convenience}, @samp{dynamic}, @samp{didSet}, @samp{final}, @samp{get}, @samp{infix},
@samp{indirect}, @samp{lazy}, @samp{left}, @samp{mutating}, @samp{none}, @samp{nonmutating},
@samp{optional}, @samp{override}, @samp{postfix}, @samp{precedence}, @samp{prefix}, @samp{Protocol},
@samp{required}, @samp{right}, @samp{set}, @samp{Type}, @samp{unowned}, @samp{weak}, and @samp{willSet}.
Outside the context in which they appear in the grammar, they can be
used as identifiers.
@end itemize

The following tokens are reserved as punctuation and can't be used as
custom operators: @samp{(}, @samp{)}, @samp{@{}, @samp{@}}, @samp{[}, @samp{]}, @samp{.}, @samp{,}, @samp{:}, @samp{;}, @samp{=},
@samp{@@}, @samp{#}, @samp{&} (as a prefix operator), @samp{->}, @samp{`}, @samp{?}, and @samp{!} (as a
postfix operator).

@node Literals
@section Literals

A @emph{literal} is the source code representation of a value of a type, such
as a number or string.

The following are examples of literals:

@enumerate
@item
42 // Integer literal
@item
3.14159 // Floating-point literal
@item
"Hello, world!" // String literal
@item
true // Boolean literal
@end enumerate

A literal doesn't have a type on its own. Instead, a literal is parsed
as having infinite precision and Swift's type inference attempts to
infer a type for the literal. For example, in the declaration
@samp{let x: Int8 = 42}, Swift uses the explicit type annotation (@samp{: Int8})
to infer that the type of the integer literal @samp{42} is @samp{Int8}. If there
isn't suitable type information available, Swift infers that the
literal's type is one of the default literal types defined in the Swift
standard library. The default types are @samp{Int} for integer literals,
@samp{Double} for floating-point literals, @samp{String} for string literals, and
@samp{Bool} for Boolean literals. For example, in the declaration
@samp{let str = "Hello, world"}, the default inferred type of the string
literal @samp{"Hello, world"} is @samp{String}.

When specifying the type annotation for a literal value, the
annotation's type must be a type that can be instantiated from that
literal value. That is, the type must conform to one of the following
Swift standard library protocols: @samp{ExpressibleByIntegerLiteral} for
integer literals, @samp{ExpressibleByFloatLiteral} for floating-point
literals, @samp{ExpressibleByStringLiteral} for string literals,
@samp{ExpressibleByBooleanLiteral} for Boolean literals,
@samp{ExpressibleByUnicodeScalarLiteral} for string literals that contain
only a single Unicode scalar, and
@samp{ExpressibleByExtendedGraphemeClusterLiteral} for string literals that
contain only a single extended grapheme cluster. For example, @samp{Int8}
conforms to the @samp{ExpressibleByIntegerLiteral} protocol, and therefore it
can be used in the type annotation for the integer literal @samp{42} in the
declaration @samp{let x: Int8 = 42}.

Grammar of a literal

literal →
numeric-literal
@multitable {}
@item
@end multitable
string-literal
@multitable {}
@item
@end multitable
boolean-literal
@multitable {}
@item
@end multitable
nil-literal

numeric-literal →
=-=@math{_opt}
integer-literal
@multitable {aaaaaaaaa}
@item =-=@math{_opt}
@end multitable
floating-point-literal

boolean-literal →
@samp{true} | @samp{false}

nil-literal → @samp{nil}

@menu
* Integer Literals::
* Floating-Point Literals::
* String Literals::
@end menu

@node Integer Literals
@subsection Integer Literals

@emph{Integer literals} represent integer values of unspecified precision. By
default, integer literals are expressed in decimal; you can specify an
alternate base using a prefix. Binary literals begin with @samp{0b}, octal
literals begin with @samp{0o}, and hexadecimal literals begin with @samp{0x}.

Decimal literals contain the digits @samp{0} through @samp{9}. Binary literals
contain @samp{0} and @samp{1}, octal literals contain @samp{0} through @samp{7}, and
hexadecimal literals contain @samp{0} through @samp{9} as well as @samp{A} through @samp{F}
in upper- or lowercase.

Negative integers literals are expressed by prepending a minus sign
(@samp{-}) to an integer literal, as in @samp{-42}.

Underscores (@samp{_}) are allowed between digits for readability, but
they're ignored and therefore don't affect the value of the literal.
Integer literals can begin with leading zeros (@samp{0}), but they're
likewise ignored and don't affect the base or value of the literal.

Unless otherwise specified, the default inferred type of an integer
literal is the Swift standard library type @samp{Int}. The Swift standard
library also defines types for various sizes of signed and unsigned
integers, as described in
@ref{Integers,Integers,,swift,}.

Grammar of an integer literal

integer-literal →
binary-literal

integer-literal →
octal-literal

integer-literal →
decimal-literal

integer-literal →
hexadecimal-literal

binary-literal → @samp{0b}
binary-digit
binary-literal-characters
_@{opt@}

binary-digit → Digit 0 or
1

binary-literal-character
→
binary-digit
@multitable {aaa}
@item @samp{_}
@end multitable

binary-literal-characters
→
binary-literal-character
binary-literal-characters
_@{opt@}

octal-literal → @samp{0o}
octal-digit
octal-literal-characters
_@{opt@}

octal-digit → Digit 0
through 7

octal-literal-character
→
octal-digit
@multitable {aaa}
@item @samp{_}
@end multitable

octal-literal-characters
→
octal-literal-character
octal-literal-characters
_@{opt@}

decimal-literal →
decimal-digit
decimal-literal-characters
_@{opt@}

decimal-digit → Digit 0
through 9

decimal-digits →
decimal-digit
decimal-digits
_@{opt@}

decimal-literal-character
→
decimal-digit
@multitable {aaa}
@item @samp{_}
@end multitable

decimal-literal-characters
→
decimal-literal-character
decimal-literal-characters
_@{opt@}

hexadecimal-literal
→ @samp{0x}
hexadecimal-digit
hexadecimal-literal-characters
_@{opt@}

hexadecimal-digit →
Digit 0 through 9, a through f, or A through F

hexadecimal-literal-character
→
hexadecimal-digit
@multitable {aaa}
@item @samp{_}
@end multitable

hexadecimal-literal-characters
→
hexadecimal-literal-character
hexadecimal-literal-characters
_@{opt@}

@node Floating-Point Literals
@subsection Floating-Point Literals

@emph{Floating-point literals} represent floating-point values of unspecified
precision.

By default, floating-point literals are expressed in decimal (with no
prefix), but they can also be expressed in hexadecimal (with a @samp{0x}
prefix).

Decimal floating-point literals consist of a sequence of decimal digits
followed by either a decimal fraction, a decimal exponent, or both. The
decimal fraction consists of a decimal point (@samp{.}) followed by a
sequence of decimal digits. The exponent consists of an upper- or
lowercase @samp{e} prefix followed by a sequence of decimal digits that
indicates what power of 10 the value preceding the @samp{e} is multiplied by.
For example, @samp{1.25e2} represents 1.25 x 10@math{^2}, which evaluates to
@samp{125.0}. Similarly, @samp{1.25e-2} represents 1.25 x 10@math{^-2}, which evaluates
to @samp{0.0125}.

Hexadecimal floating-point literals consist of a @samp{0x} prefix, followed
by an optional hexadecimal fraction, followed by a hexadecimal exponent.
The hexadecimal fraction consists of a decimal point followed by a
sequence of hexadecimal digits. The exponent consists of an upper- or
lowercase @samp{p} prefix followed by a sequence of decimal digits that
indicates what power of 2 the value preceding the @samp{p} is multiplied by.
For example, @samp{0xFp2} represents 15 x 2@math{^2}, which evaluates to @samp{60}.
Similarly, @samp{0xFp-2} represents 15 x 2@math{^-2}, which evaluates to @samp{3.75}.

Negative floating-point literals are expressed by prepending a minus
sign (@samp{-}) to a floating-point literal, as in @samp{-42.5}.

Underscores (@samp{_}) are allowed between digits for readability, but
they're ignored and therefore don't affect the value of the literal.
Floating-point literals can begin with leading zeros (@samp{0}), but they're
likewise ignored and don't affect the base or value of the literal.

Unless otherwise specified, the default inferred type of a
floating-point literal is the Swift standard library type @samp{Double},
which represents a 64-bit floating-point number. The Swift standard
library also defines a @samp{Float} type, which represents a 32-bit
floating-point number.

Grammar of a floating-point literal

floating-point-literal
→
decimal-literal
decimal-fraction
_@{opt@}
decimal-exponent
_@{opt@}

floating-point-literal
→
hexadecimal-literal
hexadecimal-fraction
_@{opt@}
hexadecimal-exponent

decimal-fraction →
@samp{.}
decimal-literal

decimal-exponent →
floating-point-e
sign _@{opt@}
decimal-literal

hexadecimal-fraction
→ @samp{.}
hexadecimal-digit
hexadecimal-literal-characters
_@{opt@}

hexadecimal-exponent
→
floating-point-p
sign _@{opt@}
decimal-literal

floating-point-e →
@samp{e} | @samp{E}

floating-point-p →
@samp{p} | @samp{P}

sign → @samp{+} | @samp{-}

@node String Literals
@subsection String Literals

A string literal is a sequence of characters surrounded by quotation
marks. A single-line string literal is surrounded by double quotation
marks and has the following form:

@enumerate
@item
"characters"
@end enumerate

String literals can't contain an unescaped double quotation mark (@samp{"}),
an unescaped backslash (@samp{\}), a carriage return, or a line feed.

A multiline string literal is surrounded by three double quotation marks
and has the following form:

@enumerate
@item
"""
@item
characters
@item
"""
@end enumerate

Unlike a single-line string literal, a multiline string literal can
contain unescaped double quotation marks (@samp{"}), carriage returns, and
line feeds. It can't contain three unescaped double quotation marks next
to each other.

The line break after the @samp{"""} that begins the multiline string literal
is not part of the string. The line break before the @samp{"""} that ends the
literal is also not part of the string. To make a multiline string
literal that begins or ends with a line feed, write a blank line as its
first or last line.

A multiline string literal can be indented using any combination of
spaces and tabs; this indentation is not included in the string. The
@samp{"""} that ends the literal determines the indentation: Every nonblank
line in the literal must begin with exactly the same indentation that
appears before the closing @samp{"""}; there's no conversion between tabs and
spaces. You can include additional spaces and tabs after that
indentation; those spaces and tabs appear in the string.

Line breaks in a multiline string literal are normalized to use the line
feed character. Even if your source file has a mix of carriage returns
and line feeds, all of the line breaks in the string will be the same.

In a multiline string literal, writing a backslash (@samp{\}) at the end of a
line omits that line break from the string. Any whitespace between the
backslash and the line break is also omitted. You can use this syntax to
hard wrap a multiline string literal in your source code, without
changing the value of the resulting string.

Special characters can be included in string literals of both the
single-line and multiline forms using the following escape sequences:

@itemize
@item
Null character (@samp{\0})

@item
Backslash (@samp{\\})

@item
Horizontal tab (@samp{\t})

@item
Line feed (@samp{\n})

@item
Carriage return (@samp{\r})

@item
Double quotation mark (@samp{\"})

@item
Single quotation mark (@samp{\'})

@item
Unicode scalar (@samp{\u@{=/n/}@}=), where @emph{n} is a hexadecimal number that
has one to eight digits
@end itemize

The value of an expression can be inserted into a string literal by
placing the expression in parentheses after a backslash (@samp{\}). The
interpolated expression can contain a string literal, but can't contain
an unescaped backslash, a carriage return, or a line feed.

For example, all of the following string literals have the same value:

@enumerate
@item
"1 2 3"
@item
"1 2 \("3")"
@item
"1 2 \(3)"
@item
"1 2 \(1 + 2)"
@item
let x = 3; "1 2 \(x)"
@end enumerate

A string delimited by extended delimiters is a sequence of characters
surrounded by quotation marks and a balanced set of one or more number
signs (@samp{#}). A string delimited by extended delimiters has the following
forms:

@enumerate
@item
#"characters"#
@item

@item
#"""
@item
characters
@item
"""#
@end enumerate

Special characters in a string delimited by extended delimiters appear
in the resulting string as normal characters rather than as special
characters. You can use extended delimiters to create strings with
characters that would ordinarily have a special effect such as
generating a string interpolation, starting an escape sequence, or
terminating the string.

The following example shows a string literal and a string delimited by
extended delimiters that create equivalent string values:

@enumerate
@item
let string = #"\(x) \ " "#
@item
let escaped = "\\(x) \\ \" \"
@item
print(string)
@item
// Prints "\(x) \ " "
@item
print(string == escaped)
@item
// Prints "true"
@end enumerate

If you use more than one number sign to form a string delimited by
extended delimiters, don't place whitespace in between the number signs:

@enumerate
@item
print(###"Line 1\###nLine 2"###) // OK
@item
print(# # #"Line 1\# # #nLine 2"# # #) // Error
@end enumerate

Multiline string literals that you create using extended delimiters have
the same indentation requirements as regular multiline string literals.

The default inferred type of a string literal is @samp{String}. For more
information about the @samp{String} type, see
@ref{Strings and Characters,Strings and Characters,,swift,}
and @uref{https://developer.apple.com/documentation/swift/string, @samp{String}}
[@uref{https://developer.apple.com/documentation/swift/string}].

String literals that are concatenated by the @samp{+} operator are
concatenated at compile time. For example, the values of @samp{textA} and
@samp{textB} in the example below are identical---no runtime concatenation is
performed.

@enumerate
@item
let textA = "Hello " + "world"
@item
let textB = "Hello world"
@end enumerate

Grammar of a string literal

string-literal →
static-string-literal
@multitable {}
@item
@end multitable
interpolated-string-literal

string-literal-opening-delimiter
→
extended-string-literal-delimiter
_@{opt@} @samp{"}

string-literal-closing-delimiter
→ @samp{"}
extended-string-literal-delimiter
_@{opt@}

static-string-literal
→
string-literal-opening-delimiter
quoted-text
_@{opt@}
string-literal-closing-delimiter

static-string-literal
→
multiline-string-literal-opening-delimiter
multiline-quoted-text
_@{opt@}
multiline-string-literal-closing-delimiter

multiline-string-literal-opening-delimiter
→
extended-string-literal-delimiter
@samp{"""}

multiline-string-literal-closing-delimiter
→ @samp{"""}
extended-string-literal-delimiter

extended-string-literal-delimiter
→ @samp{#}
extended-string-literal-delimiter
_@{opt@}

quoted-text →
quoted-text-item
quoted-text
_@{opt@}

quoted-text-item →
escaped-character

quoted-text-item
→ Any Unicode scalar value except @samp{"}, @samp{\}, U+000A, or U+000D

multiline-quoted-text
→
multiline-quoted-text-item
multiline-quoted-text
_@{opt@}

multiline-quoted-text-item
→
escaped-character

multiline-quoted-text-item
→ Any Unicode scalar value except @samp{\}

multiline-quoted-text-item
→
escaped-newline

interpolated-string-literal
→
string-literal-opening-delimiter
interpolated-text
_@{opt@}
string-literal-closing-delimiter

interpolated-string-literal
→
multiline-string-literal-opening-delimiter
interpolated-text
_@{opt@}
multiline-string-literal-closing-delimiter

interpolated-text →
interpolated-text-item
interpolated-text
_@{opt@}

interpolated-text-item
→ @samp{\(}
expression
@samp{)} |
quoted-text-item

multiline-interpolated-text
→
multiline-interpolated-text-item
multiline-interpolated-text
_@{opt@}

multiline-interpolated-text-item
→ @samp{\(}
expression
@samp{)} |
multiline-quoted-text-item

escape-sequence → @samp{\}
extended-string-literal-delimiter

escaped-character →
escape-sequence
@samp{0} |
escape-sequence
@samp{\} |
escape-sequence
@samp{t} |
escape-sequence
@samp{n} |
escape-sequence
@samp{r} |
escape-sequence
@samp{"} |
escape-sequence
@samp{'}

escaped-character
→
escape-sequence
@samp{u} @samp{@{}
unicode-scalar-digits
@samp{@}}

unicode-scalar-digits
→ Between one and eight hexadecimal digits

escaped-newline →
escape-sequence
whitespace
_@{opt@}
line-break

@node Operators
@section Operators

The Swift standard library defines a number of operators for your use,
many of which are discussed in
@ref{Basic Operators,Basic Operators,,swift,} and
@ref{Advanced Operators,Advanced Operators,,swift,}. The
present section describes which characters can be used to define custom
operators.

Custom operators can begin with one of the ASCII characters @samp{/}, @samp{=},
@samp{-}, @samp{+}, @samp{!}, @samp{*}, @samp{%}, @samp{<}, @samp{>}, @samp{&}, @samp{|}, @samp{^}, @samp{?}, or @samp{~}, or one of
the Unicode characters defined in the grammar below (which include
characters from the @emph{Mathematical Operators}, @emph{Miscellaneous Symbols},
and @emph{Dingbats} Unicode blocks, among others). After the first character,
combining Unicode characters are also allowed.

You can also define custom operators that begin with a dot (@samp{.}). These
operators can contain additional dots. For example, @samp{.+.} is treated as
a single operator. If an operator doesn't begin with a dot, it can't
contain a dot elsewhere. For example, @samp{+.+} is treated as the @samp{+}
operator followed by the @samp{.+} operator.

Although you can define custom operators that contain a question mark
(@samp{?}), they can't consist of a single question mark character only.
Additionally, although operators can contain an exclamation mark (@samp{!}),
postfix operators can't begin with either a question mark or an
exclamation mark.

Note

The tokens @samp{=}, @samp{->}, @samp{//}, @samp{/*}, @samp{*/}, @samp{.}, the prefix operators @samp{<},
@samp{&}, and @samp{?}, the infix operator @samp{?}, and the postfix operators @samp{>},
@samp{!}, and @samp{?} are reserved. These tokens can't be overloaded, nor can
they be used as custom operators.

The whitespace around an operator is used to determine whether an
operator is used as a prefix operator, a postfix operator, or a binary
operator. This behavior is summarized in the following rules:

@itemize
@item
If an operator has whitespace around both sides or around neither
side, it's treated as a binary operator. As an example, the @samp{+++}
operator in @samp{a+++b} and @samp{a +++ b} is treated as a binary operator.

@item
If an operator has whitespace on the left side only, it's treated as a
prefix unary operator. As an example, the @samp{+++} operator in @samp{a +++b}
is treated as a prefix unary operator.

@item
If an operator has whitespace on the right side only, it's treated as
a postfix unary operator. As an example, the @samp{+++} operator in
@samp{a+++ b} is treated as a postfix unary operator.

@item
If an operator has no whitespace on the left but is followed
immediately by a dot (@samp{.}), it's treated as a postfix unary operator.
As an example, the @samp{+++} operator in @samp{a+++.b} is treated as a postfix
unary operator (@samp{a+++ .b} rather than @samp{a +++ .b}).
@end itemize

For the purposes of these rules, the characters @samp{(}, @samp{[}, and @samp{@{} before
an operator, the characters @samp{)}, @samp{]}, and @samp{@}} after an operator, and the
characters @samp{,}, @samp{;}, and @samp{:} are also considered whitespace.

There's one caveat to the rules above. If the @samp{!} or @samp{?} predefined
operator has no whitespace on the left, it's treated as a postfix
operator, regardless of whether it has whitespace on the right. To use
the @samp{?} as the optional-chaining operator, it must not have whitespace
on the left. To use it in the ternary conditional (@samp{?} @samp{:}) operator, it
must have whitespace around both sides.

In certain constructs, operators with a leading @samp{<} or @samp{>} may be split
into two or more tokens. The remainder is treated the same way and may
be split again. As a result, there's no need to use whitespace to
disambiguate between the closing @samp{>} characters in constructs like
@samp{Dictionary<String, Array<Int>>}. In this example, the closing @samp{>}
characters are not treated as a single token that may then be
misinterpreted as a bit shift @samp{>>} operator.

To learn how to define new, custom operators, see
@ref{Custom Operators,Custom Operators,,swift,} and
@ref{Operator Declaration}. To learn how to
overload existing operators, see
@ref{Operator Methods,Operator Methods,,swift,}.

Grammar of operators

operator →
operator-head
operator-characters
_@{opt@}

operator →
dot-operator-head
dot-operator-characters

operator-head → @samp{/} |
@samp{=} | @samp{-} | @samp{+} | @samp{!} | @samp{*} | @samp{%} | @samp{<} | @samp{>} | @samp{&} | @samp{|} | @samp{^} | @samp{~} |
@samp{?}

operator-head →
U+00A1--U+00A7

operator-head →
U+00A9 or U+00AB

operator-head →
U+00AC or U+00AE

operator-head →
U+00B0--U+00B1

operator-head →
U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7

operator-head →
U+2016--U+2017

operator-head →
U+2020--U+2027

operator-head →
U+2030--U+203E

operator-head →
U+2041--U+2053

operator-head →
U+2055--U+205E

operator-head →
U+2190--U+23FF

operator-head →
U+2500--U+2775

operator-head →
U+2794--U+2BFF

operator-head →
U+2E00--U+2E7F

operator-head →
U+3001--U+3003

operator-head →
U+3008--U+3020

operator-head →
U+3030

operator-character
→
operator-head

operator-character
→ U+0300--U+036F

operator-character
→ U+1DC0--U+1DFF

operator-character
→ U+20D0--U+20FF

operator-character
→ U+FE00--U+FE0F

operator-character
→ U+FE20--U+FE2F

operator-character
→ U+E0100--U+E01EF

operator-characters
→
operator-character
operator-characters
_@{opt@}

dot-operator-head →
@samp{.}

dot-operator-character
→ @samp{.} |
operator-character

dot-operator-characters
→
dot-operator-character
dot-operator-characters
_@{opt@}

binary-operator →
operator

prefix-operator →
operator

postfix-operator →
operator

@node Types
@chapter Types

In Swift, there are two kinds of types: named types and compound types.
A @emph{named type} is a type that can be given a particular name when it's
defined. Named types include classes, structures, enumerations, and
protocols. For example, instances of a user-defined class named
@samp{MyClass} have the type @samp{MyClass}. In addition to user-defined named
types, the Swift standard library defines many commonly used named
types, including those that represent arrays, dictionaries, and optional
values.

Data types that are normally considered basic or primitive in other
languages---such as types that represent numbers, characters, and
strings---are actually named types, defined and implemented in the Swift
standard library using structures. Because they're named types, you can
extend their behavior to suit the needs of your program, using an
extension declaration, discussed in
@ref{Extensions,Extensions,,swift,} and
@ref{Extension Declaration}.

A @emph{compound type} is a type without a name, defined in the Swift
language itself. There are two compound types: function types and tuple
types. A compound type may contain named types and other compound types.
For example, the tuple type @samp{(Int, (Int, Int))} contains two elements:
The first is the named type @samp{Int}, and the second is another compound
type @samp{(Int, Int)}.

You can put parentheses around a named type or a compound type. However,
adding parentheses around a type doesn't have any effect. For example,
@samp{(Int)} is equivalent to @samp{Int}.

This chapter discusses the types defined in the Swift language itself
and describes the type inference behavior of Swift.

Grammar of a type

type →
function-type

type →
array-type

type →
dictionary-type

type →
type-identifier

type →
tuple-type

type →
optional-type

type →
implicitly-unwrapped-optional-type

type →
protocol-composition-type

type →
opaque-type

type →
metatype-type

type → @samp{Any}

type → @samp{Self}

type → @samp{(}
type @samp{)}

@menu
* Type Annotation::
* Type Identifier::
* Tuple Type::
* Function Type::
* Array Type::
* Dictionary Type::
* Optional Type::
* Implicitly Unwrapped Optional Type::
* Protocol Composition Type::
* Metatype Type::
* Type Inheritance Clause::
* Type Inference::
@end menu

@node Type Annotation
@section Type Annotation

A @emph{type annotation} explicitly specifies the type of a variable or
expression. Type annotations begin with a colon (@samp{:}) and end with a
type, as the following examples show:

@enumerate
@item
let someTuple: (Double, Double) = (3.14159, 2.71828)
@item
func someFunction(a: Int) @{ @emph{* @dots{} *} @}
@end enumerate

In the first example, the expression @samp{someTuple} is specified to have
the tuple type @samp{(Double, Double)}. In the second example, the parameter
@samp{a} to the function @samp{someFunction} is specified to have the type @samp{Int}.

Type annotations can contain an optional list of type attributes before
the type.

Grammar of a type annotation

type-annotation → @samp{:}
attributes
_@{opt@} =inout=@math{_opt}
type

@node Type Identifier
@section Type Identifier

A @emph{type identifier} refers to either a named type or a type alias of a
named or compound type.

Most of the time, a type identifier directly refers to a named type with
the same name as the identifier. For example, @samp{Int} is a type identifier
that directly refers to the named type @samp{Int}, and the type identifier
@samp{Dictionary<String, Int>} directly refers to the named type
@samp{Dictionary<String, Int>}.

There are two cases in which a type identifier doesn't refer to a type
with the same name. In the first case, a type identifier refers to a
type alias of a named or compound type. For instance, in the example
below, the use of @samp{Point} in the type annotation refers to the tuple
type @samp{(Int, Int)}.

@enumerate
@item
typealias Point = (Int, Int)
@item
let origin: Point = (0, 0)
@end enumerate

In the second case, a type identifier uses dot (@samp{.}) syntax to refer to
named types declared in other modules or nested within other types. For
example, the type identifier in the following code references the named
type @samp{MyType} that is declared in the @samp{ExampleModule} module.

@enumerate
@item
var someValue: ExampleModule.MyType
@end enumerate

Grammar of a type identifier

type-identifier →
type-name
generic-argument-clause
_@{opt@} | type-name
generic-argument-clause
_@{opt@} @samp{.}
type-identifier

type-name →
identifier

@node Tuple Type
@section Tuple Type

A @emph{tuple type} is a comma-separated list of types, enclosed in
parentheses.

You can use a tuple type as the return type of a function to enable the
function to return a single tuple containing multiple values. You can
also name the elements of a tuple type and use those names to refer to
the values of the individual elements. An element name consists of an
identifier followed immediately by a colon (:). For an example that
demonstrates both of these features, see
@ref{Functions with Multiple Return Values,Functions with Multiple Return
Values,,swift,}.

When an element of a tuple type has a name, that name is part of the
type.

@enumerate
@item
var someTuple = (top: 10, bottom: 12) // someTuple is of type (top:
Int, bottom: Int)
@item
someTuple = (top: 4, bottom: 42) // OK: names match
@item
someTuple = (9, 99) // OK: names are inferred
@item
someTuple = (left: 5, right: 5) // Error: names don't match
@end enumerate

All tuple types contain two or more types, except for @samp{Void} which is a
type alias for the empty tuple type, @samp{()}.

Grammar of a tuple type

tuple-type → @samp{(} @samp{)} | @samp{(}
tuple-type-element
@samp{,}
tuple-type-element-list
@samp{)}

tuple-type-element-list →
tuple-type-element
@multitable {}
@item
@end multitable
tuple-type-element
@samp{,}
tuple-type-element-list

tuple-type-element →
element-name
type-annotation
@multitable {aaaa}
@item type
@end multitable

element-name →
identifier

@node Function Type
@section Function Type

A @emph{function type} represents the type of a function, method, or closure
and consists of a parameter and return type separated by an arrow
(@samp{->}):

@enumerate
@item
(parameter type) -> return type
@end enumerate

The @emph{parameter type} is comma-separated list of types. Because the
@emph{return type} can be a tuple type, function types support functions and
methods that return multiple values.

A parameter of the function type @samp{() -> T} (where @samp{T} is any type) can
apply the @samp{autoclosure} attribute to implicitly create a closure at its
call sites. This provides a syntactically convenient way to defer the
evaluation of an expression without needing to write an explicit closure
when you call the function. For an example of an autoclosure function
type parameter, see
@ref{Autoclosures,Autoclosures,,swift,}.

A function type can have a variadic parameter in its @emph{parameter type}.
Syntactically, a variadic parameter consists of a base type name
followed immediately by three dots (@samp{...}), as in @samp{Int...}. A variadic
parameter is treated as an array that contains elements of the base type
name. For instance, the variadic parameter @samp{Int...} is treated as
@samp{[Int]}. For an example that uses a variadic parameter, see
@ref{Variadic Parameters,Variadic Parameters,,swift,}.

To specify an in-out parameter, prefix the parameter type with the
@samp{inout} keyword. You can't mark a variadic parameter or a return type
with the @samp{inout} keyword. In-out parameters are discussed in
@ref{In-Out Parameters}.

If a function type has only one parameter and that parameter's type is a
tuple type, then the tuple type must be parenthesized when writing the
function's type. For example, @samp{((Int, Int)) -> Void} is the type of a
function that takes a single parameter of the tuple type @samp{(Int, Int)}
and doesn't return any value. In contrast, without parentheses,
@samp{(Int, Int) -> Void} is the type of a function that takes two @samp{Int}
parameters and doesn't return any value. Likewise, because @samp{Void} is a
type alias for @samp{()}, the function type @samp{(Void) -> Void} is the same as
@samp{(()) -> ()}---a function that takes a single argument that is an empty
tuple. These types are not the same as @samp{() -> ()}---a function that
takes no arguments.

Argument names in functions and methods are not part of the
corresponding function type. For example:

@enumerate
@item
func someFunction(left: Int, right: Int) @{@}
@item
func anotherFunction(left: Int, right: Int) @{@}
@item
func functionWithDifferentLabels(top: Int, bottom: Int) @{@}
@item

@item
var f = someFunction // The type of f is (Int, Int) -> Void, not
(left: Int, right: Int) -> Void.
@item
f = anotherFunction // OK
@item
f = functionWithDifferentLabels // OK
@item

@item
func functionWithDifferentArgumentTypes(left: Int, right: String) @{@}
@item
f = functionWithDifferentArgumentTypes // Error
@item

@item
func functionWithDifferentNumberOfArguments(left: Int, right: Int,
top: Int) @{@}
@item
f = functionWithDifferentNumberOfArguments // Error
@end enumerate

Because argument labels are not part of a function's type, you omit them
when writing a function type.

@enumerate
@item
var operation: (lhs: Int, rhs: Int) -> Int // Error
@item
var operation: (_ lhs: Int, _ rhs: Int) -> Int // OK
@item
var operation: (Int, Int) -> Int // OK
@end enumerate

If a function type includes more than a single arrow (@samp{->}), the
function types are grouped from right to left. For example, the function
type @samp{(Int) -> (Int) -> Int} is understood as
@samp{(Int) -> ((Int) -> Int)}---that is, a function that takes an @samp{Int} and
returns another function that takes and returns an @samp{Int}.

Function types that can throw an error must be marked with the @samp{throws}
keyword, and function types that can rethrow an error must be marked
with the @samp{rethrows} keyword. The @samp{throws} keyword is part of a
function's type, and nonthrowing functions are subtypes of throwing
functions. As a result, you can use a nonthrowing function in the same
places as a throwing one. Throwing and rethrowing functions are
described in @ref{Throwing Functions and Methods, , Throwing Functions and
Methods} and @ref{Rethrowing Functions and Methods, , Rethrowing Functions and
Methods}.

@menu
* Restrictions for Nonescaping Closures::
@end menu

@node Restrictions for Nonescaping Closures
@subsection Restrictions for Nonescaping Closures

A parameter that's a nonescaping function can't be stored in a property,
variable, or constant of type @samp{Any}, because that might allow the value
to escape.

A parameter that's a nonescaping function can't be passed as an argument
to another nonescaping function parameter. This restriction helps Swift
perform more of its checks for conflicting access to memory at compile
time instead of at runtime. For example:

@enumerate
@item
let external: (() -> Void) -> Void = @{ _ in () @}
@item
func takesTwoFunctions(first: (() -> Void) -> Void, second: (() ->
Void) -> Void) @{
@item
first @{ first @{@} @} // Error
@item
second @{ second @{@} @} // Error
@item

@item
first @{ second @{@} @} // Error
@item
second @{ first @{@} @} // Error
@item

@item
first @{ external @{@} @} // OK
@item
external @{ first @{@} @} // OK
@item
@}
@end enumerate

In the code above, both of the parameters to
@samp{takesTwoFunctions(first:second:)} are functions. Neither parameter is
marked @samp{@@escaping}, so they're both nonescaping as a result.

The four function calls marked “Error” in the example above cause
compiler errors. Because the @samp{first} and @samp{second} parameters are
nonescaping functions, they can't be passed as arguments to another
nonescaping function parameter. In contrast, the two function calls
marked “OK” don't cause a compiler error. These function calls don't
violate the restriction because @samp{external} isn't one of the parameters
of @samp{takesTwoFunctions(first:second:)}.

If you need to avoid this restriction, mark one of the parameters as
escaping, or temporarily convert one of the nonescaping function
parameters to an escaping function by using the
@samp{withoutActuallyEscaping(_:do:)} function. For information about
avoiding conflicting access to memory, see
@ref{Memory Safety,Memory Safety,,swift,}.

Grammar of a function type

function-type →
attributes
_@{opt@}
function-type-argument-clause
@samp{throws=_@{opt@} =->}
type

function-type →
attributes
_@{opt@}
function-type-argument-clause
@samp{rethrows} @samp{->} type

function-type-argument-clause
→ @samp{(} @samp{)}

function-type-argument-clause
→ @samp{(}
function-type-argument-list
@samp{...=_@{opt@} =)}

function-type-argument-list
→
function-type-argument
@multitable {}
@item
@end multitable
function-type-argument
@samp{,}
function-type-argument-list

function-type-argument →
attributes
_@{opt@} =inout=@math{_opt}
type |
argument-label
type-annotation

argument-label →
identifier

@node Array Type
@section Array Type

The Swift language provides the following syntactic sugar for the Swift
standard library @samp{Array<Element>} type:

@enumerate
@item
[type]
@end enumerate

In other words, the following two declarations are equivalent:

@enumerate
@item
let someArray: Array<String> = ["Alex", "Brian", "Dave"]
@item
let someArray: [String] = ["Alex", "Brian", "Dave"]
@end enumerate

In both cases, the constant @samp{someArray} is declared as an array of
strings. The elements of an array can be accessed through subscripting
by specifying a valid index value in square brackets: @samp{someArray[0]}
refers to the element at index 0, @samp{"Alex"}.

You can create multidimensional arrays by nesting pairs of square
brackets, where the name of the base type of the elements is contained
in the innermost pair of square brackets. For example, you can create a
three-dimensional array of integers using three sets of square brackets:

@example
var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
@end example

When accessing the elements in a multidimensional array, the left-most
subscript index refers to the element at that index in the outermost
array. The next subscript index to the right refers to the element at
that index in the array that's nested one level in. And so on. This
means that in the example above, @samp{array3D[0]} refers to
@samp{[[1, 2], [3, 4]]}, @samp{array3D[0][1]} refers to @samp{[3, 4]}, and
@samp{array3D[0][1][1]} refers to the value 4.

For a detailed discussion of the Swift standard library @samp{Array} type,
see @ref{Arrays,Arrays,,swift,}.

Grammar of an array type

array-type → @samp{[}
type @samp{]}

@node Dictionary Type
@section Dictionary Type

The Swift language provides the following syntactic sugar for the Swift
standard library @samp{Dictionary<Key, Value>} type:

@enumerate
@item
[key type: value type]
@end enumerate

In other words, the following two declarations are equivalent:

@enumerate
@item
let someDictionary: [String: Int] = ["Alex": 31, "Paul": 39]
@item
let someDictionary: Dictionary<String, Int> = ["Alex": 31, "Paul":
39]
@end enumerate

In both cases, the constant @samp{someDictionary} is declared as a dictionary
with strings as keys and integers as values.

The values of a dictionary can be accessed through subscripting by
specifying the corresponding key in square brackets:
@samp{someDictionary["Alex"]} refers to the value associated with the key
@samp{"Alex"}. The subscript returns an optional value of the dictionary's
value type. If the specified key isn't contained in the dictionary, the
subscript returns @samp{nil}.

The key type of a dictionary must conform to the Swift standard library
@samp{Hashable} protocol.

For a detailed discussion of the Swift standard library @samp{Dictionary}
type, see
@ref{Dictionaries,Dictionaries,,swift,}.

Grammar of a dictionary type

dictionary-type → @samp{[}
type @samp{:}
type @samp{]}

@node Optional Type
@section Optional Type

The Swift language defines the postfix @samp{?} as syntactic sugar for the
named type @samp{Optional<Wrapped>}, which is defined in the Swift standard
library. In other words, the following two declarations are equivalent:

@enumerate
@item
var optionalInteger: Int?
@item
var optionalInteger: Optional<Int>
@end enumerate

In both cases, the variable @samp{optionalInteger} is declared to have the
type of an optional integer. Note that no whitespace may appear between
the type and the @samp{?}.

The type @samp{Optional<Wrapped>} is an enumeration with two cases, @samp{none}
and @samp{some(Wrapped)}, which are used to represent values that may or may
not be present. Any type can be explicitly declared to be (or implicitly
converted to) an optional type. If you don't provide an initial value
when you declare an optional variable or property, its value
automatically defaults to @samp{nil}.

If an instance of an optional type contains a value, you can access that
value using the postfix operator @samp{!}, as shown below:

@enumerate
@item
optionalInteger = 42
@item
optionalInteger! // 42
@end enumerate

Using the @samp{!} operator to unwrap an optional that has a value of @samp{nil}
results in a runtime error.

You can also use optional chaining and optional binding to conditionally
perform an operation on an optional expression. If the value is @samp{nil},
no operation is performed and therefore no runtime error is produced.

For more information and to see examples that show how to use optional
types, see @ref{Optionals,Optionals,,swift,}.

Grammar of an optional type

optional-type →
type @samp{?}

@node Implicitly Unwrapped Optional Type
@section Implicitly Unwrapped Optional Type

The Swift language defines the postfix @samp{!} as syntactic sugar for the
named type @samp{Optional<Wrapped>}, which is defined in the Swift standard
library, with the additional behavior that it's automatically unwrapped
when it's accessed. If you try to use an implicitly unwrapped optional
that has a value of @samp{nil}, you'll get a runtime error. With the
exception of the implicit unwrapping behavior, the following two
declarations are equivalent:

@enumerate
@item
var implicitlyUnwrappedString: String!
@item
var explicitlyUnwrappedString: Optional<String>
@end enumerate

Note that no whitespace may appear between the type and the @samp{!}.

Because implicit unwrapping changes the meaning of the declaration that
contains that type, optional types that are nested inside a tuple type
or a generic type---such as the element types of a dictionary or
array---can't be marked as implicitly unwrapped. For example:

@enumerate
@item
let tupleOfImplicitlyUnwrappedElements: (Int!, Int!) // Error
@item
let implicitlyUnwrappedTuple: (Int, Int)! // OK
@item

@item
let arrayOfImplicitlyUnwrappedElements: [Int!] // Error
@item
let implicitlyUnwrappedArray: [Int]! // OK
@end enumerate

Because implicitly unwrapped optionals have the same @samp{Optional<Wrapped>}
type as optional values, you can use implicitly unwrapped optionals in
all the same places in your code that you can use optionals. For
example, you can assign values of implicitly unwrapped optionals to
variables, constants, and properties of optionals, and vice versa.

As with optionals, if you don't provide an initial value when you
declare an implicitly unwrapped optional variable or property, its value
automatically defaults to @samp{nil}.

Use optional chaining to conditionally perform an operation on an
implicitly unwrapped optional expression. If the value is @samp{nil}, no
operation is performed and therefore no runtime error is produced.

For more information about implicitly unwrapped optional types, see
@ref{Implicitly Unwrapped Optionals,Implicitly Unwrapped
Optionals,,swift,}.

Grammar of an implicitly unwrapped optional type

implicitly-unwrapped-optional-type
→ type @samp{!}

@node Protocol Composition Type
@section Protocol Composition Type

A @emph{protocol composition} type defines a type that conforms to each
protocol in a list of specified protocols, or a type that is a subclass
of a given class and conforms to each protocol in a list of specified
protocols. Protocol composition types may be used only when specifying a
type in type annotations, in generic parameter clauses, and in generic
@samp{where} clauses.

Protocol composition types have the following form:

@enumerate
@item
Protocol 1 & Protocol 2
@end enumerate

A protocol composition type allows you to specify a value whose type
conforms to the requirements of multiple protocols without explicitly
defining a new, named protocol that inherits from each protocol you want
the type to conform to. For example, you can use the protocol
composition type @samp{ProtocolA & ProtocolB & ProtocolC} instead of
declaring a new protocol that inherits from @samp{ProtocolA}, @samp{ProtocolB},
and @samp{ProtocolC}. Likewise, you can use @samp{SuperClass & ProtocolA} instead
of declaring a new protocol that is a subclass of @samp{SuperClass} and
conforms to @samp{ProtocolA}.

Each item in a protocol composition list is one of the following; the
list can contain at most one class:

@itemize
@item
The name of a class

@item
The name of a protocol

@item
A type alias whose underlying type is a protocol composition type, a
protocol, or a class.
@end itemize

When a protocol composition type contains type aliases, it's possible
for the same protocol to appear more than once in the
definitions---duplicates are ignored. For example, the definition of
@samp{PQR} in the code below is equivalent to @samp{P & Q & R}.

@enumerate
@item
typealias PQ = P & Q
@item
typealias PQR = PQ & Q & R
@end enumerate

Grammar of a protocol composition type

protocol-composition-type
→
type-identifier
@samp{&}
protocol-composition-continuation

protocol-composition-continuation
→
type-identifier
@multitable {}
@item
@end multitable
protocol-composition-type

@node Metatype Type
@section Metatype Type

A @emph{metatype type} refers to the type of any type, including class types,
structure types, enumeration types, and protocol types.

The metatype of a class, structure, or enumeration type is the name of
that type followed by @samp{.Type}. The metatype of a protocol type---not the
concrete type that conforms to the protocol at runtime---is the name of
that protocol followed by @samp{.Protocol}. For example, the metatype of the
class type @samp{SomeClass} is @samp{SomeClass.Type} and the metatype of the
protocol @samp{SomeProtocol} is @samp{SomeProtocol.Protocol}.

You can use the postfix @samp{self} expression to access a type as a value.
For example, @samp{SomeClass.self} returns @samp{SomeClass} itself, not an
instance of @samp{SomeClass}. And @samp{SomeProtocol.self} returns @samp{SomeProtocol}
itself, not an instance of a type that conforms to @samp{SomeProtocol} at
runtime. You can call the @samp{type(of:)} function with an instance of a
type to access that instance's dynamic, runtime type as a value, as the
following example shows:

@enumerate
@item
class SomeBaseClass @{
@item
class func printClassName() @{
@item
print("SomeBaseClass")
@item
@}
@item
@}
@item
class SomeSubClass: SomeBaseClass @{
@item
override class func printClassName() @{
@item
print("SomeSubClass")
@item
@}
@item
@}
@item
let someInstance: SomeBaseClass = SomeSubClass()
@item
// The compile-time type of someInstance is SomeBaseClass,
@item
// and the runtime type of someInstance is SomeSubClass
@item
type(of: someInstance).printClassName()
@item
// Prints "SomeSubClass"
@end enumerate

For more information, see
@uref{https://developer.apple.com/documentation/swift/2885064-type, @samp{type(of:)}}
[@uref{https://developer.apple.com/documentation/swift/2885064-type}] in the
Swift standard library.

Use an initializer expression to construct an instance of a type from
that type's metatype value. For class instances, the initializer that's
called must be marked with the @samp{required} keyword or the entire class
marked with the @samp{final} keyword.

@enumerate
@item
class AnotherSubClass: SomeBaseClass @{
@item
let string: String
@item
required init(string: String) @{
@item
self.string = string
@item
@}
@item
override class func printClassName() @{
@item
print("AnotherSubClass")
@item
@}
@item
@}
@item
let metatype: AnotherSubClass.Type = AnotherSubClass.self
@item
let anotherInstance = metatype.init(string: "some string")
@end enumerate

Grammar of a metatype type

metatype-type →
type @samp{.} @samp{Type} |
type @samp{.} @samp{Protocol}

@node Type Inheritance Clause
@section Type Inheritance Clause

A @emph{type inheritance clause} is used to specify which class a named type
inherits from and which protocols a named type conforms to. A type
inheritance clause begins with a colon (@samp{:}), followed by a list of type
identifiers.

Class types can inherit from a single superclass and conform to any
number of protocols. When defining a class, the name of the superclass
must appear first in the list of type identifiers, followed by any
number of protocols the class must conform to. If the class doesn't
inherit from another class, the list can begin with a protocol instead.
For an extended discussion and several examples of class inheritance,
see @ref{Inheritance,Inheritance,,swift,}.

Other named types can only inherit from or conform to a list of
protocols. Protocol types can inherit from any number of other
protocols. When a protocol type inherits from other protocols, the set
of requirements from those other protocols are aggregated together, and
any type that inherits from the current protocol must conform to all of
those requirements.

A type inheritance clause in an enumeration definition can be either a
list of protocols, or in the case of an enumeration that assigns raw
values to its cases, a single, named type that specifies the type of
those raw values. For an example of an enumeration definition that uses
a type inheritance clause to specify the type of its raw values, see
@ref{Raw Values,Raw Values,,swift,}.

Grammar of a type inheritance clause

type-inheritance-clause →
@samp{:}
type-inheritance-list

type-inheritance-list →
type-identifier
@multitable {}
@item
@end multitable
type-identifier
@samp{,}
type-inheritance-list

@node Type Inference
@section Type Inference

Swift uses @emph{type inference} extensively, allowing you to omit the type or
part of the type of many variables and expressions in your code. For
example, instead of writing @samp{var x: Int = 0}, you can write @samp{var x = 0},
omitting the type completely---the compiler correctly infers that @samp{x}
names a value of type @samp{Int}. Similarly, you can omit part of a type when
the full type can be inferred from context. For example, if you write
@samp{let dict: Dictionary = ["A": 1]}, the compiler infers that @samp{dict} has
the type @samp{Dictionary<String, Int>}.

In both of the examples above, the type information is passed up from
the leaves of the expression tree to its root. That is, the type of @samp{x}
in @samp{var x: Int = 0} is inferred by first checking the type of @samp{0} and
then passing this type information up to the root (the variable @samp{x}).

In Swift, type information can also flow in the opposite
direction---from the root down to the leaves. In the following example,
for instance, the explicit type annotation (@samp{: Float}) on the constant
@samp{eFloat} causes the numeric literal @samp{2.71828} to have an inferred type
of @samp{Float} instead of @samp{Double}.

@enumerate
@item
let e = 2.71828 // The type of e is inferred to be Double.
@item
let eFloat: Float = 2.71828 // The type of eFloat is Float.
@end enumerate

Type inference in Swift operates at the level of a single expression or
statement. This means that all of the information needed to infer an
omitted type or part of a type in an expression must be accessible from
type-checking the expression or one of its subexpressions.

@node Expressions
@chapter Expressions

In Swift, there are four kinds of expressions: prefix expressions,
binary expressions, primary expressions, and postfix expressions.
Evaluating an expression returns a value, causes a side effect, or both.

Prefix and binary expressions let you apply operators to smaller
expressions. Primary expressions are conceptually the simplest kind of
expression, and they provide a way to access values. Postfix
expressions, like prefix and binary expressions, let you build up more
complex expressions using postfixes such as function calls and member
access. Each kind of expression is described in detail in the sections
below.

Grammar of an expression

expression →
try-operator
_@{opt@}
prefix-expression
binary-expressions
_@{opt@}

expression-list →
expression
@multitable {}
@item
@end multitable
expression
@samp{,}
expression-list

@menu
* Prefix Expressions::
* Binary Expressions::
* Primary Expressions::
* Postfix Expressions::
@end menu

@node Prefix Expressions
@section Prefix Expressions

@emph{Prefix expressions} combine an optional prefix operator with an
expression. Prefix operators take one argument, the expression that
follows them.

For information about the behavior of these operators, see
@ref{Basic Operators,Basic Operators,,swift,} and
@ref{Advanced Operators,Advanced Operators,,swift,}.

For information about the operators provided by the Swift standard
library, see
@uref{https://developer.apple.com/documentation/swift/operator_declarations, Operator
Declarations}
[@uref{https://developer.apple.com/documentation/swift/operator_declarations}].

In addition to the standard library operators, you use @samp{&} immediately
before the name of a variable that's being passed as an in-out argument
to a function call expression. For more information and to see an
example, see @ref{In-Out Parameters, , In-Out
Parameters}.

Grammar of a prefix expression

prefix-expression →
prefix-operator
_@{opt@}
postfix-expression

prefix-expression →
in-out-expression

in-out-expression → @samp{&}
identifier

@menu
* Try Operator::
@end menu

@node Try Operator
@subsection Try Operator

A @emph{try expression} consists of the @samp{try} operator followed by an
expression that can throw an error. It has the following form:

@enumerate
@item
try expression
@end enumerate

An @emph{optional-try expression} consists of the @samp{try?} operator followed by
an expression that can throw an error. It has the following form:

@enumerate
@item
try? expression
@end enumerate

If the @emph{expression} does not throw an error, the value of the
optional-try expression is an optional containing the value of the
@emph{expression}. Otherwise, the value of the optional-try expression is
@samp{nil}.

A @emph{forced-try expression} consists of the @samp{try!} operator followed by an
expression that can throw an error. It has the following form:

@enumerate
@item
try! expression
@end enumerate

If the @emph{expression} throws an error, a runtime error is produced.

When the expression on the left-hand side of a binary operator is marked
with @samp{try}, @samp{try?}, or @samp{try!}, that operator applies to the whole binary
expression. That said, you can use parentheses to be explicit about the
scope of the operator's application.

@enumerate
@item
sum = try someThrowingFunction() + anotherThrowingFunction() // try
applies to both function calls
@item
sum = try (someThrowingFunction() + anotherThrowingFunction()) // try
applies to both function calls
@item
sum = (try someThrowingFunction()) + anotherThrowingFunction() //
Error: try applies only to the first function call
@end enumerate

A @samp{try} expression can't appear on the right-hand side of a binary
operator, unless the binary operator is the assignment operator or the
@samp{try} expression is enclosed in parentheses.

For more information and to see examples of how to use @samp{try}, @samp{try?},
and @samp{try!}, see @ref{Error Handling,Error
Handling,,swift,}.

Grammar of a try expression

try-operator → @samp{try} | @samp{try}
@samp{?} | @samp{try} @samp{!}

@node Binary Expressions
@section Binary Expressions

@emph{Binary expressions} combine an infix binary operator with the
expression that it takes as its left-hand and right-hand arguments. It
has the following form:

@enumerate
@item
left-hand argument operator right-hand argument
@end enumerate

For information about the behavior of these operators, see
@ref{Basic Operators,Basic Operators,,swift,} and
@ref{Advanced Operators,Advanced Operators,,swift,}.

For information about the operators provided by the Swift standard
library, see
@uref{https://developer.apple.com/documentation/swift/operator_declarations, Operator
Declarations}
[@uref{https://developer.apple.com/documentation/swift/operator_declarations}].

Note

At parse time, an expression made up of binary operators is represented
as a flat list. This list is transformed into a tree by applying
operator precedence. For example, the expression @samp{2 + 3 * 5} is
initially understood as a flat list of five items, @samp{2}, @samp{+}, @samp{3}, @samp{*},
and @samp{5}. This process transforms it into the tree (2 + (3 * 5)).

Grammar of a binary expression

binary-expression →
binary-operator
prefix-expression

binary-expression →
assignment-operator
try-operator
_@{opt@}
prefix-expression

binary-expression →
conditional-operator
try-operator
_@{opt@}
prefix-expression

binary-expression →
type-casting-operator

binary-expressions →
binary-expression
binary-expressions
_@{opt@}

@menu
* Assignment Operator::
* Type-Casting Operators::
@end menu

@node Assignment Operator
@subsection Assignment Operator

The @emph{assignment operator} sets a new value for a given expression. It
has the following form:

@enumerate
@item
expression = value
@end enumerate

The value of the @emph{expression} is set to the value obtained by evaluating
the @emph{value}. If the @emph{expression} is a tuple, the @emph{value} must be a tuple
with the same number of elements. (Nested tuples are allowed.)
Assignment is performed from each part of the @emph{value} to the
corresponding part of the @emph{expression}. For example:

@enumerate
@item
(a, _, (b, c)) = ("test", 9.45, (12, 3))
@item
// a is "test", b is 12, c is 3, and 9.45 is ignored
@end enumerate

The assignment operator does not return any value.

Grammar of an assignment operator

assignment-operator →
@samp{=}


@strong{*} Ternary Conditional Operator

The @emph{ternary conditional operator} evaluates to one of two given values
based on the value of a condition. It has the following form:

@enumerate
@item
condition ? expression used if true : expression used if false
@end enumerate

If the @emph{condition} evaluates to @samp{true}, the conditional operator
evaluates the first expression and returns its value. Otherwise, it
evaluates the second expression and returns its value. The unused
expression is not evaluated.

For an example that uses the ternary conditional operator, see
@ref{Ternary Conditional Operator,Ternary Conditional
Operator,,swift,}.

Grammar of a conditional operator

conditional-operator →
@samp{?}
expression
@samp{:}

@node Type-Casting Operators
@subsection Type-Casting Operators

There are four type-casting operators: the @samp{is} operator, the @samp{as}
operator, the @samp{as?} operator, and the @samp{as!} operator.

They have the following form:

@enumerate
@item
expression is type
@item
expression as type
@item
expression as? type
@item
expression as! type
@end enumerate

The @samp{is} operator checks at runtime whether the @emph{expression} can be cast
to the specified @emph{type}. It returns @samp{true} if the @emph{expression} can be
cast to the specified @emph{type}; otherwise, it returns @samp{false}.

The @samp{as} operator performs a cast when it is known at compile time that
the cast always succeeds, such as upcasting or bridging. Upcasting lets
you use an expression as an instance of its type's supertype, without
using an intermediate variable. The following approaches are equivalent:

@enumerate
@item
func f(_ any: Any) @{ print("Function for Any") @}
@item
func f(_ int: Int) @{ print("Function for Int") @}
@item
let x = 10
@item
f(x)
@item
// Prints "Function for Int"
@item

@item
let y: Any = x
@item
f(y)
@item
// Prints "Function for Any"
@item

@item
f(x as Any)
@item
// Prints "Function for Any"
@end enumerate

Bridging lets you use an expression of a Swift standard library type
such as @samp{String} as its corresponding Foundation type such as @samp{NSString}
without needing to create a new instance. For more information on
bridging, see
@uref{https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types, Working
with Foundation Types}
[@uref{https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types}].

The @samp{as?} operator performs a conditional cast of the @emph{expression} to
the specified @emph{type}. The @samp{as?} operator returns an optional of the
specified @emph{type}. At runtime, if the cast succeeds, the value of
@emph{expression} is wrapped in an optional and returned; otherwise, the
value returned is @samp{nil}. If casting to the specified @emph{type} is
guaranteed to fail or is guaranteed to succeed, a compile-time error is
raised.

The @samp{as!} operator performs a forced cast of the @emph{expression} to the
specified @emph{type}. The @samp{as!} operator returns a value of the specified
@emph{type}, not an optional type. If the cast fails, a runtime error is
raised. The behavior of @samp{x as! T} is the same as the behavior of
@samp{(x as? T)!}.

For more information about type casting and to see examples that use the
type-casting operators, see @ref{Type Casting,Type
Casting,,swift,}.

Grammar of a type-casting operator

type-casting-operator
→ @samp{is} type

type-casting-operator
→ @samp{as} type

type-casting-operator
→ @samp{as} @samp{?} type

type-casting-operator
→ @samp{as} @samp{!} type

@node Primary Expressions
@section Primary Expressions

@emph{Primary expressions} are the most basic kind of expression. They can be
used as expressions on their own, and they can be combined with other
tokens to make prefix expressions, binary expressions, and postfix
expressions.

Grammar of a primary expression

primary-expression →
identifier
generic-argument-clause
_@{opt@}

primary-expression
→
literal-expression

primary-expression
→
self-expression

primary-expression
→
superclass-expression

primary-expression
→
closure-expression

primary-expression
→
parenthesized-expression

primary-expression
→
tuple-expression

primary-expression
→
implicit-member-expression

primary-expression
→
wildcard-expression

primary-expression
→
key-path-expression

primary-expression
→
selector-expression

primary-expression
→
key-path-string-expression

@menu
* Literal Expression::
* Self Expression::
* Superclass Expression::
* Closure Expression::
* Implicit Member Expression::
* Parenthesized Expression::
* Tuple Expression::
* Wildcard Expression::
* Key-Path Expression::
* Selector Expression::
* Key-Path String Expression::
@end menu

@node Literal Expression
@subsection Literal Expression

A @emph{literal expression} consists of either an ordinary literal (such as a
string or a number), an array or dictionary literal, a playground
literal, or one of the following special literals:

@findex #file
@findex #line
@findex #column
@findex #function
@findex #dsohandle

@multitable {aaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Literal
@tab Type
@tab Value
@item @samp{#file}
@tab @samp{String}
@tab The name of the file in which it appears.
@item @samp{#line}
@tab @samp{Int}
@tab The line number on which it appears.
@item @samp{#column}
@tab @samp{Int}
@tab The column number in which it begins.
@item @samp{#function}
@tab @samp{String}
@tab The name of the declaration in which it appears.
@item @samp{#dsohandle}
@tab @samp{UnsafeRawPointer}
@tab The DSO (dynamic shared object) handle in use where it appears.
@end multitable

Inside a function, the value of @samp{#function} is the name of that
function, inside a method it is the name of that method, inside a
property getter or setter it is the name of that property, inside
special members like @samp{init} or @samp{subscript} it is the name of that
keyword, and at the top level of a file it is the name of the current
module.

When used as the default value of a function or method parameter, the
special literal's value is determined when the default value expression
is evaluated at the call site.

@enumerate
@item
func logFunctionName(string: String = #function) @{
@item
print(string)
@item
@}
@item
func myFunction() @{
@item
logFunctionName() // Prints "myFunction()".
@item
@}
@end enumerate

An @emph{array literal} is an ordered collection of values. It has the
following form:

@enumerate
@item
[value 1, value 2, @dots{}]
@end enumerate

The last expression in the array can be followed by an optional comma.
The value of an array literal has type @samp{[T]}, where @samp{T} is the type of
the expressions inside it. If there are expressions of multiple types,
@samp{T} is their closest common supertype. Empty array literals are written
using an empty pair of square brackets and can be used to create an
empty array of a specified type.

@enumerate
@item
var emptyArray: [Double] = []
@end enumerate

A @emph{dictionary literal} is an unordered collection of key-value pairs. It
has the following form:

@enumerate
@item
[key 1: value 1, key 2: value 2, @dots{}]
@end enumerate

The last expression in the dictionary can be followed by an optional
comma. The value of a dictionary literal has type @samp{[Key: Value]}, where
@samp{Key} is the type of its key expressions and @samp{Value} is the type of its
value expressions. If there are expressions of multiple types, @samp{Key} and
@samp{Value} are the closest common supertype for their respective values. An
empty dictionary literal is written as a colon inside a pair of brackets
(@samp{[:]}) to distinguish it from an empty array literal. You can use an
empty dictionary literal to create an empty dictionary literal of
specified key and value types.

@enumerate
@item
var emptyDictionary: [String: Double] = [:]
@end enumerate

@findex #colorLiteral
@findex #imageLiteral

A @emph{playground literal} is used by Xcode to create an interactive
representation of a color, file, or image within the program editor.
Playground literals in plain text outside of Xcode are represented using
a special literal syntax.

For information on using playground literals in Xcode, see
@uref{https://help.apple.com/xcode/mac/current/#/dev4c60242fc, Add a color,
file, or image literal}
[@uref{https://help.apple.com/xcode/mac/current/#/dev4c60242fc}] in Xcode Help.

Grammar of a literal expression

literal-expression →
literal

literal-expression
→
array-literal
@multitable {}
@item
@end multitable
dictionary-literal
@multitable {}
@item
@end multitable
playground-literal

literal-expression
→ @samp{#file} | @samp{#line} | @samp{#column} | @samp{#function} | @samp{#dsohandle}

array-literal → @samp{[}
array-literal-items
_@{opt@} @samp{]}

array-literal-items →
array-literal-item
=,=@math{_opt} |
array-literal-item
@samp{,}
array-literal-items

array-literal-item →
expression

dictionary-literal → @samp{[}
dictionary-literal-items
@samp{]} | @samp{[} @samp{:} @samp{]}

dictionary-literal-items
→
dictionary-literal-item
=,=@math{_opt} |
dictionary-literal-item
@samp{,}
dictionary-literal-items

dictionary-literal-item
→
expression
@samp{:}
expression

playground-literal →
@samp{#colorLiteral} @samp{(} @samp{red} @samp{:}
expression
@samp{,} @samp{green} @samp{:}
expression
@samp{,} @samp{blue} @samp{:}
expression
@samp{,} @samp{alpha} @samp{:}
expression
@samp{)}

playground-literal
→ @samp{#fileLiteral} @samp{(} @samp{resourceName} @samp{:}
expression
@samp{)}

playground-literal
→ @samp{#imageLiteral} @samp{(} @samp{resourceName} @samp{:}
expression
@samp{)}

@node Self Expression
@subsection Self Expression

The @samp{self} expression is an explicit reference to the current type or
instance of the type in which it occurs. It has the following forms:

@enumerate
@item
self
@item
self.member name
@item
self[subscript index]
@item
self(initializer arguments)
@item
self.init(initializer arguments)
@end enumerate

In an initializer, subscript, or instance method, @samp{self} refers to the
current instance of the type in which it occurs. In a type method,
@samp{self} refers to the current type in which it occurs.

The @samp{self} expression is used to specify scope when accessing members,
providing disambiguation when there is another variable of the same name
in scope, such as a function parameter. For example:

@enumerate
@item
class SomeClass @{
@item
var greeting: String
@item
init(greeting: String) @{
@item
self.greeting = greeting
@item
@}
@item
@}
@end enumerate

In a mutating method of a value type, you can assign a new instance of
that value type to @samp{self}. For example:

@enumerate
@item
struct Point @{
@item
var x = 0.0, y = 0.0
@item
mutating func moveBy(x deltaX: Double, y deltaY: Double) @{
@item
self = Point(x: x + deltaX, y: y + deltaY)
@item
@}
@item
@}
@end enumerate

Grammar of a self expression

self-expression → @samp{self} |
self-method-expression
@multitable {}
@item
@end multitable
self-subscript-expression
@multitable {}
@item
@end multitable
self-initializer-expression

self-method-expression
→ @samp{self} @samp{.}
identifier

self-subscript-expression
→ @samp{self} @samp{[}
function-call-argument-list
@samp{]}

self-initializer-expression
→ @samp{self} @samp{.} @samp{init}

@node Superclass Expression
@subsection Superclass Expression

A @emph{superclass expression} lets a class interact with its superclass. It
has one of the following forms:

@enumerate
@item
super.member name
@item
super[subscript index]
@item
super.init(initializer arguments)
@end enumerate

The first form is used to access a member of the superclass. The second
form is used to access the superclass's subscript implementation. The
third form is used to access an initializer of the superclass.

Subclasses can use a superclass expression in their implementation of
members, subscripting, and initializers to make use of the
implementation in their superclass.

Grammar of a superclass expression

superclass-expression
→
superclass-method-expression
@multitable {}
@item
@end multitable
superclass-subscript-expression
@multitable {}
@item
@end multitable
superclass-initializer-expression

superclass-method-expression
→ @samp{super} @samp{.}
identifier

superclass-subscript-expression
→ @samp{super} @samp{[}
function-call-argument-list
@samp{]}

superclass-initializer-expression
→ @samp{super} @samp{.} @samp{init}

@node Closure Expression
@subsection Closure Expression

A @emph{closure expression} creates a closure, also known as a @emph{lambda} or an
@emph{anonymous function} in other programming languages. Like a function
declaration, a closure contains statements, and it captures constants
and variables from its enclosing scope. It has the following form:

@enumerate
@item
@{ (parameters) -> return type in
@item
statements
@item
@}
@end enumerate

The @emph{parameters} have the same form as the parameters in a function
declaration, as described in @ref{Function Declaration, , Function
Declaration}.

There are several special forms that allow closures to be written more
concisely:

@itemize
@item
A closure can omit the types of its parameters, its return type, or
both. If you omit the parameter names and both types, omit the @samp{in}
keyword before the statements. If the omitted types can't be inferred,
a compile-time error is raised.

@item
A closure may omit names for its parameters. Its parameters are then
implicitly named @samp{$} followed by their position: @samp{$0}, @samp{$1}, @samp{$2}, and
so on.

@item
A closure that consists of only a single expression is understood to
return the value of that expression. The contents of this expression
are also considered when performing type inference on the surrounding
expression.
@end itemize

The following closure expressions are equivalent:

@enumerate
@item
myFunction @{ (x: Int, y: Int) -> Int in
@item
return x + y
@item
@}
@item

@item
myFunction @{ x, y in
@item
return x + y
@item
@}
@item

@item
myFunction @{ return $0 + $1 @}
@item

@item
myFunction @{ $0 + $1 @}
@end enumerate

For information about passing a closure as an argument to a function,
see @ref{Function Call Expression}.

Closure expressions can be used without being stored in a variable or
constant, such as when you immediately use a closure as part of a
function call. The closure expressions passed to @samp{myFunction} in code
above are examples of this kind of immediate use. As a result, whether a
closure expression is escaping or nonescaping depends on the surrounding
context of the expression. A closure expression is nonescaping if it is
called immediately or passed as a nonescaping function argument.
Otherwise, the closure expression is escaping.

For more information about escaping closures, see
@ref{Escaping Closures,Escaping Closures,,swift,}.

@enumerate
@item
Capture Lists


By default, a closure expression captures constants and variables from
its surrounding scope with strong references to those values. You can
use a @emph{capture list} to explicitly control how values are captured in a
closure.

A capture list is written as a comma-separated list of expressions
surrounded by square brackets, before the list of parameters. If you use
a capture list, you must also use the @samp{in} keyword, even if you omit the
parameter names, parameter types, and return type.

The entries in the capture list are initialized when the closure is
created. For each entry in the capture list, a constant is initialized
to the value of the constant or variable that has the same name in the
surrounding scope. For example in the code below, @samp{a} is included in the
capture list but @samp{b} is not, which gives them different behavior.

@enumerate
@item
var a = 0
@item
var b = 0
@item
let closure = @{ [a] in
@item
print(a, b)
@item
@}
@item

@item
a = 10
@item
b = 10
@item
closure()
@item
// Prints "0 10"
@end enumerate

There are two different things named @samp{a}, the variable in the
surrounding scope and the constant in the closure's scope, but only one
variable named @samp{b}. The @samp{a} in the inner scope is initialized with the
value of the @samp{a} in the outer scope when the closure is created, but
their values are not connected in any special way. This means that a
change to the value of @samp{a} in the outer scope does not affect the value
of @samp{a} in the inner scope, nor does a change to @samp{a} inside the closure
affect the value of @samp{a} outside the closure. In contrast, there is only
one variable named @samp{b}---the @samp{b} in the outer scope---so changes from
inside or outside the closure are visible in both places.

This distinction is not visible when the captured variable's type has
reference semantics. For example, there are two things named @samp{x} in the
code below, a variable in the outer scope and a constant in the inner
scope, but they both refer to the same object because of reference
semantics.

@enumerate
@item
class SimpleClass @{
@item
var value: Int = 0
@item
@}
@item
var x = SimpleClass()
@item
var y = SimpleClass()
@item
let closure = @{ [x] in
@item
print(x.value, y.value)
@item
@}
@item

@item
x.value = 10
@item
y.value = 10
@item
closure()
@item
// Prints "10 10"
@end enumerate

If the type of the expression's value is a class, you can mark the
expression in a capture list with @samp{weak} or @samp{unowned} to capture a weak
or unowned reference to the expression's value.

@enumerate
@item
myFunction @{ print(self.title) @} // implicit strong capture
@item
myFunction @{ [self] in print(self.title) @} // explicit strong capture
@item
myFunction @{ [weak self] in print(self!.title) @} // weak capture
@item
myFunction @{ [unowned self] in print(self.title) @} // unowned capture
@end enumerate

You can also bind an arbitrary expression to a named value in a capture
list. The expression is evaluated when the closure is created, and the
value is captured with the specified strength. For example:

@enumerate
@item
// Weak capture of "self.parent" as "parent"
@item
myFunction @{ [weak parent = self.parent] in print(parent!.title) @}
@end enumerate

For more information and examples of closure expressions, see
@ref{Closure Expressions,Closure Expressions,,swift,}. For more
information and examples of capture lists, see
@ref{Resolving Strong Reference Cycles for Closures,Resolving
Strong Reference Cycles for Closures,,swift,}.

Grammar of a closure expression

closure-expression → @samp{@{}
closure-signature
_@{opt@}
statements
_@{opt@} @samp{@}}

closure-signature →
capture-list
_@{opt@}
closure-parameter-clause
=throws=@math{_opt}
function-result
_@{opt@} @samp{in}

closure-signature →
capture-list
@samp{in}

closure-parameter-clause
→ @samp{(} @samp{)} | @samp{(}
closure-parameter-list
@samp{)} |
identifier-list

closure-parameter-list
→
closure-parameter
@multitable {}
@item
@end multitable
closure-parameter
@samp{,}
closure-parameter-list

closure-parameter →
closure-parameter-name
type-annotation
_@{opt@}

closure-parameter →
closure-parameter-name
type-annotation
@samp{...}

closure-parameter-name
→
identifier

capture-list → @samp{[}
capture-list-items
@samp{]}

capture-list-items →
capture-list-item
@multitable {}
@item
@end multitable
capture-list-item
@samp{,}
capture-list-items

capture-list-item →
capture-specifier
_@{opt@}
expression

capture-specifier →
@samp{weak} | @samp{unowned} | @samp{unowned(safe)} | @samp{unowned(unsafe)}
@end enumerate

@node Implicit Member Expression
@subsection Implicit Member Expression

An @emph{implicit member expression} is an abbreviated way to access a member
of a type, such as an enumeration case or a type method, in a context
where type inference can determine the implied type. It has the
following form:

@enumerate
@item
.member name
@end enumerate

For example:

@enumerate
@item
var x = MyEnumeration.someValue
@item
x = .anotherValue
@end enumerate

Grammar of a implicit member expression

implicit-member-expression
→ @samp{.}
identifier

@node Parenthesized Expression
@subsection Parenthesized Expression

A @emph{parenthesized expression} consists of an expression surrounded by
parentheses. You can use parentheses to specify the precedence of
operations by explicitly grouping expressions. Grouping parentheses
don't change an expression's type---for example, the type of @samp{(1)} is
simply @samp{Int}.

Grammar of a parenthesized expression

parenthesized-expression
→ @samp{(}
expression
@samp{)}

@node Tuple Expression
@subsection Tuple Expression

A @emph{tuple expression} consists of a comma-separated list of expressions
surrounded by parentheses. Each expression can have an optional
identifier before it, separated by a colon (@samp{:}). It has the following
form:

@enumerate
@item
(identifier 1: expression 1, identifier 2: expression 2, @dots{})
@end enumerate

A tuple expression can contain zero expressions, or it can contain two
or more expressions. A single expression inside parentheses is a
parenthesized expression.

Note

Both an empty tuple expression and an empty tuple type are written @samp{()}
in Swift. Because @samp{Void} is a type alias for @samp{()}, you can use it to
write an empty tuple type. However, like all type aliases, @samp{Void} is
always a type---you can't use it to write an empty tuple expression.

Grammar of a tuple expression

tuple-expression → @samp{(} @samp{)}
@multitable {aaa}
@item @samp{(}
@end multitable
tuple-element
@samp{,}
tuple-element-list
@samp{)}

tuple-element-list →
tuple-element
@multitable {}
@item
@end multitable
tuple-element
@samp{,}
tuple-element-list

tuple-element →
expression
@multitable {}
@item
@end multitable
identifier
@samp{:}
expression

@node Wildcard Expression
@subsection Wildcard Expression

A @emph{wildcard expression} is used to explicitly ignore a value during an
assignment. For example, in the following assignment 10 is assigned to
@samp{x} and 20 is ignored:

@enumerate
@item
(x, _) = (10, 20)
@item
// x is 10, and 20 is ignored
@end enumerate

Grammar of a wildcard expression

wildcard-expression →
@samp{_}

@node Key-Path Expression
@subsection Key-Path Expression

A @emph{key-path expression} refers to a property or subscript of a type. You
use key-path expressions in dynamic programming tasks, such as key-value
observing. They have the following form:

@enumerate
@item
name.path
@end enumerate

The @emph{type name} is the name of a concrete type, including any generic
parameters, such as @samp{String}, @samp{[Int]}, or @samp{Set<Int>}.

The @emph{path} consists of property names, subscripts, optional-chaining
expressions, and forced unwrapping expressions. Each of these key-path
components can be repeated as many times as needed, in any order.

At compile time, a key-path expression is replaced by an instance of the
@uref{https://developer.apple.com/documentation/swift/keypath, @samp{KeyPath}}
[@uref{https://developer.apple.com/documentation/swift/keypath}] class.

To access a value using a key path, pass the key path to the
@samp{subscript(keyPath:)} subscript, which is available on all types. For
example:

@enumerate
@item
struct SomeStructure @{
@item
var someValue: Int
@item
@}
@item

@item
let s = SomeStructure(someValue: 12)
@item
let pathToProperty = .someValue
@item

@item
let value = s[keyPath: pathToProperty]
@item
// value is 12
@end enumerate

The @emph{type name} can be omitted in contexts where type inference can
determine the implied type. The following code uses @samp{\.someProperty}
instead of @samp{\SomeClass.someProperty}:

@enumerate
@item
class SomeClass: NSObject @{
@item
@@objc var someProperty: Int
@item
init(someProperty: Int) @{
@item
self.someProperty = someProperty
@item
@}
@item
@}
@item

@item
let c = SomeClass(someProperty: 10)
@item
c.observe(\.someProperty) @{ object, change in
@item
// @dots{}
@item
@}
@end enumerate

The @emph{path} can refer to @samp{self} to create the identity key path
(@samp{\.self}). The identity key path refers to a whole instance, so you can
use it to access and change all of the data stored in a variable in a
single step. For example:

@enumerate
@item
var compoundValue = (a: 1, b: 2)
@item
// Equivalent to compoundValue = (a: 10, b: 20)
@item
compoundValue[keyPath: \.self] = (a: 10, b: 20)
@end enumerate

The @emph{path} can contain multiple property names, separated by periods, to
refer to a property of a property's value. This code uses the key path
expression @samp{\OuterStructure.outer.someValue} to access the @samp{someValue}
property of the @samp{OuterStructure} type's @samp{outer} property:

@enumerate
@item
struct OuterStructure @{
@item
var outer: SomeStructure
@item
init(someValue: Int) @{
@item
self.outer = SomeStructure(someValue: someValue)
@item
@}
@item
@}
@item

@item
let nested = OuterStructure(someValue: 24)
@item
let nestedKeyPath = .outer.someValue
@item

@item
let nestedValue = nested[keyPath: nestedKeyPath]
@item
// nestedValue is 24
@end enumerate

The @emph{path} can include subscripts using brackets, as long as the
subscript's parameter type conforms to the @samp{Hashable} protocol. This
example uses a subscript in a key path to access the second element of
an array:

@enumerate
@item
let greetings = ["hello", "hola", "bonjour", "안녕"]
@item
let myGreeting = greetings[keyPath: \[String].[1]]
@item
// myGreeting is 'hola'
@end enumerate

The value used in a subscript can be a named value or a literal. Values
are captured in key paths using value semantics. The following code uses
the variable @samp{index} in both a key-path expression and in a closure to
access the third element of the @samp{greetings} array. When @samp{index} is
modified, the key-path expression still references the third element,
while the closure uses the new index.

@enumerate
@item
var index = 2
@item
let path = \[String].[index]
@item
let fn: ([String]) -> String = @{ strings in strings[index] @}
@item

@item
print(greetings[keyPath: path])
@item
// Prints "bonjour"
@item
print(fn(greetings))
@item
// Prints "bonjour"
@item

@item
// Setting 'index' to a new value doesn't affect 'path'
@item
index += 1
@item
print(greetings[keyPath: path])
@item
// Prints "bonjour"
@item

@item
// Because 'fn' closes over 'index', it uses the new value
@item
print(fn(greetings))
@item
// Prints "안녕"
@end enumerate

The @emph{path} can use optional chaining and forced unwrapping. This code
uses optional chaining in a key path to access a property of an optional
string:

@enumerate
@item
let firstGreeting: String? = greetings.first
@item
print(firstGreeting?.count as Any)
@item
// Prints "Optional(5)"
@item

@item
// Do the same thing using a key path.
@item
let count = greetings[keyPath: \[String].first?.count]
@item
print(count as Any)
@item
// Prints "Optional(5)"
@end enumerate

You can mix and match components of key paths to access values that are
deeply nested within a type. The following code accesses different
values and properties of a dictionary of arrays by using key-path
expressions that combine these components.

@enumerate
@item
let interestingNumbers = ["prime": [2, 3, 5, 7, 11, 13, 17],
@item
"triangular": [1, 3, 6, 10, 15, 21, 28],
@item
"hexagonal": [1, 6, 15, 28, 45, 66, 91]]
@item
print(interestingNumbers[keyPath: \[String: [Int]].["prime"]] as
Any)
@item
// Prints "Optional([2, 3, 5, 7, 11, 13, 17])"
@item
print(interestingNumbers[keyPath: \[String: [Int]].["prime"]![0]])
@item
// Prints "2"
@item
print(interestingNumbers[keyPath: \[String:
[Int]].["hexagonal"]!.count])
@item
// Prints "7"
@item
print(interestingNumbers[keyPath: \[String:
[Int]].["hexagonal"]!.count.bitWidth])
@item
// Prints "64"
@end enumerate

For more information about using key paths in code that interacts with
Objective-C APIs, see
@uref{https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift, Using
Objective-C Runtime Features in Swift}
[@uref{https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift}].
For information about key-value coding and key-value observing, see
@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i, Key-Value
Coding Programming Guide}
[@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i}]
and
@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i, Key-Value
Observing Programming Guide}
[@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i}].

Grammar of a key-path expression

key-path-expression →
@samp{\} type _@{opt@} @samp{.}
key-path-components

key-path-components →
key-path-component
@multitable {}
@item
@end multitable
key-path-component
@samp{.}
key-path-components

key-path-component →
identifier
key-path-postfixes
_@{opt@} |
key-path-postfixes

key-path-postfixes →
key-path-postfix
key-path-postfixes
_@{opt@}

key-path-postfix → @samp{?} |
@samp{!} | @samp{self} | @samp{[}
function-call-argument-list
@samp{]}

@node Selector Expression
@subsection Selector Expression

A selector expression lets you access the selector used to refer to a
method or to a property's getter or setter in Objective-C. It has the
following form:

@findex #selector

@enumerate
@item
#selector(method name)
@item
#selector(getter: property name)
@item
#selector(setter: property name)
@end enumerate

The @emph{method name} and @emph{property name} must be a reference to a method or
a property that is available in the Objective-C runtime. The value of a
selector expression is an instance of the @samp{Selector} type. For example:

@enumerate
@item
class SomeClass: NSObject @{
@item
@@objc let property: String
@item
@@objc(doSomethingWithInt:)
@item
func doSomething(_ x: Int) @{@}
@item

@item
init(property: String) @{
@item
self.property = property
@item
@}
@item
@}
@item
let selectorForMethod = #selector(SomeClass.doSomething(_:))
@item
let selectorForPropertyGetter = #selector(getter:
SomeClass.property)
@end enumerate

When creating a selector for a property's getter, the @emph{property name}
can be a reference to a variable or constant property. In contrast, when
creating a selector for a property's setter, the @emph{property name} must be
a reference to a variable property only.

The @emph{method name} can contain parentheses for grouping, as well the @samp{as}
operator to disambiguate between methods that share a name but have
different type signatures. For example:

@enumerate
@item
extension SomeClass @{
@item
@@objc(doSomethingWithString:)
@item
func doSomething(_ x: String) @{ @}
@item
@}
@item
let anotherSelector = #selector(SomeClass.doSomething(_:) as
(SomeClass) -> (String) -> Void)
@end enumerate

Because a selector is created at compile time, not at runtime, the
compiler can check that a method or property exists and that they're
exposed to the Objective-C runtime.

Note

Although the @emph{method name} and the @emph{property name} are expressions,
they're never evaluated.

For more information about using selectors in Swift code that interacts
with Objective-C APIs, see
@uref{https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift, Using
Objective-C Runtime Features in Swift}
[@uref{https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift}].

Grammar of a selector expression

selector-expression →
@samp{#selector} @samp{(}
expression
@samp{)}

selector-expression
→ @samp{#selector} @samp{(} @samp{getter:}
expression
@samp{)}

selector-expression
→ @samp{#selector} @samp{(} @samp{setter:}
expression
@samp{)}

@node Key-Path String Expression
@subsection Key-Path String Expression

A key-path string expression lets you access the string used to refer to
a property in Objective-C, for use in key-value coding and key-value
observing APIs. It has the following form:

@enumerate
@item
#keyPath(property name)
@end enumerate

The @emph{property name} must be a reference to a property that is available
in the Objective-C runtime. At compile time, the key-path string
expression is replaced by a string literal. For example:

@enumerate
@item
class SomeClass: NSObject @{
@item
@@objc var someProperty: Int
@item
init(someProperty: Int) @{
@item
self.someProperty = someProperty
@item
@}
@item
@}
@item

@item
let c = SomeClass(someProperty: 12)
@item
let keyPath = #keyPath(SomeClass.someProperty)
@item

@item
if let value = c.value(forKey: keyPath) @{
@item
print(value)
@item
@}
@item
// Prints "12"
@end enumerate

When you use a key-path string expression within a class, you can refer
to a property of that class by writing just the property name, without
the class name.

@enumerate
@item
extension SomeClass @{
@item
func getSomeKeyPath() -> String @{
@item
return #keyPath(someProperty)
@item
@}
@item
@}
@item
print(keyPath == c.getSomeKeyPath())
@item
// Prints "true"
@end enumerate

Because the key path string is created at compile time, not at runtime,
the compiler can check that the property exists and that the property is
exposed to the Objective-C runtime.

For more information about using key paths in Swift code that interacts
with Objective-C APIs, see
@uref{https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift, Using
Objective-C Runtime Features in Swift}
[@uref{https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift}].
For information about key-value coding and key-value observing, see
@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i, Key-Value
Coding Programming Guide}
[@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i}]
and
@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i, Key-Value
Observing Programming Guide}
[@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i}].

Note

Although the @emph{property name} is an expression, it is never evaluated.

Grammar of a key-path string expression

key-path-string-expression
→ @samp{#keyPath} @samp{(}
expression
@samp{)}

@node Postfix Expressions
@section Postfix Expressions

@emph{Postfix expressions} are formed by applying a postfix operator or other
postfix syntax to an expression. Syntactically, every primary expression
is also a postfix expression.

For information about the behavior of these operators, see
@ref{Basic Operators,Basic Operators,,swift,} and
@ref{Advanced Operators,Advanced Operators,,swift,}.

For information about the operators provided by the Swift standard
library, see
@uref{https://developer.apple.com/documentation/swift/operator_declarations, Operator
Declarations}
[@uref{https://developer.apple.com/documentation/swift/operator_declarations}].

Grammar of a postfix expression

postfix-expression →
primary-expression

postfix-expression
→
postfix-expression
postfix-operator

postfix-expression
→
function-call-expression

postfix-expression
→
initializer-expression

postfix-expression
→
explicit-member-expression

postfix-expression
→
postfix-self-expression

postfix-expression
→
subscript-expression

postfix-expression
→
forced-value-expression

postfix-expression
→
optional-chaining-expression

@menu
* Function Call Expression::
* Initializer Expression::
* Explicit Member Expression::
* Postfix Self Expression::
* Subscript Expression::
* Forced-Value Expression::
* Optional-Chaining Expression::
@end menu

@node Function Call Expression
@subsection Function Call Expression

A @emph{function call expression} consists of a function name followed by a
comma-separated list of the function's arguments in parentheses.
Function call expressions have the following form:

@enumerate
@item
function name(argument value 1, argument value 2)
@end enumerate

The @emph{function name} can be any expression whose value is of a function
type.

If the function definition includes names for its parameters, the
function call must include names before its argument values separated by
a colon (@samp{:}). This kind of function call expression has the following
form:

@enumerate
@item
function name(argument name 1: argument value 1, argument name 2:
argument value 2)
@end enumerate

A function call expression can include a trailing closure in the form of
a closure expression immediately after the closing parenthesis. The
trailing closure is understood as an argument to the function, added
after the last parenthesized argument. The following function calls are
equivalent:

@enumerate
@item
// someFunction takes an integer and a closure as its arguments
@item
someFunction(x: x, f: @{$0 == 13@})
@item
someFunction(x: x) @{$0 == 13@}
@end enumerate

If the trailing closure is the function's only argument, the parentheses
can be omitted.

@enumerate
@item
// someMethod takes a closure as its only argument
@item
myData.someMethod() @{$0 == 13@}
@item
myData.someMethod @{$0 == 13@}
@end enumerate

Grammar of a function call expression

function-call-expression
→
postfix-expression
function-call-argument-clause

function-call-expression
→
postfix-expression
function-call-argument-clause
_@{opt@}
trailing-closure

function-call-argument-clause
→ @samp{(} @samp{)} | @samp{(}
function-call-argument-list
@samp{)}

function-call-argument-list
→
function-call-argument
@multitable {}
@item
@end multitable
function-call-argument
@samp{,}
function-call-argument-list

function-call-argument
→
expression
@multitable {}
@item
@end multitable
identifier
@samp{:}
expression

function-call-argument
→
operator
@multitable {}
@item
@end multitable
identifier
@samp{:}
operator

trailing-closure →
closure-expression

@node Initializer Expression
@subsection Initializer Expression

An @emph{initializer expression} provides access to a type's initializer. It
has the following form:

@enumerate
@item
expression.init(initializer arguments)
@end enumerate

You use the initializer expression in a function call expression to
initialize a new instance of a type. You also use an initializer
expression to delegate to the initializer of a superclass.

@enumerate
@item
class SomeSubClass: SomeSuperClass @{
@item
override init() @{
@item
// subclass initialization goes here
@item
super.init()
@item
@}
@item
@}
@end enumerate

Like a function, an initializer can be used as a value. For example:

@enumerate
@item
// Type annotation is required because String has multiple
initializers.
@item
let initializer: (Int) -> String = String.init
@item
let oneTwoThree = [1, 2, 3].map(initializer).reduce("", +)
@item
print(oneTwoThree)
@item
// Prints "123"
@end enumerate

If you specify a type by name, you can access the type's initializer
without using an initializer expression. In all other cases, you must
use an initializer expression.

@enumerate
@item
let s1 = SomeType.init(data: 3) // Valid
@item
let s2 = SomeType(data: 1) // Also valid
@item

@item
let s3 = type(of: someValue).init(data: 7) // Valid
@item
let s4 = type(of: someValue)(data: 5) // Error
@end enumerate

Grammar of an initializer expression

initializer-expression
→
postfix-expression
@samp{.} @samp{init}

initializer-expression
→
postfix-expression
@samp{.} @samp{init} @samp{(}
argument-names
@samp{)}

@node Explicit Member Expression
@subsection Explicit Member Expression

An @emph{explicit member expression} allows access to the members of a named
type, a tuple, or a module. It consists of a period (@samp{.}) between the
item and the identifier of its member.

@enumerate
@item
expression.member name
@end enumerate

The members of a named type are named as part of the type's declaration
or extension. For example:

@enumerate
@item
class SomeClass @{
@item
var someProperty = 42
@item
@}
@item
let c = SomeClass()
@item
let y = c.someProperty // Member access
@end enumerate

The members of a tuple are implicitly named using integers in the order
they appear, starting from zero. For example:

@enumerate
@item
var t = (10, 20, 30)
@item
t.0 = t.1
@item
// Now t is (20, 20, 30)
@end enumerate

The members of a module access the top-level declarations of that
module.

Types declared with the @samp{dynamicMemberLookup} attribute include members
that are looked up at runtime, as described in
@ref{Attributes}.

To distinguish between methods or initializers whose names differ only
by the names of their arguments, include the argument names in
parentheses, with each argument name followed by a colon (@samp{:}). Write an
underscore (@samp{_}) for an argument with no name. To distinguish between
overloaded methods, use a type annotation. For example:

@enumerate
@item
class SomeClass @{
@item
func someMethod(x: Int, y: Int) @{@}
@item
func someMethod(x: Int, z: Int) @{@}
@item
func overloadedMethod(x: Int, y: Int) @{@}
@item
func overloadedMethod(x: Int, y: Bool) @{@}
@item
@}
@item
let instance = SomeClass()
@item

@item
let a = instance.someMethod // Ambiguous
@item
let b = instance.someMethod(x:y:) // Unambiguous
@item

@item
let d = instance.overloadedMethod // Ambiguous
@item
let d = instance.overloadedMethod(x:y:) // Still ambiguous
@item
let d: (Int, Bool) -> Void = instance.overloadedMethod(x:y:) //
Unambiguous
@end enumerate

If a period appears at the beginning of a line, it is understood as part
of an explicit member expression, not as an implicit member expression.
For example, the following listing shows chained method calls split over
several lines:

@enumerate
@item
let x = [10, 3, 20, 15, 4]
@item
.sorted()
@item
.filter @{ $0 > 5 @}
@item
.map @{ $0 * 100 @}
@end enumerate

Grammar of an explicit member expression

explicit-member-expression
→
postfix-expression
@samp{.}
decimal-digits

explicit-member-expression
→
postfix-expression
@samp{.}
identifier
generic-argument-clause
_@{opt@}

explicit-member-expression
→
postfix-expression
@samp{.}
identifier
@samp{(}
argument-names
@samp{)}

argument-names →
argument-name
argument-names
_@{opt@}

argument-name →
identifier
@samp{:}

@node Postfix Self Expression
@subsection Postfix Self Expression

A postfix @samp{self} expression consists of an expression or the name of a
type, immediately followed by @samp{.self}. It has the following forms:

@enumerate
@item
expression.self
@item
type.self
@end enumerate

The first form evaluates to the value of the @emph{expression}. For example,
@samp{x.self} evaluates to @samp{x}.

The second form evaluates to the value of the @emph{type}. Use this form to
access a type as a value. For example, because @samp{SomeClass.self}
evaluates to the @samp{SomeClass} type itself, you can pass it to a function
or method that accepts a type-level argument.

Grammar of a postfix self expression

postfix-self-expression
→
postfix-expression
@samp{.} @samp{self}

@node Subscript Expression
@subsection Subscript Expression

A @emph{subscript expression} provides subscript access using the getter and
setter of the corresponding subscript declaration. It has the following
form:

@enumerate
@item
expression[index expressions]
@end enumerate

To evaluate the value of a subscript expression, the subscript getter
for the @emph{expression}'s type is called with the @emph{index expressions}
passed as the subscript parameters. To set its value, the subscript
setter is called in the same way.

For information about subscript declarations, see
@ref{Protocol Subscript Declaration}X.

Grammar of a subscript expression

subscript-expression →
postfix-expression
@samp{[}
function-call-argument-list
@samp{]}

@node Forced-Value Expression
@subsection Forced-Value Expression

A @emph{forced-value expression} unwraps an optional value that you are
certain is not @samp{nil}. It has the following form:

@enumerate
@item
expression!
@end enumerate

If the value of the @emph{expression} is not @samp{nil}, the optional value is
unwrapped and returned with the corresponding non-optional type.
Otherwise, a runtime error is raised.

The unwrapped value of a forced-value expression can be modified, either
by mutating the value itself, or by assigning to one of the value's
members. For example:

@enumerate
@item
var x: Int? = 0
@item
x! += 1
@item
// x is now 1
@item

@item
var someDictionary = ["a": [1, 2, 3], "b": [10, 20]]
@item
someDictionary["a"]![0] = 100
@item
// someDictionary is now ["a": [100, 2, 3], "b": [10, 20]]
@end enumerate

Grammar of a forced-value expression

forced-value-expression
→
postfix-expression
@samp{!}

@node Optional-Chaining Expression
@subsection Optional-Chaining Expression

An @emph{optional-chaining expression} provides a simplified syntax for using
optional values in postfix expressions. It has the following form:

@enumerate
@item
expression?
@end enumerate

The postfix @samp{?} operator makes an optional-chaining expression from an
expression without changing the expression's value.

Optional-chaining expressions must appear within a postfix expression,
and they cause the postfix expression to be evaluated in a special way.
If the value of the optional-chaining expression is @samp{nil}, all of the
other operations in the postfix expression are ignored and the entire
postfix expression evaluates to @samp{nil}. If the value of the
optional-chaining expression is not @samp{nil}, the value of the
optional-chaining expression is unwrapped and used to evaluate the rest
of the postfix expression. In either case, the value of the postfix
expression is still of an optional type.

If a postfix expression that contains an optional-chaining expression is
nested inside other postfix expressions, only the outermost expression
returns an optional type. In the example below, when @samp{c} is not @samp{nil},
its value is unwrapped and used to evaluate @samp{.property}, the value of
which is used to evaluate @samp{.performAction()}. The entire expression
@samp{c?.property.performAction()} has a value of an optional type.

@enumerate
@item
var c: SomeClass?
@item
var result: Bool? = c?.property.performAction()
@end enumerate

The following example shows the behavior of the example above without
using optional chaining.

@enumerate
@item
var result: Bool?
@item
if let unwrappedC = c @{
@item
result = unwrappedC.property.performAction()
@item
@}
@end enumerate

The unwrapped value of an optional-chaining expression can be modified,
either by mutating the value itself, or by assigning to one of the
value's members. If the value of the optional-chaining expression is
@samp{nil}, the expression on the right-hand side of the assignment operator
is not evaluated. For example:

@enumerate
@item
func someFunctionWithSideEffects() -> Int @{
@item
return 42 // No actual side effects.
@item
@}
@item
var someDictionary = ["a": [1, 2, 3], "b": [10, 20]]
@item

@item
someDictionary["not here"]?[0] = someFunctionWithSideEffects()
@item
// someFunctionWithSideEffects is not evaluated
@item
// someDictionary is still ["a": [1, 2, 3], "b": [10, 20]]
@item

@item
someDictionary["a"]?[0] = someFunctionWithSideEffects()
@item
// someFunctionWithSideEffects is evaluated and returns 42
@item
// someDictionary is now ["a": [42, 2, 3], "b": [10, 20]]
@end enumerate

Grammar of an optional-chaining expression

optional-chaining-expression
→
postfix-expression
@samp{?}

@node Statements
@chapter Statements

In Swift, there are three kinds of statements: simple statements,
compiler control statements, and control flow statements. Simple
statements are the most common and consist of either an expression or a
declaration. Compiler control statements allow the program to change
aspects of the compiler's behavior and include a conditional compilation
block and a line control statement.

Control flow statements are used to control the flow of execution in a
program. There are several types of control flow statements in Swift,
including loop statements, branch statements, and control transfer
statements. Loop statements allow a block of code to be executed
repeatedly, branch statements allow a certain block of code to be
executed only when certain conditions are met, and control transfer
statements provide a way to alter the order in which code is executed.
In addition, Swift provides a @samp{do} statement to introduce scope, and
catch and handle errors, and a @samp{defer} statement for running cleanup
actions just before the current scope exits.

A semicolon (@samp{;}) can optionally appear after any statement and is used
to separate multiple statements if they appear on the same line.

Grammar of a statement

statement →
expression
=;=@math{_opt}

statement →
declaration
=;=@math{_opt}

statement →
loop-statement
=;=@math{_opt}

statement →
branch-statement
=;=@math{_opt}

statement →
labeled-statement
=;=@math{_opt}

statement →
control-transfer-statement
=;=@math{_opt}

statement →
defer-statement
=;=@math{_opt}

statement →
do-statement
=;=@math{_opt}

statement →
compiler-control-statement

statements →
statement
statements
_@{opt@}

@menu
* Loop Statements::
* Labeled Statement::
* Control Transfer Statements::
* Defer Statement::
* Do Statement::
* Compiler Control Statements::
* Availability Condition::
@end menu

@node Loop Statements
@section Loop Statements

Loop statements allow a block of code to be executed repeatedly,
depending on the conditions specified in the loop. Swift has three loop
statements: a @samp{for}-@samp{in} statement, a @samp{while} statement, and a
@samp{repeat}-@samp{while} statement.

Control flow in a loop statement can be changed by a @samp{break} statement
and a @samp{continue} statement and is discussed in
@ref{Break Statement} and
@ref{Continue Statement} below.

Grammar of a loop statement

loop-statement →
for-in-statement

loop-statement →
while-statement

loop-statement →
repeat-while-statement

@menu
* For-In Statement::
* While Statement::
* Repeat-While Statement::
* Branch Statements::
* If Statement::
* Guard Statement::
@end menu

@node For-In Statement
@subsection For-In Statement

A @samp{for}-@samp{in} statement allows a block of code to be executed once for
each item in a collection (or any type) that conforms to the
@uref{https://developer.apple.com/documentation/swift/sequence, @samp{Sequence}}
[@uref{https://developer.apple.com/documentation/swift/sequence}] protocol.

A @samp{for}-@samp{in} statement has the following form:

@enumerate
@item
for item in collection @{
@item
statements
@item
@}
@end enumerate

The @samp{makeIterator()} method is called on the @emph{collection} expression to
obtain a value of an iterator type---that is, a type that conforms to
the
@uref{https://developer.apple.com/documentation/swift/iteratorprotocol, @samp{IteratorProtocol}}
[@uref{https://developer.apple.com/documentation/swift/iteratorprotocol}]
protocol. The program begins executing a loop by calling the @samp{next()}
method on the iterator. If the value returned is not @samp{nil}, it is
assigned to the @emph{item} pattern, the program executes the @emph{statements},
and then continues execution at the beginning of the loop. Otherwise,
the program does not perform assignment or execute the @emph{statements}, and
it is finished executing the @samp{for}-@samp{in} statement.

Grammar of a for-in statement

for-in-statement → @samp{for}
@samp{case=_@{opt@}
pattern =in}
expression
where-clause
_@{opt@}
code-block

@node While Statement
@subsection While Statement

A @samp{while} statement allows a block of code to be executed repeatedly, as
long as a condition remains true.

A @samp{while} statement has the following form:

@enumerate
@item
while condition @{
@item
statements
@item
@}
@end enumerate

A @samp{while} statement is executed as follows:

@enumerate
@item
The @emph{condition} is evaluated.

If @samp{true}, execution continues to step 2. If @samp{false}, the program is
finished executing the @samp{while} statement.

@item
The program executes the @emph{statements}, and execution returns to step
@enumerate
@item
@end enumerate
@end enumerate

Because the value of the @emph{condition} is evaluated before the
@emph{statements} are executed, the @emph{statements} in a @samp{while} statement can
be executed zero or more times.

The value of the @emph{condition} must be of type @samp{Bool} or a type bridged to
@samp{Bool}. The condition can also be an optional binding declaration, as
discussed in @ref{Optional Binding,Optional
Binding,,swift,}.

Grammar of a while statement

while-statement → @samp{while}
condition-list
code-block

condition-list →
condition |
condition @samp{,}
condition-list

condition →
expression
@multitable {}
@item
@end multitable
availability-condition
@multitable {}
@item
@end multitable
case-condition
@multitable {}
@item
@end multitable
optional-binding-condition

case-condition → @samp{case}
pattern
initializer

optional-binding-condition
→ @samp{let} pattern
initializer
@multitable {aaaaaaaaaaaaa}
@item @samp{var} pattern
@end multitable
initializer

@node Repeat-While Statement
@subsection Repeat-While Statement

A @samp{repeat}-@samp{while} statement allows a block of code to be executed one
or more times, as long as a condition remains true.

A @samp{repeat}-@samp{while} statement has the following form:

@enumerate
@item
repeat @{
@item
statements
@item
@} while condition
@end enumerate

A @samp{repeat}-@samp{while} statement is executed as follows:

@enumerate
@item
The program executes the @emph{statements}, and execution continues to
step 2.

@item
The @emph{condition} is evaluated.

If @samp{true}, execution returns to step 1. If @samp{false}, the program is
finished executing the @samp{repeat}-@samp{while} statement.
@end enumerate

Because the value of the @emph{condition} is evaluated after the @emph{statements}
are executed, the @emph{statements} in a @samp{repeat}-@samp{while} statement are
executed at least once.

The value of the @emph{condition} must be of type @samp{Bool} or a type bridged to
@samp{Bool}. The condition can also be an optional binding declaration, as
discussed in @ref{Optional Binding,Optional
Binding,,swift,}.

Grammar of a repeat-while statement

repeat-while-statement
→ @samp{repeat}
code-block
@samp{while}
expression

@node Branch Statements
@subsection Branch Statements

Branch statements allow the program to execute certain parts of code
depending on the value of one or more conditions. The values of the
conditions specified in a branch statement control how the program
branches and, therefore, what block of code is executed. Swift has three
branch statements: an @samp{if} statement, a @samp{guard} statement, and a
@samp{switch} statement.

Control flow in an @samp{if} statement or a @samp{switch} statement can be changed
by a @samp{break} statement and is discussed in
@ref{Break Statement} below.

Grammar of a branch statement

branch-statement →
if-statement

branch-statement →
guard-statement

branch-statement →
switch-statement

@node If Statement
@subsection If Statement

An @samp{if} statement is used for executing code based on the evaluation of
one or more conditions.

There are two basic forms of an @samp{if} statement. In each form, the
opening and closing braces are required.

The first form allows code to be executed only when a condition is true
and has the following form:

@enumerate
@item
if condition @{
@item
statements
@item
@}
@end enumerate

The second form of an @samp{if} statement provides an additional @emph{else
clause} (introduced by the @samp{else} keyword) and is used for executing one
part of code when the condition is true and another part of code when
the same condition is false. When a single else clause is present, an
@samp{if} statement has the following form:

@enumerate
@item
if condition @{
@item
statements to execute if condition is true
@item
@} else @{
@item
statements to execute if condition is false
@item
@}
@end enumerate

The else clause of an @samp{if} statement can contain another @samp{if} statement
to test more than one condition. An @samp{if} statement chained together in
this way has the following form:

@enumerate
@item
if condition 1 @{
@item
statements to execute if condition 1 is true
@item
@} else if condition 2 @{
@item
statements to execute if condition 2 is true
@item
@} else @{
@item
statements to execute if both conditions are false
@item
@}
@end enumerate

The value of any condition in an @samp{if} statement must be of type @samp{Bool}
or a type bridged to @samp{Bool}. The condition can also be an optional
binding declaration, as discussed in
@ref{Optional Binding,Optional Binding,,swift,}.

Grammar of an if statement

if-statement → @samp{if}
condition-list
code-block
else-clause
_@{opt@}

else-clause → @samp{else}
code-block
@multitable {aaaaaa}
@item @samp{else}
@end multitable
if-statement

@node Guard Statement
@subsection Guard Statement

A @samp{guard} statement is used to transfer program control out of a scope
if one or more conditions aren't met.

A @samp{guard} statement has the following form:

@enumerate
@item
guard condition else @{
@item
statements
@item
@}
@end enumerate

The value of any condition in a @samp{guard} statement must be of type @samp{Bool}
or a type bridged to @samp{Bool}. The condition can also be an optional
binding declaration, as discussed in
@ref{Optional Binding,Optional Binding,,swift,}.

Any constants or variables assigned a value from an optional binding
declaration in a @samp{guard} statement condition can be used for the rest of
the guard statement's enclosing scope.

The @samp{else} clause of a @samp{guard} statement is required, and must either
call a function with the @samp{Never} return type or transfer program control
outside the guard statement's enclosing scope using one of the following
statements:

@itemize
@item
@samp{return}

@item
@samp{break}

@item
@samp{continue}

@item
@samp{throw}
@end itemize

Control transfer statements are discussed in
@ref{Control Transfer Statements} below. For more
information on functions with the @samp{Never} return type, see
@ref{Functions that Never Return}.

Grammar of a guard statement

guard-statement → @samp{guard}
condition-list
@samp{else}
code-block

@enumerate
@item
Switch Statement


A @samp{switch} statement allows certain blocks of code to be executed
depending on the value of a control expression.

A @samp{switch} statement has the following form:

@enumerate
@item
switch control expression @{
@item
case pattern 1:
@item
statements
@item
case pattern 2 where condition:
@item
statements
@item
case pattern 3 where condition,
@item
pattern 4 where condition:
@item
statements
@item
default:
@item
statements
@item
@}
@end enumerate

The @emph{control expression} of the @samp{switch} statement is evaluated and then
compared with the patterns specified in each case. If a match is found,
the program executes the @emph{statements} listed within the scope of that
case. The scope of each case can't be empty. As a result, you must
include at least one statement following the colon (@samp{:}) of each case
label. Use a single @samp{break} statement if you don't intend to execute any
code in the body of a matched case.

The values of expressions your code can branch on are very flexible. For
example, in addition to the values of scalar types, such as integers and
characters, your code can branch on the values of any type, including
floating-point numbers, strings, tuples, instances of custom classes,
and optionals. The value of the @emph{control expression} can even be matched
to the value of a case in an enumeration and checked for inclusion in a
specified range of values. For examples of how to use these various
types of values in @samp{switch} statements, see
@ref{Switch,Switch,,swift,} in
@ref{Control Flow,Control Flow,,swift,}.

A @samp{switch} case can optionally contain a @samp{where} clause after each
pattern. A @emph{where clause} is introduced by the @samp{where} keyword followed
by an expression, and is used to provide an additional condition before
a pattern in a case is considered matched to the @emph{control expression}.
If a @samp{where} clause is present, the @emph{statements} within the relevant
case are executed only if the value of the @emph{control expression} matches
one of the patterns of the case and the expression of the @samp{where} clause
evaluates to @samp{true}. For example, a @emph{control expression} matches the
case in the example below only if it is a tuple that contains two
elements of the same value, such as @samp{(1, 1)}.

@enumerate
@item
case let (x, y) where x == y:
@end enumerate

As the above example shows, patterns in a case can also bind constants
using the @samp{let} keyword (they can also bind variables using the @samp{var}
keyword). These constants (or variables) can then be referenced in a
corresponding @samp{where} clause and throughout the rest of the code within
the scope of the case. If the case contains multiple patterns that match
the control expression, all of the patterns must contain the same
constant or variable bindings, and each bound variable or constant must
have the same type in all of the case's patterns.

A @samp{switch} statement can also include a default case, introduced by the
@samp{default} keyword. The code within a default case is executed only if no
other cases match the control expression. A @samp{switch} statement can
include only one default case, which must appear at the end of the
@samp{switch} statement.

Although the actual execution order of pattern-matching operations, and
in particular the evaluation order of patterns in cases, is unspecified,
pattern matching in a @samp{switch} statement behaves as if the evaluation is
performed in source order---that is, the order in which they appear in
source code. As a result, if multiple cases contain patterns that
evaluate to the same value, and thus can match the value of the control
expression, the program executes only the code within the first matching
case in source order.

@item
Switch Statements Must Be Exhaustive


In Swift, every possible value of the control expression's type must
match the value of at least one pattern of a case. When this simply
isn't feasible (for example, when the control expression's type is
@samp{Int}), you can include a default case to satisfy the requirement.

@enumerate
@item
Switching Over Future Enumeration Cases


@findex @@unknown

A @emph{nonfrozen enumeration} is a special kind of enumeration that may gain
new enumeration cases in the future---even after you compile and ship an
app. Switching over a nonfrozen enumeration requires extra
consideration. When a library's authors mark an enumeration as
nonfrozen, they reserve the right to add new enumeration cases, and any
code that interacts with that enumeration @emph{must} be able to handle those
future cases without being recompiled. Only the standard library, Swift
overlays for Apple frameworks, and C and Objective-C code can declare
nonfrozen enumerations. Enumerations you declare in Swift can't be
nonfrozen.

When switching over a nonfrozen enumeration value, you always need to
include a default case, even if every case of the enumeration already
has a corresponding switch case. You can apply the @samp{@@unknown} attribute
to the default case, which indicates that the default case should match
only enumeration cases that are added in the future. Swift produces a
warning if the default case matches any enumeration case that is known
at compiler time. This future warning informs you that the library
author added a new case to the enumeration that doesn't have a
corresponding switch case.

The following example switches over all three existing cases of the
standard library's
@uref{https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation, @samp{Mirror.AncestorRepresentation}}
[@uref{https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation}]
enumeration. If you add additional cases in the future, the compiler
generates a warning to indicate that you need to update the switch
statement to take the new cases into account.

@example
let representation: Mirror.AncestorRepresentation = .generated
switch representation @{
case .customized:
    print("Use the nearest ancestor's implementation.")
case .generated:
    print("Generate a default mirror for all ancestor classes.")
case .suppressed:
    print("Suppress the representation of all ancestor classes.")
@@unknown default:
    print("Use a representation that was unknown when this code was compiled.")
@}
// Prints "Generate a default mirror for all ancestor classes."
@end example
@end enumerate

@item
Execution Does Not Fall Through Cases Implicitly


After the code within a matched case has finished executing, the program
exits from the @samp{switch} statement. Program execution does not continue
or “fall through” to the next case or default case. That said, if you
want execution to continue from one case to the next, explicitly include
a @samp{fallthrough} statement, which simply consists of the @samp{fallthrough}
keyword, in the case from which you want execution to continue. For more
information about the @samp{fallthrough} statement, see
@ref{Fallthrough Statement} below.

Grammar of a switch statement

switch-statement → @samp{switch}
expression
@samp{@{}
switch-cases
_@{opt@} @samp{@}}

switch-cases →
switch-case
switch-cases
_@{opt@}

switch-case →
case-label
statements

switch-case →
default-label
statements

switch-case →
conditional-switch-case

case-label →
attributes
_@{opt@} @samp{case}
case-item-list
@samp{:}

case-item-list →
pattern
where-clause
_@{opt@} | pattern
where-clause
_@{opt@} @samp{,}
case-item-list

default-label →
attributes
_@{opt@} @samp{default} @samp{:}

where-clause → @samp{where}
where-expression

where-expression →
expression

conditional-switch-case
→
switch-if-directive-clause
switch-elseif-directive-clauses
_@{opt@}
switch-else-directive-clause
_@{opt@}
endif-directive

switch-if-directive-clause
→
if-directive
compilation-condition
switch-cases
_@{opt@}

switch-elseif-directive-clauses
→
elseif-directive-clause
switch-elseif-directive-clauses
_@{opt@}

switch-elseif-directive-clause
→
elseif-directive
compilation-condition
switch-cases
_@{opt@}

switch-else-directive-clause
→
else-directive
switch-cases
_@{opt@}
@end enumerate

@node Labeled Statement
@section Labeled Statement

You can prefix a loop statement, an @samp{if} statement, a @samp{switch}
statement, or a @samp{do} statement with a @emph{statement label}, which consists
of the name of the label followed immediately by a colon (:). Use
statement labels with @samp{break} and @samp{continue} statements to be explicit
about how you want to change control flow in a loop statement or a
@samp{switch} statement, as discussed in @ref{Break Statement, , Break
Statement} and @ref{Continue Statement} below.

The scope of a labeled statement is the entire statement following the
statement label. You can nest labeled statements, but the name of each
statement label must be unique.

For more information and to see examples of how to use statement labels,
see @ref{Labeled Statements,Labeled Statements,,swift,} in
@ref{Control Flow,Control Flow,,swift,}.

Grammar of a labeled statement

labeled-statement →
statement-label
loop-statement

labeled-statement →
statement-label
if-statement

labeled-statement →
statement-label
switch-statement

labeled-statement →
statement-label
do-statement

statement-label →
label-name
@samp{:}

label-name →
identifier

@node Control Transfer Statements
@section Control Transfer Statements

Control transfer statements can change the order in which code in your
program is executed by unconditionally transferring program control from
one piece of code to another. Swift has five control transfer
statements: a @samp{break} statement, a @samp{continue} statement, a @samp{fallthrough}
statement, a @samp{return} statement, and a @samp{throw} statement.

Grammar of a control transfer statement

control-transfer-statement
→
break-statement

control-transfer-statement
→
continue-statement

control-transfer-statement
→
fallthrough-statement

control-transfer-statement
→
return-statement

control-transfer-statement
→
throw-statement

@menu
* Break Statement::
* Continue Statement::
* Fallthrough Statement::
* Return Statement::
* Throw Statement::
@end menu

@node Break Statement
@subsection Break Statement

A @samp{break} statement ends program execution of a loop, an @samp{if} statement,
or a @samp{switch} statement. A @samp{break} statement can consist of only the
@samp{break} keyword, or it can consist of the @samp{break} keyword followed by
the name of a statement label, as shown below.

@enumerate
@item
break
@item
break label name
@end enumerate

When a @samp{break} statement is followed by the name of a statement label,
it ends program execution of the loop, @samp{if} statement, or @samp{switch}
statement named by that label.

When a @samp{break} statement is not followed by the name of a statement
label, it ends program execution of the @samp{switch} statement or the
innermost enclosing loop statement in which it occurs. You can't use an
unlabeled @samp{break} statement to break out of an @samp{if} statement.

In both cases, program control is then transferred to the first line of
code following the enclosing loop or @samp{switch} statement, if any.

For examples of how to use a @samp{break} statement, see
@ref{Break,Break,,swift,} and
@ref{Labeled Statements,Labeled Statements,,swift,} in
@ref{Control Flow,Control Flow,,swift,}.

Grammar of a break statement

break-statement → @samp{break}
label-name
_@{opt@}

@node Continue Statement
@subsection Continue Statement

A @samp{continue} statement ends program execution of the current iteration
of a loop statement but does not stop execution of the loop statement. A
@samp{continue} statement can consist of only the @samp{continue} keyword, or it
can consist of the @samp{continue} keyword followed by the name of a
statement label, as shown below.

@enumerate
@item
continue
@item
continue label name
@end enumerate

When a @samp{continue} statement is followed by the name of a statement
label, it ends program execution of the current iteration of the loop
statement named by that label.

When a @samp{continue} statement is not followed by the name of a statement
label, it ends program execution of the current iteration of the
innermost enclosing loop statement in which it occurs.

In both cases, program control is then transferred to the condition of
the enclosing loop statement.

In a @samp{for} statement, the increment expression is still evaluated after
the @samp{continue} statement is executed, because the increment expression
is evaluated after the execution of the loop's body.

For examples of how to use a @samp{continue} statement, see
@ref{Continue,Continue,,swift,} and
@ref{Labeled Statements,Labeled Statements,,swift,} in
@ref{Control Flow,Control Flow,,swift,}.

Grammar of a continue statement

continue-statement →
@samp{continue}
label-name
_@{opt@}

@node Fallthrough Statement
@subsection Fallthrough Statement

A @samp{fallthrough} statement consists of the @samp{fallthrough} keyword and
occurs only in a case block of a @samp{switch} statement. A @samp{fallthrough}
statement causes program execution to continue from one case in a
@samp{switch} statement to the next case. Program execution continues to the
next case even if the patterns of the case label do not match the value
of the @samp{switch} statement's control expression.

A @samp{fallthrough} statement can appear anywhere inside a @samp{switch}
statement, not just as the last statement of a case block, but it can't
be used in the final case block. It also cannot transfer control into a
case block whose pattern contains value binding patterns.

For an example of how to use a @samp{fallthrough} statement in a @samp{switch}
statement, see @ref{Control Transfer Statements, , Control
Transfer Statements} in @ref{Control Flow,Control
Flow,,swift,}.

Grammar of a fallthrough statement

fallthrough-statement
→ @samp{fallthrough}

@node Return Statement
@subsection Return Statement

A @samp{return} statement occurs in the body of a function or method
definition and causes program execution to return to the calling
function or method. Program execution continues at the point immediately
following the function or method call.

A @samp{return} statement can consist of only the @samp{return} keyword, or it can
consist of the @samp{return} keyword followed by an expression, as shown
below.

@enumerate
@item
return
@item
return expression
@end enumerate

When a @samp{return} statement is followed by an expression, the value of the
expression is returned to the calling function or method. If the value
of the expression does not match the value of the return type declared
in the function or method declaration, the expression's value is
converted to the return type before it is returned to the calling
function or method.

Note

As described in @ref{Failable Initializers}, a
special form of the @samp{return} statement (@samp{return nil}) can be used in a
failable initializer to indicate initialization failure.

When a @samp{return} statement is not followed by an expression, it can be
used only to return from a function or method that does not return a
value (that is, when the return type of the function or method is @samp{Void}
or @samp{()}).

Grammar of a return statement

return-statement → @samp{return}
expression
_@{opt@}

@node Throw Statement
@subsection Throw Statement

A @samp{throw} statement occurs in the body of a throwing function or method,
or in the body of a closure expression whose type is marked with the
@samp{throws} keyword.

A @samp{throw} statement causes a program to end execution of the current
scope and begin error propagation to its enclosing scope. The error
that's thrown continues to propagate until it's handled by a @samp{catch}
clause of a @samp{do} statement.

A @samp{throw} statement consists of the @samp{throw} keyword followed by an
expression, as shown below.

@enumerate
@item
throw expression
@end enumerate

The value of the @emph{expression} must have a type that conforms to the
@samp{Error} protocol.

For an example of how to use a @samp{throw} statement, see
@ref{Propagating Errors Using Throwing Functions,Propagating Errors Using
Throwing Functions,,swift,} in @ref{Error Handling,Error
Handling,,swift,}.

Grammar of a throw statement

throw-statement → @samp{throw}
expression

@node Defer Statement
@section Defer Statement

A @samp{defer} statement is used for executing code just before transferring
program control outside of the scope that the @samp{defer} statement appears
in.

A @samp{defer} statement has the following form:

@enumerate
@item
defer @{
@item
statements
@item
@}
@end enumerate

The statements within the @samp{defer} statement are executed no matter how
program control is transferred. This means that a @samp{defer} statement can
be used, for example, to perform manual resource management such as
closing file descriptors, and to perform actions that need to happen
even if an error is thrown.

If multiple @samp{defer} statements appear in the same scope, the order they
appear is the reverse of the order they are executed. Executing the last
@samp{defer} statement in a given scope first means that statements inside
that last @samp{defer} statement can refer to resources that will be cleaned
up by other @samp{defer} statements.

@enumerate
@item
func f() @{
@item
defer @{ print("First defer") @}
@item
defer @{ print("Second defer") @}
@item
print("End of function")
@item
@}
@item
f()
@item
// Prints "End of function"
@item
// Prints "Second defer"
@item
// Prints "First defer"
@end enumerate

The statements in the @samp{defer} statement can't transfer program control
outside of the @samp{defer} statement.

Grammar of a defer statement

defer-statement → @samp{defer}
code-block

@node Do Statement
@section Do Statement

The @samp{do} statement is used to introduce a new scope and can optionally
contain one or more @samp{catch} clauses, which contain patterns that match
against defined error conditions. Variables and constants declared in
the scope of a @samp{do} statement can be accessed only within that scope.

A @samp{do} statement in Swift is similar to curly braces (@samp{@{@}}) in C used to
delimit a code block, and does not incur a performance cost at runtime.

A @samp{do} statement has the following form:

@enumerate
@item
do @{
@item
try expression
@item
statements
@item
@} catch pattern 1 @{
@item
statements
@item
@} catch pattern 2 where condition @{
@item
statements
@item
@}
@end enumerate

Like a @samp{switch} statement, the compiler attempts to infer whether
@samp{catch} clauses are exhaustive. If such a determination can be made, the
error is considered handled. Otherwise, the error can propagate out of
the containing scope, which means the error must be handled by an
enclosing @samp{catch} clause or the containing function must be declared
with @samp{throws}.

To ensure that an error is handled, use a @samp{catch} clause with a pattern
that matches all errors, such as a wildcard pattern (@samp{_}). If a @samp{catch}
clause does not specify a pattern, the @samp{catch} clause matches and binds
any error to a local constant named @samp{error}. For more information about
the patterns you can use in a @samp{catch} clause, see
@ref{Patterns}.

To see an example of how to use a @samp{do} statement with several @samp{catch}
clauses, see @ref{Handling Errors,Handling
Errors,,swift,}.

Grammar of a do statement

do-statement → @samp{do}
code-block
catch-clauses
_@{opt@}

catch-clauses →
catch-clause
catch-clauses
_@{opt@}

catch-clause → @samp{catch}
pattern _@{opt@}
where-clause
_@{opt@}
code-block

@node Compiler Control Statements
@section Compiler Control Statements

Compiler control statements allow the program to change aspects of the
compiler's behavior. Swift has three compiler control statements: a
conditional compilation block a line control statement, and a
compile-time diagnostic statement.

Grammar of a compiler control statement

compiler-control-statement
→
conditional-compilation-block

compiler-control-statement
→
line-control-statement

compiler-control-statement
→
diagnostic-statement

@menu
* Conditional Compilation Block::
* Line Control Statement::
* Compile-Time Diagnostic Statement::
@end menu

@node Conditional Compilation Block
@subsection Conditional Compilation Block

A conditional compilation block allows code to be conditionally compiled
depending on the value of one or more compilation conditions.

@findex #if

Every conditional compilation block begins with the @samp{#if} compilation
directive and ends with the @samp{#endif} compilation directive. A simple
conditional compilation block has the following form:

@enumerate
@item
#if compilation condition
@item
statements
@item
#endif
@end enumerate

Unlike the condition of an @samp{if} statement, the @emph{compilation condition}
is evaluated at compile time. As a result, the @emph{statements} are compiled
and executed only if the @emph{compilation condition} evaluates to @samp{true} at
compile time.

The @emph{compilation condition} can include the @samp{true} and @samp{false} Boolean
literals, an identifier used with the @samp{-D} command line flag, or any of
the platform conditions listed in the table below.

@multitable {aaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Platform condition
@tab Valid arguments
@item @samp{os()}
@tab @samp{macOS}, @samp{iOS}, @samp{watchOS}, @samp{tvOS}, @samp{Linux}
@item @samp{arch()}
@tab @samp{i386}, @samp{x86_64}, @samp{arm}, @samp{arm64}
@item @samp{swift()}
@tab @samp{>=} or @samp{<} followed by a version number
@item @samp{compiler()}
@tab @samp{>=} or @samp{<} followed by a version number
@item @samp{canImport()}
@tab A module name
@item @samp{targetEnvironment()}
@tab @samp{simulator}
@end multitable

The version number for the @samp{swift()} and @samp{compiler()} platform
conditions consists of a major number, optional minor number, optional
patch number, and so on, with a dot (@samp{.}) separating each part of the
version number. There must not be whitespace between the comparison
operator and the version number. The version for @samp{compiler()} is the
compiler version, regardless of the Swift version setting passed to the
compiler. The version for @samp{swift()} is the language version currently
being compiled. For example, if you compile your code using the Swift 5
compiler in Swift 4.2 mode, the compiler version is 5 and the language
version is 4.2. With those settings, the following code prints all three
messages:

@enumerate
@item
#if compiler(>=5)
@item
print("Compiled with the Swift 5 compiler or later")
@item
#endif
@item
#if swift(>=4.2)
@item
print("Compiled in Swift 4.2 mode or later")
@item
#endif
@item
#if compiler(>=5) && swift(<5)
@item
print("Compiled with the Swift 5 compiler or later in a Swift mode
earlier than 5")
@item
#endif
@item
// Prints "Compiled with the Swift 5 compiler or later"
@item
// Prints "Compiled in Swift 4.2 mode or later"
@item
// Prints "Compiled with the Swift 5 compiler or later in a Swift
mode earlier than 5"
@end enumerate

The argument for the @samp{canImport()} platform condition is the name of a
module that may not be present on all platforms. This condition tests
whether it's possible to import the module, but doesn't actually import
it. If the module is present, the platform condition returns @samp{true};
otherwise, it returns @samp{false}.

The @samp{targetEnvironment()} platform condition returns @samp{true} when code is
compiled for a simulator; otherwise, it returns @samp{false}.

Note

The @samp{arch(arm)} platform condition does not return @samp{true} for ARM 64
devices. The @samp{arch(i386)} platform condition returns @samp{true} when code is
compiled for the 32--bit iOS simulator.

You can combine compilation conditions using the logical operators @samp{&&},
@samp{||}, and @samp{!} and use parentheses for grouping. These operators have the
same associativity and precedence as the logical operators that are used
to combine ordinary Boolean expressions.

Similar to an @samp{if} statement, you can add multiple conditional branches
to test for different compilation conditions. You can add any number of
additional branches using @samp{#elseif} clauses. You can also add a final
additional branch using an @samp{#else} clause. Conditional compilation
blocks that contain multiple branches have the following form:

@enumerate
@item
#if compilation condition 1
@item
statements to compile if compilation condition 1 is true
@item
#elseif compilation condition 2
@item
statements to compile if compilation condition 2 is true
@item
#else
@item
statements to compile if both compilation conditions are false
@item
#endif
@end enumerate

Note

Each statement in the body of a conditional compilation block is parsed
even if it's not compiled. However, there is an exception if the
compilation condition includes a @samp{swift()} platform condition: The
statements are parsed only if the compiler's version of Swift matches
what is specified in the platform condition. This exception ensures that
an older compiler doesn't attempt to parse syntax introduced in a newer
version of Swift.

Grammar of a conditional compilation block

conditional-compilation-block
→
if-directive-clause
elseif-directive-clauses
_@{opt@}
else-directive-clause
_@{opt@}
endif-directive

if-directive-clause →
if-directive
compilation-condition
statements
_@{opt@}

elseif-directive-clauses
→
elseif-directive-clause
elseif-directive-clauses
_@{opt@}

elseif-directive-clause
→
elseif-directive
compilation-condition
statements
_@{opt@}

else-directive-clause
→
else-directive
statements
_@{opt@}

if-directive → @samp{#if}

elseif-directive →
@samp{#elseif}

else-directive → @samp{#else}

endif-directive → @samp{#endif}

compilation-condition
→
platform-condition

compilation-condition
→
identifier

compilation-condition
→
boolean-literal

compilation-condition
→ @samp{(}
compilation-condition
@samp{)}

compilation-condition
→ @samp{!}
compilation-condition

compilation-condition
→
compilation-condition
@samp{&&}
compilation-condition

compilation-condition
→
compilation-condition
@samp{||}
compilation-condition

platform-condition → @samp{os}
@samp{(}
operating-system
@samp{)}

platform-condition →
@samp{arch} @samp{(}
architecture
@samp{)}

platform-condition →
@samp{swift} @samp{(} @samp{>=}
swift-version
@samp{)} | @samp{swift} @samp{(} @samp{<}
swift-version
@samp{)}

platform-condition →
@samp{compiler} @samp{(} @samp{>=}
swift-version
@samp{)} | @samp{compiler} @samp{(} @samp{<}
swift-version
@samp{)}

platform-condition →
@samp{canImport} @samp{(}
module-name
@samp{)}

platform-condition →
@samp{targetEnvironment} @samp{(}
environment
@samp{)}

operating-system → @samp{macOS}
@multitable {aaaaa} {aaaaaaaaa} {aaaaaa}
@item @samp{iOS}
@tab @samp{watchOS}
@tab @samp{tvOS}
@end multitable

architecture → @samp{i386} |
@samp{x86_64} | @samp{arm} | @samp{arm64}

swift-version →
decimal-digits
swift-version-continuation
_@{opt@}

swift-version-continuation
→ @samp{.}
decimal-digits
swift-version-continuation
_@{opt@}

module-name →
identifier

environment → @samp{simulator}

@node Line Control Statement
@subsection Line Control Statement

A line control statement is used to specify a line number and filename
that can be different from the line number and filename of the source
code being compiled. Use a line control statement to change the source
code location used by Swift for diagnostic and debugging purposes.

@findex #sourceLocation

A line control statement has the following forms:

@enumerate
@item
#sourceLocation(file: filename, line: line number)
@item
#sourceLocation()
@end enumerate

The first form of a line control statement changes the values of the
@samp{#line} and @samp{#file} literal expressions, beginning with the line of code
following the line control statement. The @emph{line number} changes the
value of @samp{#line} and is any integer literal greater than zero. The
@emph{filename} changes the value of @samp{#file} and is a string literal.

The second form of a line control statement, @samp{#sourceLocation()}, resets
the source code location back to the default line numbering and
filename.

Grammar of a line control statement

line-control-statement
→ @samp{#sourceLocation} @samp{(} @samp{file:}
file-name @samp{,}
@samp{line:}
line-number
@samp{)}

line-control-statement
→ @samp{#sourceLocation} @samp{(} @samp{)}

line-number → A decimal integer
greater than zero

file-name →
static-string-literal

@node Compile-Time Diagnostic Statement
@subsection Compile-Time Diagnostic Statement

A compile-time diagnostic statement causes the compiler to emit an error
or a warning during compilation. A compile-time diagnostic statement has
the following forms:

@findex #error
@findex #warning

@enumerate
@item
#error("error message")
@item
#warning("warning message")
@end enumerate

The first form emits the @emph{error message} as a fatal error and terminates
the compilation process. The second form emits the @emph{warning message} as
a nonfatal warning and allows compilation to proceed. You write the
diagnostic message as a static string literal. Static string literals
can't use features like string interpolation or concatenation, but they
can use the multiline string literal syntax.

Grammar of a compile-time diagnostic statement

diagnostic-statement →
@samp{#error} @samp{(}
diagnostic-message
@samp{)}

diagnostic-statement
→ @samp{#warning} @samp{(}
diagnostic-message
@samp{)}

diagnostic-message →
static-string-literal

@node Availability Condition
@section Availability Condition

An @emph{availability condition} is used as a condition of an @samp{if}, @samp{while},
and @samp{guard} statement to query the availability of APIs at runtime,
based on specified platforms arguments.

An availability condition has the following form:

@enumerate
@item
if #available(platform name version, @dots{}, *) @{
@item
statements to execute if the APIs are available
@item
@} else @{
@item
fallback statements to execute if the APIs are unavailable
@item
@}
@end enumerate

You use an availability condition to execute a block of code, depending
on whether the APIs you want to use are available at runtime. The
compiler uses the information from the availability condition when it
verifies that the APIs in that block of code are available.

The availability condition takes a comma-separated list of platform
names and versions. Use @samp{iOS}, @samp{macOS}, @samp{watchOS}, and @samp{tvOS} for the
platform names, and include the corresponding version numbers. The @samp{*}
argument is required and specifies that on any other platform, the body
of the code block guarded by the availability condition executes on the
minimum deployment target specified by your target.

Unlike Boolean conditions, you can't combine availability conditions
using logical operators such as @samp{&&} and @samp{||}.

Grammar of an availability condition

availability-condition
→ @samp{#available} @samp{(}
availability-arguments
@samp{)}

availability-arguments
→
availability-argument
@multitable {}
@item
@end multitable
availability-argument
@samp{,}
availability-arguments

availability-argument
→
platform-name
platform-version

availability-argument
→ @samp{*}

platform-name → @samp{iOS} |
@samp{iOSApplicationExtension}

platform-name → @samp{macOS} |
@samp{macOSApplicationExtension}

platform-name → @samp{watchOS}

platform-name → @samp{tvOS}

platform-version →
decimal-digits

platform-version →
decimal-digits
@samp{.}
decimal-digits

platform-version →
decimal-digits
@samp{.}
decimal-digits
@samp{.}
decimal-digits

@node Declarations
@chapter Declarations

A @emph{declaration} introduces a new name or construct into your program.
For example, you use declarations to introduce functions and methods, to
introduce variables and constants, and to define enumeration, structure,
class, and protocol types. You can also use a declaration to extend the
behavior of an existing named type and to import symbols into your
program that are declared elsewhere.

In Swift, most declarations are also definitions in the sense that they
are implemented or initialized at the same time they are declared. That
said, because protocols don't implement their members, most protocol
members are declarations only. For convenience and because the
distinction isn't that important in Swift, the term @emph{declaration} covers
both declarations and definitions.

Grammar of a declaration

declaration →
import-declaration

declaration →
constant-declaration

declaration →
variable-declaration

declaration →
typealias-declaration

declaration →
function-declaration

declaration →
enum-declaration

declaration →
struct-declaration

declaration →
class-declaration

declaration →
protocol-declaration

declaration →
initializer-declaration

declaration →
deinitializer-declaration

declaration →
extension-declaration

declaration →
subscript-declaration

declaration →
operator-declaration

declaration →
precedence-group-declaration

declarations →
declaration
declarations
_@{opt@}

@menu
* Top-Level Code::
* Code Blocks::
* Import Declaration::
* Constant Declaration::
* Variable Declaration::
* Type Alias Declaration::
* Function Declaration::
* Enumeration Declaration::
* Structure Declaration::
* Class Declaration::
* Protocol Declaration::
* Initializer Declaration::
* Deinitializer Declaration::
* Extension Declaration::
* Subscript Declaration::
* Operator Declaration::
* Precedence Group Declaration::
* Declaration Modifiers::
@end menu

@node Top-Level Code
@section Top-Level Code

The top-level code in a Swift source file consists of zero or more
statements, declarations, and expressions. By default, variables,
constants, and other named declarations that are declared at the
top-level of a source file are accessible to code in every source file
that is part of the same module. You can override this default behavior
by marking the declaration with an access-level modifier, as described
in @ref{Access Control Levels}.

Grammar of a top-level declaration

top-level-declaration
→ statements
_@{opt@}

@node Code Blocks
@section Code Blocks

A @emph{code block} is used by a variety of declarations and control
structures to group statements together. It has the following form:

@enumerate
@item
@{
@item
statements
@item
@}
@end enumerate

The @emph{statements} inside a code block include declarations, expressions,
and other kinds of statements and are executed in order of their
appearance in source code.

Grammar of a code block

code-block → @samp{@{}
statements
_@{opt@} @samp{@}}

@node Import Declaration
@section Import Declaration

An @emph{import declaration} lets you access symbols that are declared
outside the current file. The basic form imports the entire module; it
consists of the @samp{import} keyword followed by a module name:

@enumerate
@item
import module
@end enumerate

Providing more detail limits which symbols are imported---you can
specify a specific submodule or a specific declaration within a module
or submodule. When this detailed form is used, only the imported symbol
(and not the module that declares it) is made available in the current
scope.

@enumerate
@item
import import kind module.symbol name
@item
import module.submodule
@end enumerate

Grammar of an import declaration

import-declaration →
attributes
_@{opt@} @samp{import}
import-kind
_@{opt@}
import-path

import-kind → @samp{typealias} |
@samp{struct} | @samp{class} | @samp{enum} | @samp{protocol} | @samp{let} | @samp{var} | @samp{func}

import-path →
import-path-identifier
@multitable {}
@item
@end multitable
import-path-identifier
@samp{.}
import-path

import-path-identifier
→
identifier
@multitable {}
@item
@end multitable
operator

@node Constant Declaration
@section Constant Declaration

A @emph{constant declaration} introduces a constant named value into your
program. Constant declarations are declared using the @samp{let} keyword and
have the following form:

@enumerate
@item
let constant name: type = expression
@end enumerate

A constant declaration defines an immutable binding between the
@emph{constant name} and the value of the initializer @emph{expression}; after the
value of a constant is set, it cannot be changed. That said, if a
constant is initialized with a class object, the object itself can
change, but the binding between the constant name and the object it
refers to can't.

When a constant is declared at global scope, it must be initialized with
a value. When a constant declaration occurs in the context of a function
or method, it can be initialized later, as long as it is guaranteed to
have a value set before the first time its value is read. When a
constant declaration occurs in the context of a class or structure
declaration, it is considered a @emph{constant property}. Constant
declarations are not computed properties and therefore do not have
getters or setters.

If the @emph{constant name} of a constant declaration is a tuple pattern, the
name of each item in the tuple is bound to the corresponding value in
the initializer @emph{expression}.

@enumerate
@item
let (firstNumber, secondNumber) = (10, 42)
@end enumerate

In this example, @samp{firstNumber} is a named constant for the value @samp{10},
and @samp{secondNumber} is a named constant for the value @samp{42}. Both
constants can now be used independently:

@enumerate
@item
print("The first number is \(firstNumber).")
@item
// Prints "The first number is 10."
@item
print("The second number is \(secondNumber).")
@item
// Prints "The second number is 42."
@end enumerate

The type annotation (@samp{:} @emph{type}) is optional in a constant declaration
when the type of the @emph{constant name} can be inferred, as described in
@ref{Type Inference}.

To declare a constant type property, mark the declaration with the
@samp{static} declaration modifier. A constant type property of a class is
always implicitly final; you can't mark it with the @samp{class} or @samp{final}
declaration modifier to allow or disallow overriding by subclasses. Type
properties are discussed in
@ref{Type Properties,Type Properties,,swift,}.

For more information about constants and for guidance about when to use
them, see @ref{Constants and Variables,Constants and
Variables,,swift,} and @ref{Stored Properties,Stored
Properties,,swift,}.

Grammar of a constant declaration

constant-declaration
→ attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{let}
pattern-initializer-list

pattern-initializer-list
→
pattern-initializer
@multitable {}
@item
@end multitable
pattern-initializer
@samp{,}
pattern-initializer-list

pattern-initializer →
pattern
initializer
_@{opt@}

initializer → @samp{=}
expression

@node Variable Declaration
@section Variable Declaration

A @emph{variable declaration} introduces a variable named value into your
program and is declared using the @samp{var} keyword.

Variable declarations have several forms that declare different kinds of
named, mutable values, including stored and computed variables and
properties, stored variable and property observers, and static variable
properties. The appropriate form to use depends on the scope at which
the variable is declared and the kind of variable you intend to declare.

Note

You can also declare properties in the context of a protocol
declaration, as described in @ref{Protocol Property Declaration, , Protocol
Property Declaration}.

You can override a property in a subclass by marking the subclass's
property declaration with the @samp{override} declaration modifier, as
described in @ref{Overriding,Overriding,,swift,}.

@menu
* Stored Variables and Stored Variable Properties::
* Computed Variables and Computed Properties::
* Stored Variable Observers and Property Observers::
* Type Variable Properties::
@end menu

@node Stored Variables and Stored Variable Properties
@subsection Stored Variables and Stored Variable Properties

The following form declares a stored variable or stored variable
property:

@enumerate
@item
var variable name: type = expression
@end enumerate

You define this form of a variable declaration at global scope, the
local scope of a function, or in the context of a class or structure
declaration. When a variable declaration of this form is declared at
global scope or the local scope of a function, it is referred to as a
@emph{stored variable}. When it is declared in the context of a class or
structure declaration, it is referred to as a @emph{stored variable
property}.

The initializer @emph{expression} can't be present in a protocol declaration,
but in all other contexts, the initializer @emph{expression} is optional.
That said, if no initializer @emph{expression} is present, the variable
declaration must include an explicit type annotation (@samp{:} @emph{type}).

As with constant declarations, if the @emph{variable name} is a tuple
pattern, the name of each item in the tuple is bound to the
corresponding value in the initializer @emph{expression}.

As their names suggest, the value of a stored variable or a stored
variable property is stored in memory.

@node Computed Variables and Computed Properties
@subsection Computed Variables and Computed Properties

The following form declares a computed variable or computed property:

@enumerate
@item
var variable name: type @{
@item
get @{
@item
statements
@item
@}
@item
set(setter name) @{
@item
statements
@item
@}
@item
@}
@end enumerate

You define this form of a variable declaration at global scope, the
local scope of a function, or in the context of a class, structure,
enumeration, or extension declaration. When a variable declaration of
this form is declared at global scope or the local scope of a function,
it is referred to as a @emph{computed variable}. When it is declared in the
context of a class, structure, or extension declaration, it is referred
to as a @emph{computed property}.

The getter is used to read the value, and the setter is used to write
the value. The setter clause is optional, and when only a getter is
needed, you can omit both clauses and simply return the requested value
directly, as described in
@ref{Read-Only Computed Properties,Read-Only Computed
Properties,,swift,}. But if you provide a setter clause, you must also provide
a getter clause.

The @emph{setter name} and enclosing parentheses is optional. If you provide
a setter name, it is used as the name of the parameter to the setter. If
you do not provide a setter name, the default parameter name to the
setter is @samp{newValue}, as described in
@ref{Shorthand Setter Declaration,Shorthand Setter
Declaration,,swift,}.

Unlike stored named values and stored variable properties, the value of
a computed named value or a computed property is not stored in memory.

For more information and to see examples of computed properties, see
@ref{Computed Properties,Computed Properties,,swift,}.

@node Stored Variable Observers and Property Observers
@subsection Stored Variable Observers and Property Observers

You can also declare a stored variable or property with @samp{willSet} and
@samp{didSet} observers. A stored variable or property declared with
observers has the following form:

@enumerate
@item
var variable name: type = expression @{
@item
willSet(setter name) @{
@item
statements
@item
@}
@item
didSet(setter name) @{
@item
statements
@item
@}
@item
@}
@end enumerate

You define this form of a variable declaration at global scope, the
local scope of a function, or in the context of a class or structure
declaration. When a variable declaration of this form is declared at
global scope or the local scope of a function, the observers are
referred to as @emph{stored variable observers}. When it is declared in the
context of a class or structure declaration, the observers are referred
to as @emph{property observers}.

You can add property observers to any stored property. You can also add
property observers to any inherited property (whether stored or
computed) by overriding the property within a subclass, as described in
@ref{Overriding Property Observers,Overriding Property
Observers,,swift,}.

The initializer @emph{expression} is optional in the context of a class or
structure declaration, but required elsewhere. The @emph{type} annotation is
optional when the type can be inferred from the initializer
@emph{expression}.

The @samp{willSet} and @samp{didSet} observers provide a way to observe (and to
respond appropriately) when the value of a variable or property is being
set. The observers are not called when the variable or property is first
initialized. Instead, they are called only when the value is set outside
of an initialization context.

A @samp{willSet} observer is called just before the value of the variable or
property is set. The new value is passed to the @samp{willSet} observer as a
constant, and therefore it can't be changed in the implementation of the
@samp{willSet} clause. The @samp{didSet} observer is called immediately after the
new value is set. In contrast to the @samp{willSet} observer, the old value
of the variable or property is passed to the @samp{didSet} observer in case
you still need access to it. That said, if you assign a value to a
variable or property within its own @samp{didSet} observer clause, that new
value that you assign will replace the one that was just set and passed
to the @samp{willSet} observer.

The @emph{setter name} and enclosing parentheses in the @samp{willSet} and
@samp{didSet} clauses are optional. If you provide setter names, they are
used as the parameter names to the @samp{willSet} and @samp{didSet} observers. If
you do not provide setter names, the default parameter name to the
@samp{willSet} observer is @samp{newValue} and the default parameter name to the
@samp{didSet} observer is @samp{oldValue}.

The @samp{didSet} clause is optional when you provide a @samp{willSet} clause.
Likewise, the @samp{willSet} clause is optional when you provide a @samp{didSet}
clause.

For more information and to see an example of how to use property
observers, see @ref{Property Observers,Property
Observers,,swift,}.

@node Type Variable Properties
@subsection Type Variable Properties

To declare a type variable property, mark the declaration with the
@samp{static} declaration modifier. Classes can mark type computed properties
with the @samp{class} declaration modifier instead to allow subclasses to
override the superclass's implementation. Type properties are discussed
in @ref{Type Properties,Type Properties,,swift,}.

Note

In a class declaration, the @samp{static} keyword has the same effect as
marking the declaration with both the @samp{class} and @samp{final} declaration
modifiers.

Grammar of a variable declaration

variable-declaration
→
variable-declaration-head
pattern-initializer-list

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
code-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-keyword-block

variable-declaration
→
variable-declaration-head
variable-name
initializer
willSet-didSet-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
initializer
_@{opt@}
willSet-didSet-block

variable-declaration-head
→ attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{var}

variable-name →
identifier

getter-setter-block →
code-block

getter-setter-block
→ @samp{@{}
getter-clause
setter-clause
_@{opt@} @samp{@}}

getter-setter-block
→ @samp{@{}
setter-clause
getter-clause
@samp{@}}

getter-clause →
attributes
_@{opt@}
mutation-modifier
_@{opt@} @samp{get}
code-block

setter-clause →
attributes
_@{opt@}
mutation-modifier
_@{opt@} @samp{set}
setter-name
_@{opt@}
code-block

setter-name → @samp{(}
identifier
@samp{)}

getter-setter-keyword-block
→ @samp{@{}
getter-keyword-clause
setter-keyword-clause
_@{opt@} @samp{@}}

getter-setter-keyword-block
→ @samp{@{}
setter-keyword-clause
getter-keyword-clause
@samp{@}}

getter-keyword-clause
→ attributes
_@{opt@}
mutation-modifier
_@{opt@} @samp{get}

setter-keyword-clause
→ attributes
_@{opt@}
mutation-modifier
_@{opt@} @samp{set}

willSet-didSet-block
→ @samp{@{}
willSet-clause
didSet-clause
_@{opt@} @samp{@}}

willSet-didSet-block
→ @samp{@{}
didSet-clause
willSet-clause
_@{opt@} @samp{@}}

willSet-clause →
attributes
_@{opt@} @samp{willSet}
setter-name
_@{opt@}
code-block

didSet-clause →
attributes
_@{opt@} @samp{didSet}
setter-name
_@{opt@}
code-block

@node Type Alias Declaration
@section Type Alias Declaration

A @emph{type alias declaration} introduces a named alias of an existing type
into your program. Type alias declarations are declared using the
@samp{typealias} keyword and have the following form:

@enumerate
@item
typealias name = existing type
@end enumerate

After a type alias is declared, the aliased @emph{name} can be used instead
of the @emph{existing type} everywhere in your program. The @emph{existing type}
can be a named type or a compound type. Type aliases do not create new
types; they simply allow a name to refer to an existing type.

A type alias declaration can use generic parameters to give a name to an
existing generic type. The type alias can provide concrete types for
some or all of the generic parameters of the existing type. For example:

@enumerate
@item
typealias StringDictionary<Value> = Dictionary<String, Value>
@item

@item
// The following dictionaries have the same type.
@item
var dictionary1: StringDictionary<Int> = [:]
@item
var dictionary2: Dictionary<String, Int> = [:]
@end enumerate

When a type alias is declared with generic parameters, the constraints
on those parameters must match exactly the constraints on the existing
type's generic parameters. For example:

@enumerate
@item
typealias DictionaryOfInts<Key: Hashable> = Dictionary<Key, Int>
@end enumerate

Because the type alias and the existing type can be used
interchangeably, the type alias can't introduce additional generic
constraints.

A type alias can forward an existing type's generic parameters by
omitting all generic parameters from the declaration. For example, the
@samp{Diccionario} type alias declared here has the same generic parameters
and constraints as @samp{Dictionary}.

@enumerate
@item
typealias Diccionario = Dictionary
@end enumerate

Inside a protocol declaration, a type alias can give a shorter and more
convenient name to a type that is used frequently. For example:

@enumerate
@item
protocol Sequence @{
@item
associatedtype Iterator: IteratorProtocol
@item
typealias Element = Iterator.Element
@item
@}
@item

@item
func sum<T: Sequence>(_ sequence: T) -> Int where T.Element == Int @{
@item
// @dots{}
@item
@}
@end enumerate

Without this type alias, the @samp{sum} function would have to refer to the
associated type as @samp{T.Iterator.Element} instead of @samp{T.Element}.

See also @ref{Protocol Associated Type Declaration, , Protocol Associated Type
Declaration}.

Grammar of a type alias declaration

typealias-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{typealias}
typealias-name
generic-parameter-clause
_@{opt@}
typealias-assignment

typealias-name →
identifier

typealias-assignment
→ @samp{=} type

@node Function Declaration
@section Function Declaration

A @emph{function declaration} introduces a function or method into your
program. A function declared in the context of class, structure,
enumeration, or protocol is referred to as a @emph{method}. Function
declarations are declared using the @samp{func} keyword and have the
following form:

@enumerate
@item
func function name(parameters) -> return type @{
@item
statements
@item
@}
@end enumerate

If the function has a return type of @samp{Void}, the return type can be
omitted as follows:

@enumerate
@item
func function name(parameters) @{
@item
statements
@item
@}
@end enumerate

The type of each parameter must be included---it can't be inferred. If
you write @samp{inout} in front of a parameter's type, the parameter can be
modified inside the scope of the function. In-out parameters are
discussed in detail in @ref{In-Out Parameters},
below.

Functions can return multiple values using a tuple type as the return
type of the function.

A function definition can appear inside another function declaration.
This kind of function is known as a @emph{nested function}.

A nested function is nonescaping if it captures a value that is
guaranteed to never escape---such as an in-out parameter---or passed as
a nonescaping function argument. Otherwise, the nested function is an
escaping function.

For a discussion of nested functions, see
@ref{Nested Functions,Nested Functions,,swift,}.

@menu
* Parameter Names::
* In-Out Parameters::
* Special Kinds of Parameters::
* Special Kinds of Methods::
* Throwing Functions and Methods::
* Rethrowing Functions and Methods::
* Functions that Never Return::
@end menu

@node Parameter Names
@subsection Parameter Names

Function parameters are a comma-separated list where each parameter has
one of several forms. The order of arguments in a function call must
match the order of parameters in the function's declaration. The
simplest entry in a parameter list has the following form:

@enumerate
@item
parameter name: parameter type
@end enumerate

A parameter has a name, which is used within the function body, as well
as an argument label, which is used when calling the function or method.
By default, parameter names are also used as argument labels. For
example:

@enumerate
@item
func f(x: Int, y: Int) -> Int @{ return x + y @}
@item
f(x: 1, y: 2) // both x and y are labeled
@end enumerate

You can override the default behavior for argument labels with one of
the following forms:

@enumerate
@item
argument label parameter name: parameter type
@item
_ parameter name: parameter type
@end enumerate

A name before the parameter name gives the parameter an explicit
argument label, which can be different from the parameter name. The
corresponding argument must use the given argument label in function or
method calls.

An underscore (@samp{_}) before a parameter name suppresses the argument
label. The corresponding argument must have no label in function or
method calls.

@enumerate
@item
func repeatGreeting(_ greeting: String, count n: Int) @{ @emph{* Greet n
times *} @}
@item
repeatGreeting("Hello, world!", count: 2) // count is labeled,
greeting is not
@end enumerate

@node In-Out Parameters
@subsection In-Out Parameters

@findex inout

In-out parameters are passed as follows:

@enumerate
@item
When the function is called, the value of the argument is copied.

@item
In the body of the function, the copy is modified.

@item
When the function returns, the copy's value is assigned to the
original argument.
@end enumerate

This behavior is known as @emph{copy-in copy-out} or @emph{call by value result}.
For example, when a computed property or a property with observers is
passed as an in-out parameter, its getter is called as part of the
function call and its setter is called as part of the function return.

As an optimization, when the argument is a value stored at a physical
address in memory, the same memory location is used both inside and
outside the function body. The optimized behavior is known as @emph{call by
reference}; it satisfies all of the requirements of the copy-in copy-out
model while removing the overhead of copying. Write your code using the
model given by copy-in copy-out, without depending on the
call-by-reference optimization, so that it behaves correctly with or
without the optimization.

Within a function, don't access a value that was passed as an in-out
argument, even if the original value is available in the current scope.
Accessing the original is a simultaneous access of the value, which
violates Swift's memory exclusivity guarantee. For the same reason, you
can't pass the same value to multiple in-out parameters.

For more information about memory safety and memory exclusivity, see
@ref{Memory Safety,Memory Safety,,swift,}.

A closure or nested function that captures an in-out parameter must be
nonescaping. If you need to capture an in-out parameter without mutating
it or to observe changes made by other code, use a capture list to
explicitly capture the parameter immutably.

@enumerate
@item
func someFunction(a: inout Int) -> () -> Int @{
@item
return @{ [a] in return a + 1 @}
@item
@}
@end enumerate

If you need to capture and mutate an in-out parameter, use an explicit
local copy, such as in multithreaded code that ensures all mutation has
finished before the function returns.

@enumerate
@item
func multithreadedFunction(queue: DispatchQueue, x: inout Int) @{
@item
// Make a local copy and manually copy it back.
@item
var localX = x
@item
defer @{ x = localX @}
@item

@item
// Operate on localX asynchronously, then wait before returning.
@item
queue.async @{ someMutatingOperation(&localX) @}
@item
queue.sync @{@}
@item
@}
@end enumerate

For more discussion and examples of in-out parameters, see
@ref{In-Out Parameters}.

@node Special Kinds of Parameters
@subsection Special Kinds of Parameters

Parameters can be ignored, take a variable number of values, and provide
default values using the following forms:

@enumerate
@item
_ : parameter type
@item
parameter name: parameter type@dots{}
@item
parameter name: parameter type = default argument value
@end enumerate

An underscore (@samp{_}) parameter is explicitly ignored and can't be
accessed within the body of the function.

A parameter with a base type name followed immediately by three dots
(@samp{...}) is understood as a variadic parameter. A function can have at
most one variadic parameter. A variadic parameter is treated as an array
that contains elements of the base type name. For example, the variadic
parameter @samp{Int...} is treated as @samp{[Int]}. For an example that uses a
variadic parameter, see
@ref{Variadic Parameters,Variadic Parameters,,swift,}.

A parameter with an equals sign (@samp{=}) and an expression after its type
is understood to have a default value of the given expression. The given
expression is evaluated when the function is called. If the parameter is
omitted when calling the function, the default value is used instead.

@enumerate
@item
func f(x: Int = 42) -> Int @{ return x @}
@item
f() // Valid, uses default value
@item
f(x: 7) // Valid, uses the value provided
@item
f(7) // Invalid, missing argument label
@end enumerate

@node Special Kinds of Methods
@subsection Special Kinds of Methods

@findex mutating

Methods on an enumeration or a structure that modify @samp{self} must be
marked with the @samp{mutating} declaration modifier.

Methods that override a superclass method must be marked with the
@samp{override} declaration modifier. It's a compile-time error to override a
method without the @samp{override} modifier or to use the @samp{override} modifier
on a method that doesn't override a superclass method.

Methods associated with a type rather than an instance of a type must be
marked with the @samp{static} declaration modifier for enumerations and
structures, or with either the @samp{static} or @samp{class} declaration modifier
for classes. A class type method marked with the @samp{class} declaration
modifier can be overridden by a subclass implementation; a class type
method marked with @samp{class final} or @samp{static} can't be overridden.

@node Throwing Functions and Methods
@subsection Throwing Functions and Methods

Functions and methods that can throw an error must be marked with the
@samp{throws} keyword. These functions and methods are known as @emph{throwing
functions} and @emph{throwing methods}. They have the following form:

@enumerate
@item
func function name(parameters) throws -> return type @{
@item
statements
@item
@}
@end enumerate

Calls to a throwing function or method must be wrapped in a @samp{try} or
@samp{try!} expression (that is, in the scope of a @samp{try} or @samp{try!} operator).

The @samp{throws} keyword is part of a function's type, and nonthrowing
functions are subtypes of throwing functions. As a result, you can use a
nonthrowing function in the same places as a throwing one.

You can't overload a function based only on whether the function can
throw an error. That said, you can overload a function based on whether
a function @emph{parameter} can throw an error.

A throwing method can't override a nonthrowing method, and a throwing
method can't satisfy a protocol requirement for a nonthrowing method.
That said, a nonthrowing method can override a throwing method, and a
nonthrowing method can satisfy a protocol requirement for a throwing
method.

@node Rethrowing Functions and Methods
@subsection Rethrowing Functions and Methods

@findex rethrows

A function or method can be declared with the @samp{rethrows} keyword to
indicate that it throws an error only if one of its function parameters
throws an error. These functions and methods are known as @emph{rethrowing
functions} and @emph{rethrowing methods}. Rethrowing functions and methods
must have at least one throwing function parameter.

@enumerate
@item
func someFunction(callback: () throws -> Void) rethrows @{
@item
try callback()
@item
@}
@end enumerate

A rethrowing function or method can contain a @samp{throw} statement only
inside a @samp{catch} clause. This lets you call the throwing function inside
a @samp{do}-@samp{catch} block and handle errors in the @samp{catch} clause by throwing
a different error. In addition, the @samp{catch} clause must handle only
errors thrown by one of the rethrowing function's throwing parameters.
For example, the following is invalid because the @samp{catch} clause would
handle the error thrown by @samp{alwaysThrows()}.

@enumerate
@item
func alwaysThrows() throws @{
@item
throw SomeError.error
@item
@}
@item
func someFunction(callback: () throws -> Void) rethrows @{
@item
do @{
@item
try callback()
@item
try alwaysThrows() // Invalid, alwaysThrows() isn't a throwing
parameter
@item
@} catch @{
@item
throw AnotherError.error
@item
@}
@item
@}
@end enumerate

A throwing method can't override a rethrowing method, and a throwing
method can't satisfy a protocol requirement for a rethrowing method.
That said, a rethrowing method can override a throwing method, and a
rethrowing method can satisfy a protocol requirement for a throwing
method.

@node Functions that Never Return
@subsection Functions that Never Return

Swift defines a @samp{Never} type, which indicates that a function or method
doesn't return to its caller. Functions and methods with the @samp{Never}
return type are called @emph{nonreturning}. Nonreturning functions and
methods either cause an irrecoverable error or begin a sequence of work
that continues indefinitely. This means that code that would otherwise
run immediately after the call is never executed. Throwing and
rethrowing functions can transfer program control to an appropriate
@samp{catch} block, even when they are nonreturning.

A nonreturning function or method can be called to conclude the @samp{else}
clause of a guard statement, as discussed in
@ref{Guard Statement}.

You can override a nonreturning method, but the new method must preserve
its return type and nonreturning behavior.

Grammar of a function declaration

function-declaration
→
function-head
function-name
generic-parameter-clause
_@{opt@}
function-signature
generic-where-clause
_@{opt@}
function-body
_@{opt@}

function-head →
attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{func}

function-name →
identifier
@multitable {}
@item
@end multitable
operator

function-signature →
parameter-clause
=throws=@math{_opt}
function-result
_@{opt@}

function-signature
→
parameter-clause
@samp{rethrows}
function-result
_@{opt@}

function-result → @samp{->}
attributes
_@{opt@} type

function-body →
code-block

parameter-clause → @samp{(}
@samp{)} | @samp{(}
parameter-list
@samp{)}

parameter-list →
parameter |
parameter
@samp{,}
parameter-list

parameter →
external-parameter-name
_@{opt@}
local-parameter-name
type-annotation
default-argument-clause
_@{opt@}

parameter →
external-parameter-name
_@{opt@}
local-parameter-name
type-annotation

parameter →
external-parameter-name
_@{opt@}
local-parameter-name
type-annotation
@samp{...}

external-parameter-name
→
identifier

local-parameter-name
→
identifier

default-argument-clause
→ @samp{=}
expression

@node Enumeration Declaration
@section Enumeration Declaration

An @emph{enumeration declaration} introduces a named enumeration type into
your program.

@findex enum

Enumeration declarations have two basic forms and are declared using the
@samp{enum} keyword. The body of an enumeration declared using either form
contains zero or more values---called @emph{enumeration cases}---and any
number of declarations, including computed properties, instance methods,
type methods, initializers, type aliases, and even other enumeration,
structure, and class declarations. Enumeration declarations can't
contain deinitializer or protocol declarations.

Enumeration types can adopt any number of protocols, but can't inherit
from classes, structures, or other enumerations.

Unlike classes and structures, enumeration types do not have an
implicitly provided default initializer; all initializers must be
declared explicitly. Initializers can delegate to other initializers in
the enumeration, but the initialization process is complete only after
an initializer assigns one of the enumeration cases to @samp{self}.

Like structures but unlike classes, enumerations are value types;
instances of an enumeration are copied when assigned to variables or
constants, or when passed as arguments to a function call. For
information about value types, see
@ref{Structures and Enumerations Are Value Types,Structures and
Enumerations Are Value Types,,swift,}.

You can extend the behavior of an enumeration type with an extension
declaration, as discussed in @ref{Extension Declaration, , Extension
Declaration}.

@menu
* Enumerations with Cases of Any Type::
* Enumerations with Cases of a Raw-Value Type::
* Accessing Enumeration Cases::
@end menu

@node Enumerations with Cases of Any Type
@subsection Enumerations with Cases of Any Type

The following form declares an enumeration type that contains
enumeration cases of any type:

@enumerate
@item
enum enumeration name: adopted protocols @{
@item
case enumeration case 1
@item
case enumeration case 2(associated value types)
@item
@}
@end enumerate

Enumerations declared in this form are sometimes called @emph{discriminated
unions} in other programming languages.

In this form, each case block consists of the @samp{case} keyword followed by
one or more enumeration cases, separated by commas. The name of each
case must be unique. Each case can also specify that it stores values of
a given type. These types are specified in the @emph{associated value types}
tuple, immediately following the name of the case.

Enumeration cases that store associated values can be used as functions
that create instances of the enumeration with the specified associated
values. And just like functions, you can get a reference to an
enumeration case and apply it later in your code.

@enumerate
@item
enum Number @{
@item
case integer(Int)
@item
case real(Double)
@item
@}
@item
let f = Number.integer
@item
// f is a function of type (Int) -> Number
@item

@item
// Apply f to create an array of Number instances with integer values
@item
let evenInts: [Number] = [0, 2, 4, 6].map(f)
@end enumerate

For more information and to see examples of cases with associated value
types, see @ref{Associated Values,Associated
Values,,swift,}.

@enumerate
@item
Enumerations with Indirection


Enumerations can have a recursive structure, that is, they can have
cases with associated values that are instances of the enumeration type
itself. However, instances of enumeration types have value semantics,
which means they have a fixed layout in memory. To support recursion,
the compiler must insert a layer of indirection.

To enable indirection for a particular enumeration case, mark it with
the @samp{indirect} declaration modifier. An indirect case must have an
associated value.

@enumerate
@item
enum Tree<T> @{
@item
case empty
@item
indirect case node(value: T, left: Tree, right: Tree)
@item
@}
@end enumerate

To enable indirection for all the cases of an enumeration that have an
associated value, mark the entire enumeration with the @samp{indirect}
modifier---this is convenient when the enumeration contains many cases
that would each need to be marked with the @samp{indirect} modifier.

An enumeration that is marked with the @samp{indirect} modifier can contain a
mixture of cases that have associated values and cases those that don't.
That said, it can't contain any cases that are also marked with the
@samp{indirect} modifier.
@end enumerate

@node Enumerations with Cases of a Raw-Value Type
@subsection Enumerations with Cases of a Raw-Value Type

The following form declares an enumeration type that contains
enumeration cases of the same basic type:

@enumerate
@item
enum enumeration name: raw-value type, adopted protocols @{
@item
case enumeration case 1 = raw value 1
@item
case enumeration case 2 = raw value 2
@item
@}
@end enumerate

In this form, each case block consists of the @samp{case} keyword, followed
by one or more enumeration cases, separated by commas. Unlike the cases
in the first form, each case has an underlying value, called a @emph{raw
value}, of the same basic type. The type of these values is specified in
the @emph{raw-value type} and must represent an integer, floating-point
number, string, or single character. In particular, the @emph{raw-value type}
must conform to the @samp{Equatable} protocol and one of the following
protocols: @samp{ExpressibleByIntegerLiteral} for integer literals,
@samp{ExpressibleByFloatLiteral} for floating-point literals,
@samp{ExpressibleByStringLiteral} for string literals that contain any number
of characters, and @samp{ExpressibleByUnicodeScalarLiteral} or
@samp{ExpressibleByExtendedGraphemeClusterLiteral} for string literals that
contain only a single character. Each case must have a unique name and
be assigned a unique raw value.

If the raw-value type is specified as @samp{Int} and you don't assign a value
to the cases explicitly, they are implicitly assigned the values @samp{0},
@samp{1}, @samp{2}, and so on. Each unassigned case of type @samp{Int} is implicitly
assigned a raw value that is automatically incremented from the raw
value of the previous case.

@enumerate
@item
enum ExampleEnum: Int @{
@item
case a, b, c = 5, d
@item
@}
@end enumerate

In the above example, the raw value of @samp{ExampleEnum.a} is @samp{0} and the
value of @samp{ExampleEnum.b} is @samp{1}. And because the value of
@samp{ExampleEnum.c} is explicitly set to @samp{5}, the value of @samp{ExampleEnum.d}
is automatically incremented from @samp{5} and is therefore @samp{6}.

If the raw-value type is specified as @samp{String} and you don't assign
values to the cases explicitly, each unassigned case is implicitly
assigned a string with the same text as the name of that case.

@enumerate
@item
enum GamePlayMode: String @{
@item
case cooperative, individual, competitive
@item
@}
@end enumerate

In the above example, the raw value of @samp{GamePlayMode.cooperative} is
@samp{"cooperative"}, the raw value of @samp{GamePlayMode.individual} is
@samp{"individual"}, and the raw value of @samp{GamePlayMode.competitive} is
@samp{"competitive"}.

Enumerations that have cases of a raw-value type implicitly conform to
the @samp{RawRepresentable} protocol, defined in the Swift standard library.
As a result, they have a @samp{rawValue} property and a failable initializer
with the signature @samp{init?(rawValue: RawValue)}. You can use the
@samp{rawValue} property to access the raw value of an enumeration case, as
in @samp{ExampleEnum.b.rawValue}. You can also use a raw value to find a
corresponding case, if there is one, by calling the enumeration's
failable initializer, as in @samp{ExampleEnum(rawValue: 5)}, which returns an
optional case. For more information and to see examples of cases with
raw-value types, see @ref{Raw Values,Raw
Values,,swift,}.

@node Accessing Enumeration Cases
@subsection Accessing Enumeration Cases

To reference the case of an enumeration type, use dot (@samp{.}) syntax, as
in @samp{EnumerationType.enumerationCase}. When the enumeration type can be
inferred from context, you can omit it (the dot is still required), as
described in @ref{Enumeration Syntax,Enumeration
Syntax,,swift,} and @ref{Implicit Member Expression}.

To check the values of enumeration cases, use a @samp{switch} statement, as
shown in @ref{Matching Enumeration Values with a Switch Statement,Matching
Enumeration Values with a Switch Statement,,swift,}. The enumeration type is
pattern-matched against the enumeration case patterns in the case blocks
of the @samp{switch} statement, as described in
@ref{Enumeration Case Pattern}.

Grammar of an enumeration declaration

enum-declaration →
attributes
_@{opt@}
access-level-modifier
_@{opt@}
union-style-enum

enum-declaration →
attributes
_@{opt@}
access-level-modifier
_@{opt@}
raw-value-style-enum

union-style-enum →
@samp{indirect=_@{opt@} =enum}
enum-name
generic-parameter-clause
_@{opt@}
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@} @samp{@{}
union-style-enum-members
_@{opt@} @samp{@}}

union-style-enum-members
→
union-style-enum-member
union-style-enum-members
_@{opt@}

union-style-enum-member
→
declaration
@multitable {}
@item
@end multitable
union-style-enum-case-clause
@multitable {}
@item
@end multitable
compiler-control-statement

union-style-enum-case-clause
→ attributes
_@{opt@} @samp{indirect=_@{opt@} =case}
union-style-enum-case-list

union-style-enum-case-list
→
union-style-enum-case
@multitable {}
@item
@end multitable
union-style-enum-case
@samp{,}
union-style-enum-case-list

union-style-enum-case
→
enum-case-name
tuple-type _@{opt@}

enum-name →
identifier

enum-case-name →
identifier

raw-value-style-enum
→ @samp{enum}
enum-name
generic-parameter-clause
_@{opt@}
type-inheritance-clause
generic-where-clause
_@{opt@} @samp{@{}
raw-value-style-enum-members
@samp{@}}

raw-value-style-enum-members
→
raw-value-style-enum-member
raw-value-style-enum-members
_@{opt@}

raw-value-style-enum-member
→
declaration
@multitable {}
@item
@end multitable
raw-value-style-enum-case-clause
@multitable {}
@item
@end multitable
compiler-control-statement

raw-value-style-enum-case-clause
→ attributes
_@{opt@} @samp{case}
raw-value-style-enum-case-list

raw-value-style-enum-case-list
→
raw-value-style-enum-case
@multitable {}
@item
@end multitable
raw-value-style-enum-case
@samp{,}
raw-value-style-enum-case-list

raw-value-style-enum-case
→
enum-case-name
raw-value-assignment
_@{opt@}

raw-value-assignment
→ @samp{=}
raw-value-literal

raw-value-literal →
numeric-literal
@multitable {}
@item
@end multitable
static-string-literal
@multitable {}
@item
@end multitable
boolean-literal

@node Structure Declaration
@section Structure Declaration

A @emph{structure declaration} introduces a named structure type into your
program. Structure declarations are declared using the @samp{struct} keyword
and have the following form:

@enumerate
@item
struct structure name: adopted protocols @{
@item
declarations
@item
@}
@end enumerate

The body of a structure contains zero or more @emph{declarations}. These
@emph{declarations} can include both stored and computed properties, type
properties, instance methods, type methods, initializers, subscripts,
type aliases, and even other structure, class, and enumeration
declarations. Structure declarations can't contain deinitializer or
protocol declarations. For a discussion and several examples of
structures that include various kinds of declarations, see
@ref{Structures and Classes,Structures and Classes,,swift,}.

Structure types can adopt any number of protocols, but can't inherit
from classes, enumerations, or other structures.

There are three ways to create an instance of a previously declared
structure:

@itemize
@item
Call one of the initializers declared within the structure, as
described in
@ref{Initializers,Initializers,,swift,}.

@item
If no initializers are declared, call the structure's memberwise
initializer, as described in
@ref{Memberwise Initializers for Structure Types,Memberwise Initializers
for Structure Types,,swift,}.

@item
If no initializers are declared, and all properties of the structure
declaration were given initial values, call the structure's default
initializer, as described in
@ref{Default Initializers,Default Initializers,,swift,}.
@end itemize

The process of initializing a structure's declared properties is
described in @ref{Initialization,Initialization,,swift,}.

Properties of a structure instance can be accessed using dot (@samp{.})
syntax, as described in
@ref{Accessing Properties,Accessing
Properties,,swift,}.

Structures are value types; instances of a structure are copied when
assigned to variables or constants, or when passed as arguments to a
function call. For information about value types, see
@ref{Structures and Enumerations Are Value Types,Structures and
Enumerations Are Value Types,,swift,}.

You can extend the behavior of a structure type with an extension
declaration, as discussed in @ref{Extension Declaration, , Extension
Declaration}.

Grammar of a structure declaration

struct-declaration →
attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{struct}
struct-name
generic-parameter-clause
_@{opt@}
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@}
struct-body

struct-name →
identifier

struct-body → @samp{@{}
struct-members
_@{opt@} @samp{@}}

struct-members →
struct-member
struct-members
_@{opt@}

struct-member →
declaration
@multitable {}
@item
@end multitable
compiler-control-statement

@node Class Declaration
@section Class Declaration

A @emph{class declaration} introduces a named class type into your program.
Class declarations are declared using the @samp{class} keyword and have the
following form:

@enumerate
@item
class class name: superclass, adopted protocols @{
@item
declarations
@item
@}
@end enumerate

The body of a class contains zero or more @emph{declarations}. These
@emph{declarations} can include both stored and computed properties, instance
methods, type methods, initializers, a single deinitializer, subscripts,
type aliases, and even other class, structure, and enumeration
declarations. Class declarations can't contain protocol declarations.
For a discussion and several examples of classes that include various
kinds of declarations, see
@ref{Structures and Classes,Structures and Classes,,swift,}.

A class type can inherit from only one parent class, its @emph{superclass},
but can adopt any number of protocols. The @emph{superclass} appears first
after the @emph{class name} and colon, followed by any @emph{adopted protocols}.
Generic classes can inherit from other generic and nongeneric classes,
but a nongeneric class can inherit only from other nongeneric classes.
When you write the name of a generic superclass class after the colon,
you must include the full name of that generic class, including its
generic parameter clause.

As discussed in @ref{Initializer Declaration},
classes can have designated and convenience initializers. The designated
initializer of a class must initialize all of the class's declared
properties and it must do so before calling any of its superclass's
designated initializers.

A class can override properties, methods, subscripts, and initializers
of its superclass. Overridden properties, methods, subscripts, and
designated initializers must be marked with the @samp{override} declaration
modifier.

To require that subclasses implement a superclass's initializer, mark
the superclass's initializer with the @samp{required} declaration modifier.
The subclass's implementation of that initializer must also be marked
with the @samp{required} declaration modifier.

Although properties and methods declared in the @emph{superclass} are
inherited by the current class, designated initializers declared in the
@emph{superclass} are only inherited when the subclass meets the conditions
described in @ref{Automatic Initializer Inheritance,Automatic
Initializer Inheritance,,swift,}. Swift classes do not inherit from a universal
base class.

There are two ways to create an instance of a previously declared class:

@itemize
@item
Call one of the initializers declared within the class, as described
in @ref{Initializers,Initializers,,swift,}.

@item
If no initializers are declared, and all properties of the class
declaration were given initial values, call the class's default
initializer, as described in
@ref{Default Initializers,Default Initializers,,swift,}.
@end itemize

Access properties of a class instance with dot (@samp{.}) syntax, as
described in
@ref{Accessing Properties,Accessing
Properties,,swift,}.

Classes are reference types; instances of a class are referred to,
rather than copied, when assigned to variables or constants, or when
passed as arguments to a function call. For information about reference
types, see
@ref{Structures and Enumerations Are Value Types,Structures and
Enumerations Are Value Types,,swift,}.

You can extend the behavior of a class type with an extension
declaration, as discussed in @ref{Extension Declaration, , Extension
Declaration}.

Grammar of a class declaration

class-declaration →
attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{final=_@{opt@} =class}
class-name
generic-parameter-clause
_@{opt@}
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@}
class-body

class-declaration →
attributes
_@{opt@} @samp{final}
access-level-modifier
_@{opt@} @samp{class}
class-name
generic-parameter-clause
_@{opt@}
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@}
class-body

class-name →
identifier

class-body → @samp{@{}
class-members
_@{opt@} @samp{@}}

class-members →
class-member
class-members
_@{opt@}

class-member →
declaration
@multitable {}
@item
@end multitable
compiler-control-statement

@node Protocol Declaration
@section Protocol Declaration

A @emph{protocol declaration} introduces a named protocol type into your
program. Protocol declarations are declared at global scope using the
@samp{protocol} keyword and have the following form:

@enumerate
@item
protocol protocol name: inherited protocols @{
@item
protocol member declarations
@item
@}
@end enumerate

The body of a protocol contains zero or more @emph{protocol member
declarations}, which describe the conformance requirements that any type
adopting the protocol must fulfill. In particular, a protocol can
declare that conforming types must implement certain properties,
methods, initializers, and subscripts. Protocols can also declare
special kinds of type aliases, called @emph{associated types}, that can
specify relationships among the various declarations of the protocol.
Protocol declarations can't contain class, structure, enumeration, or
other protocol declarations. The @emph{protocol member declarations} are
discussed in detail below.

Protocol types can inherit from any number of other protocols. When a
protocol type inherits from other protocols, the set of requirements
from those other protocols are aggregated, and any type that inherits
from the current protocol must conform to all those requirements. For an
example of how to use protocol inheritance, see
@ref{Protocol Inheritance,Protocol Inheritance,,swift,}.

Note

You can also aggregate the conformance requirements of multiple
protocols using protocol composition types, as described in
@ref{Protocol Composition Type} and
@ref{Protocol Composition,Protocol Composition,,swift,}.

You can add protocol conformance to a previously declared type by
adopting the protocol in an extension declaration of that type. In the
extension, you must implement all of the adopted protocol's
requirements. If the type already implements all of the requirements,
you can leave the body of the extension declaration empty.

By default, types that conform to a protocol must implement all
properties, methods, and subscripts declared in the protocol. That said,
you can mark these protocol member declarations with the @samp{optional}
declaration modifier to specify that their implementation by a
conforming type is optional. The @samp{optional} modifier can be applied only
to members that are marked with the @samp{objc} attribute, and only to
members of protocols that are marked with the @samp{objc} attribute. As a
result, only class types can adopt and conform to a protocol that
contains optional member requirements. For more information about how to
use the @samp{optional} declaration modifier and for guidance about how to
access optional protocol members---for example, when you're not sure
whether a conforming type implements them---see
@ref{Optional Protocol Requirements,Optional Protocol
Requirements,,swift,}.

To restrict the adoption of a protocol to class types only, include the
@samp{AnyObject} protocol in the @emph{inherited protocols} list after the colon.
For example, the following protocol can be adopted only by class types:

@enumerate
@item
protocol SomeProtocol: AnyObject @{
@item
@emph{* Protocol members go here *}
@item
@}
@end enumerate

Any protocol that inherits from a protocol that's marked with the
@samp{AnyObject} requirement can likewise be adopted only by class types.

Note

If a protocol is marked with the @samp{objc} attribute, the @samp{AnyObject}
requirement is implicitly applied to that protocol; there's no need to
mark the protocol with the @samp{AnyObject} requirement explicitly.

Protocols are named types, and thus they can appear in all the same
places in your code as other named types, as discussed in
@ref{Protocols as Types,Protocols as Types,,swift,}. However,
you can't construct an instance of a protocol, because protocols do not
actually provide the implementations for the requirements they specify.

You can use protocols to declare which methods a delegate of a class or
structure should implement, as described in
@ref{Delegation,Delegation,,swift,}.

Grammar of a protocol declaration

protocol-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{protocol}
protocol-name
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@}
protocol-body

protocol-name →
identifier

protocol-body → @samp{@{}
protocol-members
_@{opt@} @samp{@}}

protocol-members →
protocol-member
protocol-members
_@{opt@}

protocol-member →
protocol-member-declaration
@multitable {}
@item
@end multitable
compiler-control-statement

protocol-member-declaration
→
protocol-property-declaration

protocol-member-declaration
→
protocol-method-declaration

protocol-member-declaration
→
protocol-initializer-declaration

protocol-member-declaration
→
protocol-subscript-declaration

protocol-member-declaration
→
protocol-associated-type-declaration

protocol-member-declaration
→
typealias-declaration

@menu
* Protocol Property Declaration::
* Protocol Method Declaration::
* Protocol Initializer Declaration::
* Protocol Subscript Declaration::
* Protocol Associated Type Declaration::
@end menu

@node Protocol Property Declaration
@subsection Protocol Property Declaration

Protocols declare that conforming types must implement a property by
including a @emph{protocol property declaration} in the body of the protocol
declaration. Protocol property declarations have a special form of a
variable declaration:

@enumerate
@item
var property name: type @{ get set @}
@end enumerate

As with other protocol member declarations, these property declarations
declare only the getter and setter requirements for types that conform
to the protocol. As a result, you don't implement the getter or setter
directly in the protocol in which it is declared.

The getter and setter requirements can be satisfied by a conforming type
in a variety of ways. If a property declaration includes both the @samp{get}
and @samp{set} keywords, a conforming type can implement it with a stored
variable property or a computed property that is both readable and
writeable (that is, one that implements both a getter and a setter).
However, that property declaration can't be implemented as a constant
property or a read-only computed property. If a property declaration
includes only the @samp{get} keyword, it can be implemented as any kind of
property. For examples of conforming types that implement the property
requirements of a protocol, see
@ref{Property Requirements,Property Requirements,,swift,}.

See also @ref{Variable Declaration}.

Grammar of a protocol property declaration

protocol-property-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-keyword-block

@node Protocol Method Declaration
@subsection Protocol Method Declaration

Protocols declare that conforming types must implement a method by
including a protocol method declaration in the body of the protocol
declaration. Protocol method declarations have the same form as function
declarations, with two exceptions: They don't include a function body,
and you can't provide any default parameter values as part of the
function declaration. For examples of conforming types that implement
the method requirements of a protocol, see
@ref{Method Requirements,Method Requirements,,swift,}.

To declare a class or static method requirement in a protocol
declaration, mark the method declaration with the @samp{static} declaration
modifier. Structures and enumerations that conform to the protocol
declare the method with the @samp{static} keyword, and classes that conform
to the protocol declare the method with either the @samp{static} or @samp{class}
keyword. Extensions that add protocol conformance to a structure,
enumeration, or class use the same keyword as the type they extend uses.
Extensions that provide a default implementation for a type method
requirement use the @samp{static} keyword.

See also @ref{Function Declaration}.

Grammar of a protocol method declaration

protocol-method-declaration
→
function-head
function-name
generic-parameter-clause
_@{opt@}
function-signature
generic-where-clause
_@{opt@}

@node Protocol Initializer Declaration
@subsection Protocol Initializer Declaration

Protocols declare that conforming types must implement an initializer by
including a protocol initializer declaration in the body of the protocol
declaration. Protocol initializer declarations have the same form as
initializer declarations, except they don't include the initializer's
body.

A conforming type can satisfy a nonfailable protocol initializer
requirement by implementing a nonfailable initializer or an @samp{init!}
failable initializer. A conforming type can satisfy a failable protocol
initializer requirement by implementing any kind of initializer.

When a class implements an initializer to satisfy a protocol's
initializer requirement, the initializer must be marked with the
@samp{required} declaration modifier if the class is not already marked with
the @samp{final} declaration modifier.

See also @ref{Initializer Declaration}.

Grammar of a protocol initializer declaration

protocol-initializer-declaration
→
initializer-head
generic-parameter-clause
_@{opt@}
parameter-clause
=throws=@math{_opt}
generic-where-clause
_@{opt@}

protocol-initializer-declaration
→
initializer-head
generic-parameter-clause
_@{opt@}
parameter-clause
@samp{rethrows}
generic-where-clause
_@{opt@}

@node Protocol Subscript Declaration
@subsection Protocol Subscript Declaration

Protocols declare that conforming types must implement a subscript by
including a protocol subscript declaration in the body of the protocol
declaration. Protocol subscript declarations have a special form of a
subscript declaration:

@enumerate
@item
subscript (parameters) -> return type @{ get set @}
@end enumerate

Subscript declarations only declare the minimum getter and setter
implementation requirements for types that conform to the protocol. If
the subscript declaration includes both the @samp{get} and @samp{set} keywords, a
conforming type must implement both a getter and a setter clause. If the
subscript declaration includes only the @samp{get} keyword, a conforming type
must implement @emph{at least} a getter clause and optionally can implement a
setter clause.

See also @ref{Subscript Declaration}.

Grammar of a protocol subscript declaration

protocol-subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_@{opt@}
getter-setter-keyword-block

@node Protocol Associated Type Declaration
@subsection Protocol Associated Type Declaration

@findex associatedtype
@findex Self

Protocols declare associated types using the @samp{associatedtype} keyword.
An associated type provides an alias for a type that is used as part of
a protocol's declaration. Associated types are similar to type
parameters in generic parameter clauses, but they're associated with
@samp{Self} in the protocol in which they're declared. In that context,
@samp{Self} refers to the eventual type that conforms to the protocol. For
more information and examples, see
@ref{Associated Types,Associated Types,,swift,}.

@findex where

You use a generic @samp{where} clause in a protocol declaration to add
constraints to an associated types inherited from another protocol,
without redeclaring the associated types. For example, the declarations
of @samp{SubProtocol} below are equivalent:

@enumerate
@item
protocol SomeProtocol @{
@item
associatedtype SomeType
@item
@}
@item

@item
protocol SubProtocolA: SomeProtocol @{
@item
// This syntax produces a warning.
@item
associatedtype SomeType: Equatable
@item
@}
@item

@item
// This syntax is preferred.
@item
protocol SubProtocolB: SomeProtocol where SomeType: Equatable @{ @}
@end enumerate

See also @ref{Type Alias Declaration}.

Grammar of a protocol associated type declaration

protocol-associated-type-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{associatedtype}
typealias-name
type-inheritance-clause
_@{opt@}
typealias-assignment
_@{opt@}
generic-where-clause
_@{opt@}

@node Initializer Declaration
@section Initializer Declaration

An @emph{initializer declaration} introduces an initializer for a class,
structure, or enumeration into your program. Initializer declarations
are declared using the @samp{init} keyword and have two basic forms.

Structure, enumeration, and class types can have any number of
initializers, but the rules and associated behavior for class
initializers are different. Unlike structures and enumerations, classes
have two kinds of initializers: designated initializers and convenience
initializers, as described in
@ref{Initialization,Initialization,,swift,}.

The following form declares initializers for structures, enumerations,
and designated initializers of classes:

@enumerate
@item
init(parameters) @{
@item
statements
@item
@}
@end enumerate

A designated initializer of a class initializes all of the class's
properties directly. It can't call any other initializers of the same
class, and if the class has a superclass, it must call one of the
superclass's designated initializers. If the class inherits any
properties from its superclass, one of the superclass's designated
initializers must be called before any of these properties can be set or
modified in the current class.

Designated initializers can be declared in the context of a class
declaration only and therefore can't be added to a class using an
extension declaration.

Initializers in structures and enumerations can call other declared
initializers to delegate part or all of the initialization process.

To declare convenience initializers for a class, mark the initializer
declaration with the @samp{convenience} declaration modifier.

@enumerate
@item
convenience init(parameters) @{
@item
statements
@item
@}
@end enumerate

Convenience initializers can delegate the initialization process to
another convenience initializer or to one of the class's designated
initializers. That said, the initialization processes must end with a
call to a designated initializer that ultimately initializes the class's
properties. Convenience initializers can't call a superclass's
initializers.

You can mark designated and convenience initializers with the @samp{required}
declaration modifier to require that every subclass implement the
initializer. A subclass's implementation of that initializer must also
be marked with the @samp{required} declaration modifier.

By default, initializers declared in a superclass are not inherited by
subclasses. That said, if a subclass initializes all of its stored
properties with default values and doesn't define any initializers of
its own, it inherits all of the superclass's initializers. If the
subclass overrides all of the superclass's designated initializers, it
inherits the superclass's convenience initializers.

As with methods, properties, and subscripts, you need to mark overridden
designated initializers with the @samp{override} declaration modifier.

Note

If you mark an initializer with the @samp{required} declaration modifier, you
don't also mark the initializer with the @samp{override} modifier when you
override the required initializer in a subclass.

Just like functions and methods, initializers can throw or rethrow
errors. And just like functions and methods, you use the @samp{throws} or
@samp{rethrows} keyword after an initializer's parameters to indicate the
appropriate behavior.

To see examples of initializers in various type declarations, see
@ref{Initialization,Initialization,,swift,}.

@menu
* Failable Initializers::
@end menu

@node Failable Initializers
@subsection Failable Initializers

A @emph{failable initializer} is a type of initializer that produces an
optional instance or an implicitly unwrapped optional instance of the
type the initializer is declared on. As a result, a failable initializer
can return @samp{nil} to indicate that initialization failed.

To declare a failable initializer that produces an optional instance,
append a question mark to the @samp{init} keyword in the initializer
declaration (@samp{init?}). To declare a failable initializer that produces
an implicitly unwrapped optional instance, append an exclamation mark
instead (@samp{init!}). The example below shows an @samp{init?} failable
initializer that produces an optional instance of a structure.

@enumerate
@item
struct SomeStruct @{
@item
let property: String
@item
// produces an optional instance of 'SomeStruct'
@item
init?(input: String) @{
@item
if input.isEmpty @{
@item
// discard 'self' and return 'nil'
@item
return nil
@item
@}
@item
property = input
@item
@}
@item
@}
@end enumerate

You call an @samp{init?} failable initializer in the same way that you call a
nonfailable initializer, except that you must deal with the optionality
of the result.

@enumerate
@item
if let actualInstance = SomeStruct(input: "Hello") @{
@item
// do something with the instance of 'SomeStruct'
@item
@} else @{
@item
// initialization of 'SomeStruct' failed and the initializer returned
'nil'
@item
@}
@end enumerate

A failable initializer can return @samp{nil} at any point in the
implementation of the initializer's body.

A failable initializer can delegate to any kind of initializer. A
nonfailable initializer can delegate to another nonfailable initializer
or to an @samp{init!} failable initializer. A nonfailable initializer can
delegate to an @samp{init?} failable initializer by force-unwrapping the
result of the superclass's initializer---for example, by writing
@samp{super.init()!}.

Initialization failure propagates through initializer delegation.
Specifically, if a failable initializer delegates to an initializer that
fails and returns @samp{nil}, then the initializer that delegated also fails
and implicitly returns @samp{nil}. If a nonfailable initializer delegates to
an @samp{init!} failable initializer that fails and returns @samp{nil}, then a
runtime error is raised (as if you used the @samp{!} operator to unwrap an
optional that has a @samp{nil} value).

A failable designated initializer can be overridden in a subclass by any
kind of designated initializer. A nonfailable designated initializer can
be overridden in a subclass by a nonfailable designated initializer
only.

For more information and to see examples of failable initializers, see
@ref{Failable Initializers}.

Grammar of an initializer declaration

initializer-declaration
→
initializer-head
generic-parameter-clause
_@{opt@}
parameter-clause
=throws=@math{_opt}
generic-where-clause
_@{opt@}
initializer-body

initializer-declaration
→
initializer-head
generic-parameter-clause
_@{opt@}
parameter-clause
@samp{rethrows}
generic-where-clause
_@{opt@}
initializer-body

initializer-head →
attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{init}

initializer-head →
attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{init} @samp{?}

initializer-head →
attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{init} @samp{!}

initializer-body →
code-block

@node Deinitializer Declaration
@section Deinitializer Declaration

@findex deinit

A @emph{deinitializer declaration} declares a deinitializer for a class type.
Deinitializers take no parameters and have the following form:

@enumerate
@item
deinit @{
@item
statements
@item
@}
@end enumerate

A deinitializer is called automatically when there are no longer any
references to a class object, just before the class object is
deallocated. A deinitializer can be declared only in the body of a class
declaration---but not in an extension of a class---and each class can
have at most one.

A subclass inherits its superclass's deinitializer, which is implicitly
called just before the subclass object is deallocated. The subclass
object is not deallocated until all deinitializers in its inheritance
chain have finished executing.

Deinitializers are not called directly.

For an example of how to use a deinitializer in a class declaration, see
@ref{Deinitialization,Deinitialization,,swift,}.

Grammar of a deinitializer declaration

deinitializer-declaration
→ attributes
_@{opt@} @samp{deinit}
code-block

@node Extension Declaration
@section Extension Declaration

@findex extension

An @emph{extension declaration} allows you to extend the behavior of existing
types. Extension declarations are declared using the @samp{extension} keyword
and have the following form:

@enumerate
@item
extension type name where requirements @{
@item
declarations
@item
@}
@end enumerate

The body of an extension declaration contains zero or more
@emph{declarations}. These @emph{declarations} can include computed properties,
computed type properties, instance methods, type methods, initializers,
subscript declarations, and even class, structure, and enumeration
declarations. Extension declarations can't contain deinitializer or
protocol declarations, stored properties, property observers, or other
extension declarations. Declarations in a protocol extension can't be
marked @samp{final}. For a discussion and several examples of extensions that
include various kinds of declarations, see
@ref{Extensions,Extensions,,swift,}.

If the @emph{type name} is a class, structure, or enumeration type, the
extension extends that type. If the @emph{type name} is a protocol type, the
extension extends all types that conform to that protocol.

Extension declarations that extend a generic type or a protocol with
associated types can include @emph{requirements}. If an instance of the
extended type or of a type that conforms to the extended protocol
satisfies the @emph{requirements}, the instance gains the behavior specified
in the declaration.

Extension declarations can contain initializer declarations. That said,
if the type you're extending is defined in another module, an
initializer declaration must delegate to an initializer already defined
in that module to ensure members of that type are properly initialized.

Properties, methods, and initializers of an existing type can't be
overridden in an extension of that type.

Extension declarations can add protocol conformance to an existing
class, structure, or enumeration type by specifying @emph{adopted protocols}:

@enumerate
@item
extension type name: adopted protocols where requirements @{
@item
declarations
@item
@}
@end enumerate

Extension declarations can't add class inheritance to an existing class,
and therefore you can specify only a list of protocols after the @emph{type
name} and colon.

@menu
* Conditional Conformance::
* Protocol Conformance Must Not Be Redundant::
@end menu

@node Conditional Conformance
@subsection Conditional Conformance

You can extend a generic type to conditionally conform to a protocol, so
that instances of the type conform to the protocol only when certain
requirements are met. You add conditional conformance to a protocol by
including @emph{requirements} in an extension declaration.

@enumerate
@item
Overridden Requirements Aren't Used in Some Generic Contexts


In some generic contexts, types that get behavior from conditional
conformance to a protocol don't always use the specialized
implementations of that protocol's requirements. To illustrate this
behavior, the following example defines two protocols and a generic type
that conditionally conforms to both protocols.

@enumerate
@item
protocol Loggable @{
@item
func log()
@item
@}
@item
extension Loggable @{
@item
func log() @{
@item
print(self)
@item
@}
@item
@}
@item

@item
protocol TitledLoggable: Loggable @{
@item
static var logTitle: String @{ get @}
@item
@}
@item
extension TitledLoggable @{
@item
func log() @{
@item
print("\(Self.logTitle): \(self)")
@item
@}
@item
@}
@item

@item
struct Pair<T>: CustomStringConvertible @{
@item
let first: T
@item
let second: T
@item
var description: String @{
@item
return "(\(first), \(second))"
@item
@}
@item
@}
@item

@item
extension Pair: Loggable where T: Loggable @{ @}
@item
extension Pair: TitledLoggable where T: TitledLoggable @{
@item
static var logTitle: String @{
@item
return "Pair of '\(T.logTitle)'"
@item
@}
@item
@}
@item

@item
extension String: TitledLoggable @{
@item
static var logTitle: String @{
@item
return "String"
@item
@}
@item
@}
@end enumerate

The @samp{Pair} structure conforms to @samp{Loggable} and @samp{TitledLoggable}
whenever its generic type conforms to @samp{Loggable} or @samp{TitledLoggable},
respectively. In the example below, @samp{oneAndTwo} is an instance of
@samp{Pair<String>}, which conforms to @samp{TitledLoggable} because @samp{String}
conforms to @samp{TitledLoggable}. When the @samp{log()} method is called on
@samp{oneAndTwo} directly, the specialized version containing the title
string is used.

@enumerate
@item
let oneAndTwo = Pair(first: "one", second: "two")
@item
oneAndTwo.log()
@item
// Prints "Pair of 'String': (one, two)"
@end enumerate

However, when @samp{oneAndTwo} is used in a generic context or as an instance
of the @samp{Loggable} protocol, the specialized version isn't used. Swift
picks which implementation of @samp{log()} to call by consulting only the
minimum requirements that @samp{Pair} needs to conform to @samp{Loggable}. For
this reason, the default implementation provided by the @samp{Loggable}
protocol is used instead.

@enumerate
@item
func doSomething<T: Loggable>(with x: T) @{
@item
x.log()
@item
@}
@item
doSomething(with: oneAndTwo)
@item
// Prints "(one, two)"
@end enumerate

When @samp{log()} is called on the instance that's passed to
@samp{doSomething(_:)}, the customized title is omitted from the logged
string.
@end enumerate

@node Protocol Conformance Must Not Be Redundant
@subsection Protocol Conformance Must Not Be Redundant

A concrete type can conform to a particular protocol only once. Swift
marks redundant protocol conformances as an error. You're likely to
encounter this kind of error in two kinds of situations. The first
situation is when you explicitly conform to the same protocol multiple
times, but with different requirements. The second situation is when you
implicitly inherit from the same protocol multiple times. These
situations are discussed in the sections below.

@enumerate
@item
Resolving Explicit Redundancy


Multiple extensions on a concrete type can't add conformance to the same
protocol, even if the extensions' requirements are mutually exclusive.
This restriction is demonstrated in the example below. Two extension
declarations attempt to add conditional conformance to the
@samp{Serializable} protocol, one for for arrays with @samp{Int} elements, and one
for arrays with @samp{String} elements.

@enumerate
@item
protocol Serializable @{
@item
func serialize() -> Any
@item
@}
@item

@item
extension Array: Serializable where Element == Int @{
@item
func serialize() -> Any @{
@item
// implementation
@item
@}
@item
@}
@item
extension Array: Serializable where Element == String @{
@item
func serialize() -> Any @{
@item
// implementation
@item
@}
@item
@}
@item
// Error: redundant conformance of 'Array<Element>' to protocol
'Serializable'
@end enumerate

If you need to add conditional conformance based on multiple concrete
types, create a new protocol that each type can conform to and use that
protocol as the requirement when declaring conditional conformance.

@enumerate
@item
protocol SerializableInArray @{ @}
@item
extension Int: SerializableInArray @{ @}
@item
extension String: SerializableInArray @{ @}
@item

@item
extension Array: Serializable where Element: SerializableInArray @{
@item
func serialize() -> Any @{
@item
// implementation
@item
@}
@item
@}
@end enumerate

@item
Resolving Implicit Redundancy


When a concrete type conditionally conforms to a protocol, that type
implicitly conforms to any parent protocols with the same requirements.

If you need a type to conditionally conform to two protocols that
inherit from a single parent, explicitly declare conformance to the
parent protocol. This avoids implicitly conforming to the parent
protocol twice with different requirements.

The following example explicitly declares the conditional conformance of
@samp{Array} to @samp{Loggable} to avoid a conflict when declaring its conditional
conformance to both @samp{TitledLoggable} and the new @samp{MarkedLoggable}
protocol.

@enumerate
@item
protocol MarkedLoggable: Loggable @{
@item
func markAndLog()
@item
@}
@item

@item
extension MarkedLoggable @{
@item
func markAndLog() @{
@item
print("----------")
@item
log()
@item
@}
@item
@}
@item

@item
extension Array: Loggable where Element: Loggable @{ @}
@item
extension Array: TitledLoggable where Element: TitledLoggable @{
@item
static var logTitle: String @{
@item
return "Array of '\(Element.logTitle)'"
@item
@}
@item
@}
@item
extension Array: MarkedLoggable where Element: MarkedLoggable @{ @}
@end enumerate

Without the extension to explicitly declare conditional conformance to
@samp{Loggable}, the other @samp{Array} extensions would implicitly create these
declarations, resulting in an error:

@enumerate
@item
extension Array: Loggable where Element: TitledLoggable @{ @}
@item
extension Array: Loggable where Element: MarkedLoggable @{ @}
@item
// Error: redundant conformance of 'Array<Element>' to protocol
'Loggable'
@end enumerate

Grammar of an extension declaration

extension-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{extension}
type-identifier
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@}
extension-body

extension-body → @samp{@{}
extension-members
_@{opt@} @samp{@}}

extension-members →
extension-member
extension-members
_@{opt@}

extension-member →
declaration
@multitable {}
@item
@end multitable
compiler-control-statement
@end enumerate

@node Subscript Declaration
@section Subscript Declaration

A @emph{subscript} declaration allows you to add subscripting support for
objects of a particular type and are typically used to provide a
convenient syntax for accessing the elements in a collection, list, or
sequence. Subscript declarations are declared using the @samp{subscript}
keyword and have the following form:

@enumerate
@item
subscript (parameters) -> return type @{
@item
get @{
@item
statements
@item
@}
@item
set(setter name) @{
@item
statements
@item
@}
@item
@}
@end enumerate

Subscript declarations can appear only in the context of a class,
structure, enumeration, extension, or protocol declaration.

The @emph{parameters} specify one or more indexes used to access elements of
the corresponding type in a subscript expression (for example, the @samp{i}
in the expression @samp{object[i]}). Although the indexes used to access the
elements can be of any type, each parameter must include a type
annotation to specify the type of each index. The @emph{return type}
specifies the type of the element being accessed.

As with computed properties, subscript declarations support reading and
writing the value of the accessed elements. The getter is used to read
the value, and the setter is used to write the value. The setter clause
is optional, and when only a getter is needed, you can omit both clauses
and simply return the requested value directly. That said, if you
provide a setter clause, you must also provide a getter clause.

The @emph{setter name} and enclosing parentheses are optional. If you provide
a setter name, it is used as the name of the parameter to the setter. If
you do not provide a setter name, the default parameter name to the
setter is @samp{value}. The type of the parameter to the setter is the same
as the @emph{return type}.

You can overload a subscript declaration in the type in which it is
declared, as long as the @emph{parameters} or the @emph{return type} differ from
the one you're overloading. You can also override a subscript
declaration inherited from a superclass. When you do so, you must mark
the overridden subscript declaration with the @samp{override} declaration
modifier.

Subscript parameters follow the same rules as function parameters, with
two exceptions. By default, the parameters used in subscripting don't
have argument labels, unlike functions, methods, and initializers.
However, you can provide explicit argument labels using the same syntax
that functions, methods, and initializers use. In addition, subscripts
can't have in-out parameters.

You can also declare subscripts in the context of a protocol
declaration, as described in @ref{Protocol Subscript Declaration, , Protocol
Subscript Declaration}.

For more information about subscripting and to see examples of subscript
declarations, see @ref{Subscripts,Subscripts,,swift,}.

Grammar of a subscript declaration

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_@{opt@}
code-block

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_@{opt@}
getter-setter-block

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_@{opt@}
getter-setter-keyword-block

subscript-head →
attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{subscript}
generic-parameter-clause
_@{opt@}
parameter-clause

subscript-result → @samp{->}
attributes
_@{opt@} type

@node Operator Declaration
@section Operator Declaration

An @emph{operator declaration} introduces a new infix, prefix, or postfix
operator into your program and is declared using the @samp{operator} keyword.

You can declare operators of three different fixities: infix, prefix,
and postfix. The @emph{fixity} of an operator specifies the relative position
of an operator to its operands.

There are three basic forms of an operator declaration, one for each
fixity. The fixity of the operator is specified by marking the operator
declaration with the @samp{infix}, @samp{prefix}, or @samp{postfix} declaration
modifier before the @samp{operator} keyword. In each form, the name of the
operator can contain only the operator characters defined in
@ref{Operators}.

The following form declares a new infix operator:

@enumerate
@item
infix operator operator name: precedence group
@end enumerate

An @emph{infix operator} is a binary operator that is written between its two
operands, such as the familiar addition operator (@samp{+}) in the expression
@samp{1 + 2}.

Infix operators can optionally specify a precedence group. If you omit
the precedence group for an operator, Swift uses the default precedence
group, @samp{DefaultPrecedence}, which specifies a precedence just higher
than @samp{TernaryPrecedence}. For more information, see
@ref{Precedence Group Declaration}.

The following form declares a new prefix operator:

@enumerate
@item
prefix operator operator name
@end enumerate

A @emph{prefix operator} is a unary operator that is written immediately
before its operand, such as the prefix logical NOT operator (@samp{!}) in the
expression @samp{!a}.

Prefix operators declarations don't specify a precedence level. Prefix
operators are nonassociative.

The following form declares a new postfix operator:

@enumerate
@item
postfix operator operator name
@end enumerate

A @emph{postfix operator} is a unary operator that is written immediately
after its operand, such as the postfix forced-unwrap operator (@samp{!}) in
the expression @samp{a!}.

As with prefix operators, postfix operator declarations don't specify a
precedence level. Postfix operators are nonassociative.

After declaring a new operator, you implement it by declaring a static
method that has the same name as the operator. The static method is a
member of one of the types whose values the operator takes as an
argument---for example, an operator that multiplies a @samp{Double} by an
@samp{Int} is implemented as a static method on either the @samp{Double} or @samp{Int}
structure. If you're implementing a prefix or postfix operator, you must
also mark that method declaration with the corresponding @samp{prefix} or
@samp{postfix} declaration modifier. To see an example of how to create and
implement a new operator, see
@ref{Custom Operators,Custom Operators,,swift,}.

Grammar of an operator declaration

operator-declaration
→
prefix-operator-declaration
@multitable {}
@item
@end multitable
postfix-operator-declaration
@multitable {}
@item
@end multitable
infix-operator-declaration

prefix-operator-declaration
→ @samp{prefix} @samp{operator}
operator

postfix-operator-declaration
→ @samp{postfix} @samp{operator}
operator

infix-operator-declaration
→ @samp{infix} @samp{operator}
operator
infix-operator-group
_@{opt@}

infix-operator-group
→ @samp{:}
precedence-group-name

@node Precedence Group Declaration
@section Precedence Group Declaration

A @emph{precedence group declaration} introduces a new grouping for infix
operator precedence into your program. The precedence of an operator
specifies how tightly the operator binds to its operands, in the absence
of grouping parentheses.

A precedence group declaration has the following form:

@enumerate
@item
precedencegroup precedence group name @{
@item
higherThan: lower group names
@item
lowerThan: higher group names
@item
associativity: associativity
@item
assignment: assignment
@item
@}
@end enumerate

The @emph{lower group names} and @emph{higher group names} lists specify the new
precedence group's relation to existing precedence groups. The
@samp{lowerThan} precedence group attribute may only be used to refer to
precedence groups declared outside of the current module. When two
operators compete with each other for their operands, such as in the
expression @samp{2 + 3 * 5}, the operator with the higher relative precedence
binds more tightly to its operands.

Note

Precedence groups related to each other using @emph{lower group names} and
@emph{higher group names} must fit into a single relational hierarchy, but
they @emph{don't} have to form a linear hierarchy. This means it is possible
to have precedence groups with undefined relative precedence. Operators
from those precedence groups can't be used next to each other without
grouping parentheses.

Swift defines numerous precedence groups to go along with the operators
provided by the standard library. For example, the addition (@samp{+}) and
subtraction (@samp{-}) operators belong to the @samp{AdditionPrecedence} group,
and the multiplication (@samp{*}) and division (@samp{/}) operators belong to the
@samp{MultiplicationPrecedence} group. For a complete list of precedence
groups provided by the Swift standard library, see
@uref{https://developer.apple.com/documentation/swift/operator_declarations, Operator
Declarations}
[@uref{https://developer.apple.com/documentation/swift/operator_declarations}].

@findex associativity

The @emph{associativity} of an operator specifies how a sequence of operators
with the same precedence level are grouped together in the absence of
grouping parentheses. You specify the associativity of an operator by
writing one of the context-sensitive keywords @samp{left}, @samp{right}, or
@samp{none}---if your omit the associativity, the default is @samp{none}.
Operators that are left-associative group left-to-right. For example,
the subtraction operator (@samp{-}) is left-associative, so the expression
@samp{4 - 5 - 6} is grouped as @samp{(4 - 5) - 6} and evaluates to @samp{-7}. Operators
that are right-associative group right-to-left, and operators that are
specified with an associativity of @samp{none} don't associate at all.
Nonassociative operators of the same precedence level can't appear
adjacent to each to other. For example, the @samp{<} operator has an
associativity of @samp{none}, which means @samp{1 < 2 < 3} is not a valid
expression.

The @emph{assignment} of a precedence group specifies the precedence of an
operator when used in an operation that includes optional chaining. When
set to @samp{true}, an operator in the corresponding precedence group uses
the same grouping rules during optional chaining as the assignment
operators from the standard library. Otherwise, when set to @samp{false} or
omitted, operators in the precedence group follows the same optional
chaining rules as operators that don't perform assignment.

Grammar of a precedence group declaration

precedence-group-declaration
→ @samp{precedencegroup}
precedence-group-name
@samp{@{}
precedence-group-attributes
_@{opt@} @samp{@}}

precedence-group-attributes
→
precedence-group-attribute
precedence-group-attributes
_@{opt@}

precedence-group-attribute
→
precedence-group-relation

precedence-group-attribute
→
precedence-group-assignment

precedence-group-attribute
→
precedence-group-associativity

precedence-group-relation
→ @samp{higherThan} @samp{:}
precedence-group-names

precedence-group-relation
→ @samp{lowerThan} @samp{:}
precedence-group-names

precedence-group-assignment
→ @samp{assignment} @samp{:}
boolean-literal

precedence-group-associativity
→ @samp{associativity} @samp{:} @samp{left}

precedence-group-associativity
→ @samp{associativity} @samp{:} @samp{right}

precedence-group-associativity
→ @samp{associativity} @samp{:} @samp{none}

precedence-group-names
→
precedence-group-name
@multitable {}
@item
@end multitable
precedence-group-name
@samp{,}
precedence-group-names

precedence-group-name
→
identifier

@node Declaration Modifiers
@section Declaration Modifiers

@emph{Declaration modifiers} are keywords or context-sensitive keywords that
modify the behavior or meaning of a declaration. You specify a
declaration modifier by writing the appropriate keyword or
context-sensitive keyword between a declaration's attributes (if any)
and the keyword that introduces the declaration.

@table @asis
@item @samp{class}
Apply this modifier to a member of a class to indicate that
the member is a member of the class itself, rather than a member of
instances of the class. Members of a superclass that have this
modifier and don't have the @samp{final} modifier can be overridden by
subclasses.

@item @samp{dynamic}
Apply this modifier to any member of a class that can be
represented by Objective-C. When you mark a member declaration with
the @samp{dynamic} modifier, access to that member is always dynamically
dispatched using the Objective-C runtime. Access to that member is
never inlined or devirtualized by the compiler.

Because declarations marked with the @samp{dynamic} modifier are dispatched
using the Objective-C runtime, they must be marked with the @samp{objc}
attribute.

@item @samp{final}
Apply this modifier to a class or to a property, method, or
subscript member of a class. It's applied to a class to indicate that
the class can't be subclassed. It's applied to a property, method, or
subscript of a class to indicate that a class member can't be
overridden in any subclass. For an example of how to use the @samp{final}
attribute, see @ref{Preventing Overrides,Preventing
Overrides,,swift,}.

@item @samp{lazy}
Apply this modifier to a stored variable property of a class
or structure to indicate that the property's initial value is
calculated and stored at most once, when the property is first
accessed. For an example of how to use the @samp{lazy} modifier, see
@ref{Lazy Stored Properties,Lazy Stored Properties,,swift,}.

@item @samp{optional}
Apply this modifier to a protocol's property, method, or
subscript members to indicate that a conforming type isn't required to
implement those members.

You can apply the @samp{optional} modifier only to protocols that are
marked with the @samp{objc} attribute. As a result, only class types can
adopt and conform to a protocol that contains optional member
requirements. For more information about how to use the @samp{optional}
modifier and for guidance about how to access optional protocol
members---for example, when you're not sure whether a conforming type
implements them---see
@ref{Optional Protocol Requirements,Optional Protocol
Requirements,,swift,}.

@item @samp{required}
Apply this modifier to a designated or convenience
initializer of a class to indicate that every subclass must implement
that initializer. The subclass's implementation of that initializer
must also be marked with the @samp{required} modifier.

@item @samp{static}
Apply this modifier to a member of a structure, class,
enumeration, or protocol to indicate that the member is a member of
the type, rather than a member of instances of that type. In the scope
of a class declaration, writing the @samp{static} modifier on a member
declaration has the same effect as writing the @samp{class} and @samp{final}
modifiers on that member declaration. However, constant type
properties of a class are an exception: @samp{static} has its normal,
nonclass meaning there because you can't write @samp{class} or @samp{final} on
those declarations.

@item @samp{unowned}
Apply this modifier to a stored variable, constant, or
stored property to indicate that the variable or property has an
unowned reference to the object stored as its value. If you try to
access the variable or property after the object has been deallocated,
a runtime error is raised. Like a weak reference, the type of the
property or value must be a class type; unlike a weak reference, the
type is non-optional. For an example and more information about the
@samp{unowned} modifier, see
@ref{Unowned References,Unowned
References,,swift,}.

@item @samp{unowned(safe)}
An explicit spelling of @samp{unowned}.

@item @samp{unowned(unsafe)}
Apply this modifier to a stored variable,
constant, or stored property to indicate that the variable or property
has an unowned reference to the object stored as its value. If you try
to access the variable or property after the object has been
deallocated, you'll access the memory at the location where the object
used to be, which is a memory-unsafe operation. Like a weak reference,
the type of the property or value must be a class type; unlike a weak
reference, the type is non-optional. For an example and more
information about the @samp{unowned} modifier, see
@ref{Unowned References,Unowned
References,,swift,}.

@item @samp{weak}
Apply this modifier to a stored variable or stored variable
property to indicate that the variable or property has a weak
reference to the object stored as its value. The type of the variable
or property must be an optional class type. If you access the variable
or property after the object has been deallocated, its value is @samp{nil}.
For an example and more information about the @samp{weak} modifier, see
@ref{Weak References,Weak
References,,swift,}.
@end table

@menu
* Access Control Levels::
@end menu

@node Access Control Levels
@subsection Access Control Levels

Swift provides five levels of access control: open, public, internal,
file private, and private. You can mark a declaration with one of the
access-level modifiers below to specify the declaration's access level.
Access control is discussed in detail in
@ref{Access Control,Access Control,,swift,}.

@findex open

@table @asis
@item @samp{open}
Apply this modifier to a declaration to indicate the
declaration can be accessed and subclassed by code in the same module
as the declaration. Declarations marked with the @samp{open} access-level
modifier can also be accessed and subclassed by code in a module that
imports the module that contains that declaration.
@end table

@findex public

@table @asis
@item @samp{public}
Apply this modifier to a declaration to indicate the
declaration can be accessed and subclassed by code in the same module
as the declaration. Declarations marked with the @samp{public} access-level
modifier can also be accessed (but not subclassed) by code in a module
that imports the module that contains that declaration.
@end table

@findex internal

@table @asis
@item @samp{internal}
Apply this modifier to a declaration to indicate the
declaration can be accessed only by code in the same module as the
declaration. By default, most declarations are implicitly marked with
the @samp{internal} access-level modifier.
@end table

@findex fileprivate

@table @asis
@item @samp{fileprivate}
Apply this modifier to a declaration to indicate the
declaration can be accessed only by code in the same source file as
the declaration.
@end table

@findex private

@table @asis
@item @samp{private}
Apply this modifier to a declaration to indicate the
declaration can be accessed only by code within the declaration's
immediate enclosing scope.
@end table

For the purpose of access control, extensions to the same type that are
in the same file share an access-control scope. If the type they extend
is also in the same file, they share the type's access-control scope.
Private members declared in the type's declaration can be accessed from
extensions, and private members declared in one extension can be
accessed from other extensions and from the type's declaration.

Each access-level modifier above optionally accepts a single argument,
which consists of the @samp{set} keyword enclosed in parentheses (for
example, @samp{private(set)}). Use this form of an access-level modifier when
you want to specify an access level for the setter of a variable or
subscript that's less than or equal to the access level of the variable
or subscript itself, as discussed in
@ref{Getters and Setters,Getters and Setters,,swift,}.

Grammar of a declaration modifier

declaration-modifier
→ @samp{class} | @samp{convenience} | @samp{dynamic} | @samp{final} | @samp{infix} | @samp{lazy} |
@samp{optional} | @samp{override} | @samp{postfix} | @samp{prefix} | @samp{required} | @samp{static} |
@samp{unowned} | @samp{unowned} @samp{(} @samp{safe} @samp{)} | @samp{unowned} @samp{(} @samp{unsafe} @samp{)} |
@samp{weak}

declaration-modifier
→
access-level-modifier

declaration-modifier
→
mutation-modifier

declaration-modifiers
→
declaration-modifier
declaration-modifiers
_@{opt@}

access-level-modifier
→ @samp{private} | @samp{private} @samp{(} @samp{set} @samp{)}

access-level-modifier
→ @samp{fileprivate} | @samp{fileprivate} @samp{(} @samp{set} @samp{)}

access-level-modifier
→ @samp{internal} | @samp{internal} @samp{(} @samp{set} @samp{)}

access-level-modifier
→ @samp{public} | @samp{public} @samp{(} @samp{set} @samp{)}

access-level-modifier
→ @samp{open} | @samp{open} @samp{(} @samp{set} @samp{)}

mutation-modifier →
@samp{mutating} | @samp{nonmutating}

@node Attributes
@chapter Attributes

There are two kinds of attributes in Swift---those that apply to
declarations and those that apply to types. An attribute provides
additional information about the declaration or type. For example, the
@samp{discardableResult} attribute on a function declaration indicates that,
although the function returns a value, the compiler shouldn't generate a
warning if the return value is unused.

You specify an attribute by writing the @samp{@@} symbol followed by the
attribute's name and any arguments that the attribute accepts:

@enumerate
@item
@@attribute name
@item
@@attribute name(attribute arguments)
@end enumerate

Some declaration attributes accept arguments that specify more
information about the attribute and how it applies to a particular
declaration. These @emph{attribute arguments} are enclosed in parentheses,
and their format is defined by the attribute they belong to.

@menu
* Declaration Attributes::
* Type Attributes::
* Switch Case Attributes::
@end menu

@node Declaration Attributes
@section Declaration Attributes

You can apply a declaration attribute to declarations only.

@menu
* available::
* discardableResult::
* dynamicCallable::
* dynamicMemberLookup::
* GKInspectable::
* inlinable::
* nonobjc::
* NSApplicationMain::
* NSCopying::
* NSManaged::
* objc::
* objcMembers::
* requires@math{_stored}@math{_property}@math{_inits}::
* testable::
* UIApplicationMain::
* usableFromInline::
* warn@math{_unqualified}@math{_access}::
* Declaration Attributes Used by Interface Builder::
@end menu

@node available
@subsection available

Apply this attribute to indicate a declaration's life cycle relative to
certain Swift language versions or certain platforms and operating
system versions.

The @samp{available} attribute always appears with a list of two or more
comma-separated attribute arguments. These arguments begin with one of
the following platform or language names:

@itemize
@item
@samp{iOS}

@item
@samp{iOSApplicationExtension}

@item
@samp{macOS}

@item
@samp{macOSApplicationExtension}

@item
@samp{watchOS}

@item
@samp{watchOSApplicationExtension}

@item
@samp{tvOS}

@item
@samp{tvOSApplicationExtension}

@item
@samp{swift}
@end itemize

You can also use an asterisk (@samp{*}) to indicate the availability of the
declaration on all of the platform names listed above. An @samp{available}
attribute that specifies availability using a Swift version number can't
use the asterisk.

The remaining arguments can appear in any order and specify additional
information about the declaration's life cycle, including important
milestones.

@itemize
@item
The @samp{unavailable} argument indicates that the declaration isn't
available on the specified platform. This argument can't be used when
specifying Swift version availability.

@item
The @samp{introduced} argument indicates the first version of the specified
platform or language in which the declaration was introduced. It has
the following form:

@enumerate
@item
introduced: version number
@end enumerate

The @emph{version number} consists of one to three positive integers,
separated by periods.

@item
The @samp{deprecated} argument indicates the first version of the specified
platform or language in which the declaration was deprecated. It has
the following form:

@enumerate
@item
deprecated: version number
@end enumerate

The optional @emph{version number} consists of one to three positive
integers, separated by periods. Omitting the version number indicates
that the declaration is currently deprecated, without giving any
information about when the deprecation occurred. If you omit the
version number, omit the colon (@samp{:}) as well.

@item
The @samp{obsoleted} argument indicates the first version of the specified
platform or language in which the declaration was obsoleted. When a
declaration is obsoleted, it's removed from the specified platform or
language and can no longer be used. It has the following form:

@enumerate
@item
obsoleted: version number
@end enumerate

The @emph{version number} consists of one to three positive integers,
separated by periods.

@item
The @samp{message} argument provides a textual message that the compiler
displays when emitting a warning or error about the use of a
deprecated or obsoleted declaration. It has the following form:

@enumerate
@item
message: message
@end enumerate

The @emph{message} consists of a string literal.

@item
The @samp{renamed} argument provides a textual message that indicates the
new name for a declaration that's been renamed. The compiler displays
the new name when emitting an error about the use of a renamed
declaration. It has the following form:

@enumerate
@item
renamed: new name
@end enumerate

The @emph{new name} consists of a string literal.

You can apply the @samp{available} attribute with the @samp{renamed} and
@samp{unavailable} arguments to a type alias declaration, as shown below,
to indicate that the name of a declaration changed between releases of
a framework or library. This combination results in a compile-time
error that the declaration has been renamed.

@enumerate
@item
// First release
@item
protocol MyProtocol @{
@item
// protocol definition
@item
@}

@item
// Subsequent release renames MyProtocol
@item
protocol MyRenamedProtocol @{
@item
// protocol definition
@item
@}
@item

@item
@@available(*, unavailable, renamed: "MyRenamedProtocol")
@item
typealias MyProtocol = MyRenamedProtocol
@end enumerate
@end itemize

You can apply multiple @samp{available} attributes on a single declaration to
specify the declaration's availability on different platforms and
different versions of Swift. The declaration that the @samp{available}
attribute applies to is ignored if the attribute specifies a platform or
language version that doesn't match the current target. If you use
multiple @samp{available} attributes, the effective availability is the
combination of the platform and Swift availabilities.

If an @samp{available} attribute only specifies an @samp{introduced} argument in
addition to a platform or language name argument, you can use the
following shorthand syntax instead:

@enumerate
@item
@@available(platform name version number, *)
@item
@@available(swift version number)
@end enumerate

The shorthand syntax for @samp{available} attributes concisely expresses
availability for multiple platforms. Although the two forms are
functionally equivalent, the shorthand form is preferred whenever
possible.

@enumerate
@item
@@available(iOS 10.0, macOS 10.12, *)
@item
class MyClass @{
@item
// class definition
@item
@}
@end enumerate

An @samp{available} attribute that specifies availability using a Swift
version number can't additionally specify a declaration's platform
availability. Instead, use separate @samp{available} attributes to specify a
Swift version availability and one or more platform availabilities.

@enumerate
@item
@@available(swift 3.0.2)
@item
@@available(macOS 10.12, *)
@item
struct MyStruct @{
@item
// struct definition
@item
@}
@end enumerate

@node discardableResult
@subsection discardableResult

@findex @@discardableResult

Apply this attribute to a function or method declaration to suppress the
compiler warning when the function or method that returns a value is
called without using its result.

@node dynamicCallable
@subsection dynamicCallable

@findex @@dynamicCallable

Apply this attribute to a class, structure, enumeration, or protocol to
treat instances of the type as callable functions. The type must
implement either a @samp{dynamicallyCall(withArguments:)} method, a
@samp{dynamicallyCall(withKeywordArguments:)} method, or both.

You can call an instance of a dynamically callable type as if it's a
function that takes any number of arguments.

@enumerate
@item
@@dynamicCallable
@item
struct TelephoneExchange @{
@item
func dynamicallyCall(withArguments phoneNumber: [Int]) @{
@item
if phoneNumber == [4, 1, 1] @{
@item
print("Get Swift help on forums.swift.org")
@item
@} else @{
@item
print("Unrecognized number")
@item
@}
@item
@}
@item
@}
@item

@item
let dial = TelephoneExchange()
@item

@item
// Use a dynamic method call.
@item
dial(4, 1, 1)
@item
// Prints "Get Swift help on forums.swift.org"
@item

@item
dial(8, 6, 7, 5, 3, 0, 9)
@item
// Prints "Unrecognized number"
@item

@item
// Call the underlying method directly.
@item
dial.dynamicallyCall(withArguments: [4, 1, 1])
@end enumerate

The declaration of the @samp{dynamicallyCall(withArguments:)} method must
have a single parameter that conforms to the
@uref{https://developer.apple.com/documentation/swift/expressiblebyarrayliteral, @samp{ExpressibleByArrayLiteral}}
[@uref{https://developer.apple.com/documentation/swift/expressiblebyarrayliteral}]
protocol---like @samp{[Int]} in the example above. The return type can be any
type.

You can include labels in a dynamic method call if you implement the
@samp{dynamicallyCall(withKeywordArguments:)} method.

@enumerate
@item
@@dynamicCallable
@item
struct Repeater @{
@item
func dynamicallyCall(withKeywordArguments pairs:
KeyValuePairs<String, Int>) -> String @{
@item
return pairs
@item
.map @{ label, count in
@item
repeatElement(label, count: count).joined(separator: " ")
@item
@}
@item
.joined(separator: "")
@item
@}
@item
@}
@item

@item
let repeatLabels = Repeater()
@item
print(repeatLabels(a: 1, b: 2, c: 3, b: 2, a: 1))
@item
// a
@item
// b b
@item
// c c c
@item
// b b
@item
// a
@end enumerate

The declaration of the @samp{dynamicallyCall(withKeywordArguments:)} method
must have a single parameter that conforms to the
@uref{https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral, @samp{ExpressibleByDictionaryLiteral}}
[@uref{https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral}]
protocol, and the return type can be any type. The parameter's
@uref{https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key, @samp{Key}}
[@uref{https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key}]
must be
@uref{https://developer.apple.com/documentation/swift/expressiblebystringliteral, @samp{ExpressibleByStringLiteral}}
[@uref{https://developer.apple.com/documentation/swift/expressiblebystringliteral}].
The previous example uses
@uref{https://developer.apple.com/documentation/swift/keyvaluepairs, @samp{KeyValuePairs}}
[@uref{https://developer.apple.com/documentation/swift/keyvaluepairs}] as the
parameter type so that callers can include duplicate parameter
labels---@samp{a} and @samp{b} appear multiple times in the call to @samp{repeat}.

If you implement both @samp{dynamicallyCall} methods,
@samp{dynamicallyCall(withKeywordArguments:)} is called when the method call
includes keyword arguments. In all other cases,
@samp{dynamicallyCall(withArguments:)} is called.

You can only call a dynamically callable instance with arguments and a
return value that match the types you specify in one of your
@samp{dynamicallyCall} method implementations. The call in the following
example doesn't compile because there isn't an implementation of
@samp{dynamicallyCall(withArguments:)} that takes
@samp{KeyValuePairs<String, String>}.

@enumerate
@item
repeatLabels(a: "four") // Error
@end enumerate

@node dynamicMemberLookup
@subsection dynamicMemberLookup

@findex @@dynamicMemberLookup

Apply this attribute to a class, structure, enumeration, or protocol to
enable members to be looked up by name at runtime. The type must
implement a @samp{subscript(dynamicMemberLookup:)} subscript.

In an explicit member expression, if there isn't a corresponding
declaration for the named member, the expression is understood as a call
to the type's @samp{subscript(dynamicMemberLookup:)} subscript, passing
information about the member as the argument. The subscript can accept a
parameter that's either a key path or a member name; if you implement
both subscripts, the subscript that takes key path argument is used.

An implementation of @samp{subscript(dynamicMemberLookup:)} can accept key
paths using an argument of type
@uref{https://developer.apple.com/documentation/swift/keypath, @samp{KeyPath}}
[@uref{https://developer.apple.com/documentation/swift/keypath}],
@uref{https://developer.apple.com/documentation/swift/writablekeypath, @samp{WritableKeyPath}}
[@uref{https://developer.apple.com/documentation/swift/writablekeypath}], or
@uref{https://developer.apple.com/documentation/swift/referencewritablekeypath, @samp{ReferenceWritableKeyPath}}
[@uref{https://developer.apple.com/documentation/swift/referencewritablekeypath}].
It can accept member names using an argument of a type that conforms to
the
@uref{https://developer.apple.com/documentation/swift/expressiblebystringliteral, @samp{ExpressibleByStringLiteral}}
[@uref{https://developer.apple.com/documentation/swift/expressiblebystringliteral}]
protocol---in most cases, @samp{String}. The subscript's return type can be
any type.

Dynamic member lookup by member name can be used to create a wrapper
type around data that can't be type checked at compile time, such as
when bridging data from other languages into Swift. For example:

@enumerate
@item
@@dynamicMemberLookup
@item
struct DynamicStruct @{
@item
let dictionary = ["someDynamicMember": 325,
@item
"someOtherMember": 787]
@item
subscript(dynamicMember member: String) -> Int @{
@item
return dictionary[member] ?? 1054
@item
@}
@item
@}
@item
let s = DynamicStruct()
@item

@item
// Use dynamic member lookup.
@item
let dynamic = s.someDynamicMember
@item
print(dynamic)
@item
// Prints "325"
@item

@item
// Call the underlying subscript directly.
@item
let equivalent = s[dynamicMember: "someDynamicMember"]
@item
print(dynamic == equivalent)
@item
// Prints "true"
@end enumerate

@node GKInspectable
@subsection GKInspectable

@findex @@GKInspectable

Apply this attribute to expose a custom GameplayKit component property
to the SpriteKit editor UI. Applying this attribute also implies the
@samp{objc} attribute.

@node inlinable
@subsection inlinable

@findex @@inlinable

Apply this attribute to a function, method, computed property,
subscript, convenience initializer, or deinitializer declaration to
expose that declaration's implementation as part of the module's public
interface. The compiler is allowed to replace calls to an inlinable
symbol with a copy of the symbol's implementation at the call site.

Inlinable code can interact with @samp{public} symbols declared in any
module, and it can interact with @samp{internal} symbols declared in the same
module that are marked with the @samp{usableFromInline} attribute. Inlinable
code can't interact with @samp{private} or @samp{fileprivate} symbols.

This attribute can't be applied to declarations that are nested inside
functions or to @samp{fileprivate} or @samp{private} declarations. Functions and
closures that are defined inside an inlinable function are implicitly
inlinable, even though they can't be marked with this attribute.

@node nonobjc
@subsection nonobjc

@findex @@nonobjc

Apply this attribute to a method, property, subscript, or initializer
declaration to suppress an implicit @samp{objc} attribute. The @samp{nonobjc}
attribute tells the compiler to make the declaration unavailable in
Objective-C code, even though it's possible to represent it in
Objective-C.

Applying this attribute to an extension has the same effect as applying
it to every member of that extension that isn't explicitly marked with
the @samp{objc} attribute.

You use the @samp{nonobjc} attribute to resolve circularity for bridging
methods in a class marked with the @samp{objc} attribute, and to allow
overloading of methods and initializers in a class marked with the
@samp{objc} attribute.

A method marked with the @samp{nonobjc} attribute can't override a method
marked with the @samp{objc} attribute. However, a method marked with the
@samp{objc} attribute can override a method marked with the @samp{nonobjc}
attribute. Similarly, a method marked with the @samp{nonobjc} attribute can't
satisfy a protocol requirement for a method marked with the @samp{objc}
attribute.

@node NSApplicationMain
@subsection NSApplicationMain

@findex @@NSApplicationMain

Apply this attribute to a class to indicate that it's the application
delegate. Using this attribute is equivalent to calling the
@samp{NSApplicationMain(_:_:)} function.

If you don't use this attribute, supply a @samp{main.swift} file with code at
the top level that calls the @samp{NSApplicationMain(_:_:)} function as
follows:

@enumerate
@item
import AppKit
@item
NSApplicationMain(CommandLine.argc, CommandLine.unsafeArgv)
@end enumerate

@node NSCopying
@subsection NSCopying

@findex @@NSCopying

Apply this attribute to a stored variable property of a class. This
attribute causes the property's setter to be synthesized with a @emph{copy}
of the property's value---returned by the @samp{copyWithZone(_:)}
method---instead of the value of the property itself. The type of the
property must conform to the @samp{NSCopying} protocol.

The @samp{NSCopying} attribute behaves in a way similar to the Objective-C
@samp{copy} property attribute.

@node NSManaged
@subsection NSManaged

@findex @@dynamicCallable

Apply this attribute to an instance method or stored variable property
of a class that inherits from @samp{NSManagedObject} to indicate that Core
Data dynamically provides its implementation at runtime, based on the
associated entity description. For a property marked with the
@samp{NSManaged} attribute, Core Data also provides the storage at runtime.
Applying this attribute also implies the @samp{objc} attribute.

@node objc
@subsection objc

@findex @@objc

Apply this attribute to any declaration that can be represented in
Objective-C---for example, nonnested classes, protocols, nongeneric
enumerations (constrained to integer raw-value types), properties and
methods (including getters and setters) of classes, protocols and
optional members of a protocol, initializers, and subscripts. The @samp{objc}
attribute tells the compiler that a declaration is available to use in
Objective-C code.

Applying this attribute to an extension has the same effect as applying
it to every member of that extension that isn't explicitly marked with
the @samp{nonobjc} attribute.

The compiler implicitly adds the @samp{objc} attribute to subclasses of any
class defined in Objective-C. However, the subclass must not be generic,
and must not inherit from any generic classes. You can explicitly add
the @samp{objc} attribute to a subclass that meets these criteria, to specify
its Objective-C name as discussed below. Protocols that are marked with
the @samp{objc} attribute can't inherit from protocols that aren't marked
with this attribute.

The @samp{objc} attribute is also implicitly added in the following cases:

@itemize
@item
The declaration is an override in a subclass, and the superclass's
declaration has the @samp{objc} attribute.

@item
The declaration satisfies a requirement from a protocol that has the
@samp{objc} attribute.

@item
The declaration has the @samp{IBAction}, @samp{IBSegueAction}, @samp{IBOutlet},
@samp{IBDesignable}, @samp{IBInspectable}, @samp{NSManaged}, or @samp{GKInspectable}
attribute.
@end itemize

If you apply the @samp{objc} attribute to an enumeration, each enumeration
case is exposed to Objective-C code as the concatenation of the
enumeration name and the case name. The first letter of the case name is
capitalized. For example, a case named @samp{venus} in a Swift @samp{Planet}
enumeration is exposed to Objective-C code as a case named
@samp{PlanetVenus}.

The @samp{objc} attribute optionally accepts a single attribute argument,
which consists of an identifier. The identifier specifies the name to be
exposed to Objective-C for the entity that the @samp{objc} attribute applies
to. You can use this argument to name classes, enumerations, enumeration
cases, protocols, methods, getters, setters, and initializers. If you
specify the Objective-C name for a class, protocol, or enumeration,
include a three-letter prefix on the name, as described in
@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1, Conventions}
[@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1}]
in
@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210, Programming
with Objective-C}
[@uref{https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210}].
The example below exposes the getter for the @samp{enabled} property of the
@samp{ExampleClass} to Objective-C code as @samp{isEnabled} rather than just as
the name of the property itself.

@enumerate
@item
class ExampleClass: NSObject @{
@item
@@objc var enabled: Bool @{
@item
@@objc(isEnabled) get @{
@item
// Return the appropriate value
@item
@}
@item
@}
@item
@}
@end enumerate

@node objcMembers
@subsection objcMembers

@findex @@objcMembers

Apply this attribute to a class declaration, to implicitly apply the
@samp{objc} attribute to all Objective-C compatible members of the class, its
extensions, its subclasses, and all of the extensions of its subclasses.

Most code should use the @samp{objc} attribute instead, to expose only the
declarations that are needed. If you need to expose many declarations,
you can group them in an extension that has the @samp{objc} attribute. The
@samp{objcMembers} attribute is a convenience for libraries that make heavy
use of the introspection facilities of the Objective-C runtime. Applying
the @samp{objc} attribute when it isn't needed can increase your binary size
and adversely affect performance.

@node requires@math{_stored}@math{_property}@math{_inits}
@subsection requires@math{_stored}@math{_property}@math{_inits}

@findex @@requires_stored_property_inits

Apply this attribute to a class declaration to require all stored
properties within the class to provide default values as part of their
definitions. This attribute is inferred for any class that inherits from
@samp{NSManagedObject}.

@node testable
@subsection testable

@findex @@testable

Apply this attribute to an @samp{import} declaration to import that module
with changes to its access control that simplify testing the module's
code. Entities in the imported module that are marked with the
@samp{internal} access-level modifier are imported as if they were declared
with the @samp{public} access-level modifier. Classes and class members that
are marked with the @samp{internal} or @samp{public} access-level modifier are
imported as if they were declared with the @samp{open} access-level modifier.
The imported module must be compiled with testing enabled.

@node UIApplicationMain
@subsection UIApplicationMain

@findex @@UIApplicationMain

Apply this attribute to a class to indicate that it's the application
delegate. Using this attribute is equivalent to calling the
@samp{UIApplicationMain} function and passing this class's name as the name
of the delegate class.

If you don't use this attribute, supply a @samp{main.swift} file with code at
the top level that calls the
@uref{https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain, @samp{UIApplicationMain(_:_:_:_:)}}
[@uref{https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain}]
function. For example, if your app uses a custom subclass of
@samp{UIApplication} as its principal class, call the
@samp{UIApplicationMain(_:_:_:_:)} function instead of using this attribute.

@node usableFromInline
@subsection usableFromInline

@findex @@usableFromInline

Apply this attribute to a function, method, computed property,
subscript, initializer, or deinitializer declaration to allow that
symbol to be used in inlinable code that's defined in the same module as
the declaration. The declaration must have the @samp{internal} access level
modifier.

Like the @samp{public} access level modifier, this attribute exposes the
declaration as part of the module's public interface. Unlike @samp{public},
the compiler doesn't allow declarations marked with @samp{usableFromInline}
to be referenced by name in code outside the module, even though the
declaration's symbol is exported. However, code outside the module might
still be able to interact with the declaration's symbol by using runtime
behavior.

Declarations marked with the @samp{inlinable} attribute are implicitly usable
from inlinable code. Although either @samp{inlinable} or @samp{usableFromInline}
can be applied to @samp{internal} declarations, applying both attributes is
an error.

@node warn@math{_unqualified}@math{_access}
@subsection warn@math{_unqualified}@math{_access}

@findex @@warn_unqualified_access

Apply this attribute to a top-level function, instance method, or class
or static method to trigger warnings when that function or method is
used without a preceding qualifier, such as a module name, type name, or
instance variable or constant. Use this attribute to help discourage
ambiguity between functions with the same name that are accessible from
the same scope.

For example, the Swift standard library includes both a top-level
@uref{https://developer.apple.com/documentation/swift/1538339-min/, @samp{min(_:_:)}}
[@uref{https://developer.apple.com/documentation/swift/1538339-min/}] function
and a
@uref{https://developer.apple.com/documentation/swift/sequence/1641174-min, @samp{min()}}
[@uref{https://developer.apple.com/documentation/swift/sequence/1641174-min}]
method for sequences with comparable elements. The sequence method is
declared with the @samp{warn_unqualified_access} attribute to help reduce
confusion when attempting to use one or the other from within a
@samp{Sequence} extension.

@node Declaration Attributes Used by Interface Builder
@subsection Declaration Attributes Used by Interface Builder

Interface Builder attributes are declaration attributes used by
Interface Builder to synchronize with Xcode. Swift provides the
following Interface Builder attributes: @samp{IBAction}, @samp{IBSegueAction},
 @samp{IBOutlet}, @samp{IBDesignable}, and @samp{IBInspectable}. These attributes are
conceptually the same as their Objective-C counterparts.

You apply the @samp{IBOutlet} and @samp{IBInspectable} attributes to property
declarations of a class. You apply the @samp{IBAction} and @samp{IBSegueAction}
 attribute to method declarations of a class and the @samp{IBDesignable}
attribute to class declarations.

Applying the @samp{IBAction}, @samp{IBSegueAction}, @samp{IBOutlet}, @samp{IBDesignable}, or
@samp{IBInspectable} attribute also implies the @samp{objc} attribute.

@node Type Attributes
@section Type Attributes

You can apply type attributes to types only.

@menu
* autoclosure::
* convention::
* escaping::
@end menu

@node autoclosure
@subsection autoclosure

Apply this attribute to delay the evaluation of an expression by
automatically wrapping that expression in a closure with no arguments.
You apply it to a parameter's type in a method or function declaration,
for a parameter whose type is a function type that takes no arguments
and that returns a value of the type of the expression. For an example
of how to use the @samp{autoclosure} attribute, see
@ref{Autoclosures,Autoclosures,,swift,} and
@ref{Function Type}.

@node convention
@subsection convention

Apply this attribute to the type of a function to indicate its calling
conventions.

The @samp{convention} attribute always appears with one of the following
arguments:

@itemize
@item
The @samp{swift} argument indicates a Swift function reference. This is the
standard calling convention for function values in Swift.

@item
The @samp{block} argument indicates an Objective-C compatible block
reference. The function value is represented as a reference to the
block object, which is an @samp{id}-compatible Objective-C object that
embeds its invocation function within the object. The invocation
function uses the C calling convention.

@item
The @samp{c} argument indicates a C function reference. The function value
carries no context and uses the C calling convention.
@end itemize

With a few exceptions, a function of any calling convention can be used
when a function any other calling convention is needed. A nongeneric
global function, a local function that doesn't capture any local
variables or a closure that doesn't capture any local variables can be
converted to the C calling convention. Other Swift functions can't be
converted to the C calling convention. A function with the Objective-C
block calling convention can't be converted to the C calling convention.

@node escaping
@subsection escaping

Apply this attribute to a parameter's type in a method or function
declaration to indicate that the parameter's value can be stored for
later execution. This means that the value is allowed to outlive the
lifetime of the call. Function type parameters with the @samp{escaping} type
attribute require explicit use of @samp{self.} for properties or methods. For
an example of how to use the @samp{escaping} attribute, see
@ref{Escaping Closures,Escaping Closures,,swift,}.

@node Switch Case Attributes
@section Switch Case Attributes

You can apply switch case attributes to switch cases only.

@menu
* unknown::
@end menu

@node unknown
@subsection unknown

Apply this attribute to a switch case to indicate that it isn't expected
to be matched by any case of the enumeration that's known at the time
the code is compiled. For an example of how to use the @samp{unknown}
attribute, see Switching Over Future
Enumeration Cases.

Grammar of an attribute

attribute → @samp{@@}
attribute-name
attribute-argument-clause
_@{opt@}

attribute-name →
identifier

attribute-argument-clause
→ @samp{(}
balanced-tokens
_@{opt@} @samp{)}

attributes →
attribute
attributes
_@{opt@}

balanced-tokens →
balanced-token
balanced-tokens
_@{opt@}

balanced-token → @samp{(}
balanced-tokens
_@{opt@} @samp{)}

balanced-token → @samp{[}
balanced-tokens
_@{opt@} @samp{]}

balanced-token → @samp{@{}
balanced-tokens
_@{opt@} @samp{@}}

balanced-token → Any
identifier, keyword, literal, or operator

balanced-token → Any
punctuation except @samp{(}, @samp{)}, @samp{[}, @samp{]}, @samp{@{}, or @samp{@}}

@node Patterns
@chapter Patterns

A @emph{pattern} represents the structure of a single value or a composite
value. For example, the structure of a tuple @samp{(1, 2)} is a
comma-separated list of two elements. Because patterns represent the
structure of a value rather than any one particular value, you can match
them with a variety of values. For instance, the pattern @samp{(x, y)}
matches the tuple @samp{(1, 2)} and any other two-element tuple. In addition
to matching a pattern with a value, you can extract part or all of a
composite value and bind each part to a constant or variable name.

In Swift, there are two basic kinds of patterns: those that successfully
match any kind of value, and those that may fail to match a specified
value at runtime.

The first kind of pattern is used for destructuring values in simple
variable, constant, and optional bindings. These include wildcard
patterns, identifier patterns, and any value binding or tuple patterns
containing them. You can specify a type annotation for these patterns to
constrain them to match only values of a certain type.

The second kind of pattern is used for full pattern matching, where the
values you're trying to match against may not be there at runtime. These
include enumeration case patterns, optional patterns, expression
patterns, and type-casting patterns. You use these patterns in a case
label of a @samp{switch} statement, a @samp{catch} clause of a @samp{do} statement, or
in the case condition of an @samp{if}, @samp{while}, @samp{guard}, or @samp{for}-@samp{in}
statement.

Grammar of a pattern

pattern →
wildcard-pattern
type-annotation
_@{opt@}

pattern →
identifier-pattern
type-annotation
_@{opt@}

pattern →
value-binding-pattern

pattern →
tuple-pattern
type-annotation
_@{opt@}

pattern →
enum-case-pattern

pattern →
optional-pattern

pattern →
type-casting-pattern

pattern →
expression-pattern

@menu
* Wildcard Pattern::
* Identifier Pattern::
* Value-Binding Pattern::
* Tuple Pattern::
* Enumeration Case Pattern::
* Optional Pattern::
* Type-Casting Patterns::
* Expression Pattern::
@end menu

@node Wildcard Pattern
@section Wildcard Pattern

A @emph{wildcard pattern} matches and ignores any value and consists of an
underscore (@samp{_}). Use a wildcard pattern when you don't care about the
values being matched against. For example, the following code iterates
through the closed range @samp{1...3}, ignoring the current value of the
range on each iteration of the loop:

@enumerate
@item
for _ in 1@dots{}3 @{
@item
// Do something three times.
@item
@}
@end enumerate

Grammar of a wildcard pattern

wildcard-pattern → @samp{_}

@node Identifier Pattern
@section Identifier Pattern

An @emph{identifier pattern} matches any value and binds the matched value to
a variable or constant name. For example, in the following constant
declaration, @samp{someValue} is an identifier pattern that matches the value
@samp{42} of type @samp{Int}:

@enumerate
@item
let someValue = 42
@end enumerate

When the match succeeds, the value @samp{42} is bound (assigned) to the
constant name @samp{someValue}.

When the pattern on the left-hand side of a variable or constant
declaration is an identifier pattern, the identifier pattern is
implicitly a subpattern of a value-binding pattern.

Grammar of an identifier pattern

identifier-pattern →
identifier

@node Value-Binding Pattern
@section Value-Binding Pattern

A @emph{value-binding pattern} binds matched values to variable or constant
names. Value-binding patterns that bind a matched value to the name of a
constant begin with the @samp{let} keyword; those that bind to the name of
variable begin with the @samp{var} keyword.

Identifiers patterns within a value-binding pattern bind new named
variables or constants to their matching values. For example, you can
decompose the elements of a tuple and bind the value of each element to
a corresponding identifier pattern.

@enumerate
@item
let point = (3, 2)
@item
switch point @{
@item
// Bind x and y to the elements of point.
@item
case let (x, y):
@item
print("The point is at (\(x), \(y)).")
@item
@}
@item
// Prints "The point is at (3, 2)."
@end enumerate

In the example above, @samp{let} distributes to each identifier pattern in
the tuple pattern @samp{(x, y)}. Because of this behavior, the @samp{switch} cases
@samp{case let (x, y):} and @samp{case (let x, let y):} match the same values.

Grammar of a value-binding pattern

value-binding-pattern →
@samp{var} pattern |
@samp{let} pattern

@node Tuple Pattern
@section Tuple Pattern

A @emph{tuple pattern} is a comma-separated list of zero or more patterns,
enclosed in parentheses. Tuple patterns match values of corresponding
tuple types.

You can constrain a tuple pattern to match certain kinds of tuple types
by using type annotations. For example, the tuple pattern
@samp{(x, y): (Int, Int)} in the constant declaration
@samp{let (x, y): (Int, Int) = (1, 2)} matches only tuple types in which both
elements are of type @samp{Int}.

When a tuple pattern is used as the pattern in a @samp{for}-@samp{in} statement or
in a variable or constant declaration, it can contain only wildcard
patterns, identifier patterns, optional patterns, or other tuple
patterns that contain those. For example, the following code isn't valid
because the element @samp{0} in the tuple pattern @samp{(x, 0)} is an expression
pattern:

@enumerate
@item
let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]
@item
// This code isn't valid.
@item
for (x, 0) in points @{
@item
@emph{* @dots{} *}
@item
@}
@end enumerate

The parentheses around a tuple pattern that contains a single element
have no effect. The pattern matches values of that single element's
type. For example, the following are equivalent:

@enumerate
@item
let a = 2 // a: Int = 2
@item
let (a) = 2 // a: Int = 2
@item
let (a): Int = 2 // a: Int = 2
@end enumerate

Grammar of a tuple pattern

tuple-pattern → @samp{(}
tuple-pattern-element-list
_@{opt@} @samp{)}

tuple-pattern-element-list
→
tuple-pattern-element
@multitable {}
@item
@end multitable
tuple-pattern-element
@samp{,}
tuple-pattern-element-list

tuple-pattern-element →
pattern |
identifier
@samp{:} pattern

@node Enumeration Case Pattern
@section Enumeration Case Pattern

An @emph{enumeration case pattern} matches a case of an existing enumeration
type. Enumeration case patterns appear in @samp{switch} statement case labels
and in the case conditions of @samp{if}, @samp{while}, @samp{guard}, and @samp{for}-@samp{in}
statements.

If the enumeration case you're trying to match has any associated
values, the corresponding enumeration case pattern must specify a tuple
pattern that contains one element for each associated value. For an
example that uses a @samp{switch} statement to match enumeration cases
containing associated values, see
@ref{Associated Values,Associated Values,,swift,}.

Grammar of an enumeration case pattern

enum-case-pattern →
type-identifier
_@{opt@} @samp{.}
enum-case-name
tuple-pattern
_@{opt@}

@node Optional Pattern
@section Optional Pattern

An @emph{optional pattern} matches values wrapped in a @samp{some(Wrapped)} case
of an @samp{Optional<Wrapped>} enumeration. Optional patterns consist of an
identifier pattern followed immediately by a question mark and appear in
the same places as enumeration case patterns.

Because optional patterns are syntactic sugar for @samp{Optional} enumeration
case patterns, the following are equivalent:

@enumerate
@item
let someOptional: Int? = 42
@item
// Match using an enumeration case pattern.
@item
if case .some(let x) = someOptional @{
@item
print(x)
@item
@}
@item

@item
// Match using an optional pattern.
@item
if case let x? = someOptional @{
@item
print(x)
@item
@}
@end enumerate

The optional pattern provides a convenient way to iterate over an array
of optional values in a @samp{for}-@samp{in} statement, executing the body of the
loop only for non-@samp{nil} elements.

@enumerate
@item
let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]
@item
// Match only non-nil values.
@item
for case let number? in arrayOfOptionalInts @{
@item
print("Found a \(number)")
@item
@}
@item
// Found a 2
@item
// Found a 3
@item
// Found a 5
@end enumerate

Grammar of an optional pattern

optional-pattern →
identifier-pattern
@samp{?}

@node Type-Casting Patterns
@section Type-Casting Patterns

There are two type-casting patterns, the @samp{is} pattern and the @samp{as}
pattern. The @samp{is} pattern appears only in @samp{switch} statement case
labels. The @samp{is} and @samp{as} patterns have the following form:

@enumerate
@item
is type
@item
pattern as type
@end enumerate

The @samp{is} pattern matches a value if the type of that value at runtime is
the same as the type specified in the right-hand side of the @samp{is}
pattern---or a subclass of that type. The @samp{is} pattern behaves like the
@samp{is} operator in that they both perform a type cast but discard the
returned type.

The @samp{as} pattern matches a value if the type of that value at runtime is
the same as the type specified in the right-hand side of the @samp{as}
pattern---or a subclass of that type. If the match succeeds, the type of
the matched value is cast to the @emph{pattern} specified in the right-hand
side of the @samp{as} pattern.

For an example that uses a @samp{switch} statement to match values with @samp{is}
and @samp{as} patterns, see @ref{Type Casting for Any and AnyObject,Type
Casting for Any and AnyObject,,swift,}.

Grammar of a type casting pattern

type-casting-pattern →
is-pattern |
as-pattern

is-pattern → @samp{is}
type

as-pattern →
pattern @samp{as}
type

@node Expression Pattern
@section Expression Pattern

An @emph{expression pattern} represents the value of an expression.
Expression patterns appear only in @samp{switch} statement case labels.

The expression represented by the expression pattern is compared with
the value of an input expression using the Swift standard library @samp{~=}
operator. The matches succeeds if the @samp{~=} operator returns @samp{true}. By
default, the @samp{~=} operator compares two values of the same type using
the @samp{==} operator. It can also match a value with a range of values, by
checking whether the value is contained within the range, as the
following example shows.

@enumerate
@item
let point = (1, 2)
@item
switch point @{
@item
case (0, 0):
@item
print("(0, 0) is at the origin.")
@item
case (-2@dots{}2, -2@dots{}2):
@item
print("(\(point.0), \(point.1)) is near the origin.")
@item
default:
@item
print("The point is at (\(point.0), \(point.1)).")
@item
@}
@item
// Prints "(1, 2) is near the origin."
@end enumerate

You can overload the @samp{~=} operator to provide custom expression matching
behavior. For example, you can rewrite the above example to compare the
@samp{point} expression with a string representations of points.

@enumerate
@item
// Overload the ~= operator to match a string with an integer.
@item
func ~= (pattern: String, value: Int) -> Bool @{
@item
return pattern == "\(value)"
@item
@}
@item
switch point @{
@item
case ("0", "0"):
@item
print("(0, 0) is at the origin.")
@item
default:
@item
print("The point is at (\(point.0), \(point.1)).")
@item
@}
@item
// Prints "The point is at (1, 2)."
@end enumerate

Grammar of an expression pattern

expression-pattern →
expression

@node Generic Parameters and Arguments
@chapter Generic Parameters and Arguments

This chapter describes parameters and arguments for generic types,
functions, and initializers. When you declare a generic type, function,
subscript, or initializer, you specify the type parameters that the
generic type, function, or initializer can work with. These type
parameters act as placeholders that are replaced by actual concrete type
arguments when an instance of a generic type is created or a generic
function or initializer is called.

For an overview of generics in Swift, see
@ref{Generics,Generics,,swift,}.

@menu
* Generic Parameter Clause::
* Generic Argument Clause::
@end menu

@node Generic Parameter Clause
@section Generic Parameter Clause

A @emph{generic parameter clause} specifies the type parameters of a generic
type or function, along with any associated constraints and requirements
on those parameters. A generic parameter clause is enclosed in angle
brackets (<>) and has the following form:

@enumerate
@item
<generic parameter list>
@end enumerate

The @emph{generic parameter list} is a comma-separated list of generic
parameters, each of which has the following form:

@enumerate
@item
type parameter: constraint
@end enumerate

A generic parameter consists of a @emph{type parameter} followed by an
optional @emph{constraint}. A @emph{type parameter} is simply the name of a
placeholder type (for example, @samp{T}, @samp{U}, @samp{V}, @samp{Key}, @samp{Value}, and so
on). You have access to the type parameters (and any of their associated
types) in the rest of the type, function, or initializer declaration,
including in the signature of the function or initializer.

The @emph{constraint} specifies that a type parameter inherits from a
specific class or conforms to a protocol or protocol composition. For
example, in the generic function below, the generic parameter
@samp{T: Comparable} indicates that any type argument substituted for the
type parameter @samp{T} must conform to the @samp{Comparable} protocol.

@enumerate
@item
func simpleMax<T: Comparable>(_ x: T, _ y: T) -> T @{
@item
if x < y @{
@item
return y
@item
@}
@item
return x
@item
@}
@end enumerate

Because @samp{Int} and @samp{Double}, for example, both conform to the
@samp{Comparable} protocol, this function accepts arguments of either type.
In contrast with generic types, you don't specify a generic argument
clause when you use a generic function or initializer. The type
arguments are instead inferred from the type of the arguments passed to
the function or initializer.

@enumerate
@item
simpleMax(17, 42) // T is inferred to be Int
@item
simpleMax(3.14159, 2.71828) // T is inferred to be Double
@end enumerate

@menu
* Generic Where Clauses::
@end menu

@node Generic Where Clauses
@subsection Generic Where Clauses

You can specify additional requirements on type parameters and their
associated types by including a generic @samp{where} clause right before the
opening curly brace of a type or function's body. A generic @samp{where}
clause consists of the @samp{where} keyword, followed by a comma-separated
list of one or more @emph{requirements}.

@enumerate
@item
where requirements
@end enumerate

The @emph{requirements} in a generic @samp{where} clause specify that a type
parameter inherits from a class or conforms to a protocol or protocol
composition. Although the generic @samp{where} clause provides syntactic
sugar for expressing simple constraints on type parameters (for example,
@samp{<T: Comparable>} is equivalent to @samp{<T> where T: Comparable} and so on),
you can use it to provide more complex constraints on type parameters
and their associated types. For example, you can constrain the
associated types of type parameters to conform to protocols. For
example, @samp{<S: Sequence> where S.Iterator.Element: Equatable} specifies
that @samp{S} conforms to the @samp{Sequence} protocol and that the associated
type @samp{S.Iterator.Element} conforms to the @samp{Equatable} protocol. This
constraint ensures that each element of the sequence is equatable.

You can also specify the requirement that two types be identical, using
the @samp{==} operator. For example,
@samp{<S1: Sequence, S2: Sequence> where S1.Iterator.Element =} S2.Iterator.Element=
expresses the constraints that @samp{S1} and @samp{S2} conform to the @samp{Sequence}
protocol and that the elements of both sequences must be of the same
type.

Any type argument substituted for a type parameter must meet all the
constraints and requirements placed on the type parameter.

You can overload a generic function or initializer by providing
different constraints, requirements, or both on the type parameters.
When you call an overloaded generic function or initializer, the
compiler uses these constraints to resolve which overloaded function or
initializer to invoke.

For more information about generic @samp{where} clauses and to see an example
of one in a generic function declaration, see
@ref{Generic Where Clauses}.

Grammar of a generic parameter clause

generic-parameter-clause
→ @samp{<}
generic-parameter-list
@samp{>}

generic-parameter-list
→
generic-parameter
@multitable {}
@item
@end multitable
generic-parameter
@samp{,}
generic-parameter-list

generic-parameter
→ type-name

generic-parameter
→ type-name @samp{:}
type-identifier

generic-parameter
→ type-name @samp{:}
protocol-composition-type

generic-where-clause
→ @samp{where}
requirement-list

requirement-list
→
requirement
@multitable {}
@item
@end multitable
requirement
@samp{,}
requirement-list

requirement →
conformance-requirement
@multitable {}
@item
@end multitable
same-type-requirement

conformance-requirement
→
type-identifier
@samp{:}
type-identifier

conformance-requirement
→
type-identifier
@samp{:}
protocol-composition-type

same-type-requirement
→
type-identifier
@samp{==} type

@node Generic Argument Clause
@section Generic Argument Clause

A @emph{generic argument clause} specifies the type arguments of a generic
type. A generic argument clause is enclosed in angle brackets (<>) and
has the following form:

@enumerate
@item
<generic argument list>
@end enumerate

The @emph{generic argument list} is a comma-separated list of type arguments.
A @emph{type argument} is the name of an actual concrete type that replaces a
corresponding type parameter in the generic parameter clause of a
generic type. The result is a specialized version of that generic type.
The example below shows a simplified version of the Swift standard
library's generic dictionary type.

@enumerate
@item
struct Dictionary<Key: Hashable, Value>: Collection,
ExpressibleByDictionaryLiteral @{
@item
@emph{* @dots{} *}
@item
@}
@end enumerate

The specialized version of the generic @samp{Dictionary} type,
@samp{Dictionary<String, Int>} is formed by replacing the generic parameters
@samp{Key: Hashable} and @samp{Value} with the concrete type arguments @samp{String}
and @samp{Int}. Each type argument must satisfy all the constraints of the
generic parameter it replaces, including any additional requirements
specified in a generic @samp{where} clause. In the example above, the @samp{Key}
type parameter is constrained to conform to the @samp{Hashable} protocol and
therefore @samp{String} must also conform to the @samp{Hashable} protocol.

You can also replace a type parameter with a type argument that is
itself a specialized version of a generic type (provided it satisfies
the appropriate constraints and requirements). For example, you can
replace the type parameter @samp{Element} in @samp{Array<Element>} with a
specialized version of an array, @samp{Array<Int>}, to form an array whose
elements are themselves arrays of integers.

@enumerate
@item
let arrayOfArrays: Array<Array<Int>> = [[1, 2, 3], [4, 5, 6], [7, 8,
9]]
@end enumerate

As mentioned in @ref{Generic Parameter Clause, , Generic
Parameter Clause}, you don't use a generic argument clause to specify
the type arguments of a generic function or initializer.

Grammar of a generic argument clause

generic-argument-clause
→ @samp{<}
generic-argument-list
@samp{>}

generic-argument-list
→
generic-argument
@multitable {}
@item
@end multitable
generic-argument
@samp{,}
generic-argument-list

generic-argument
→ type

@node Summary of the Grammar
@chapter Summary of the Grammar

@menu
* Lexical Structure: Lexical Structure 1.
* Types: Types 1.
* Expressions: Expressions 1.
* Statements: Statements 1.
* Declarations: Declarations 1.
* Attributes: Attributes 1.
* Patterns: Patterns 1.
* Generic Parameters and Arguments: Generic Parameters and Arguments 1.
@end menu

@node Lexical Structure 1
@section Lexical Structure

Grammar of whitespace

whitespace →
whitespace-item
whitespace
_@{opt@}

whitespace-item
→
line-break

whitespace-item
→ comment

whitespace-item
→
multiline-comment

whitespace-item
→ U+0000, U+0009, U+000B, U+000C, or U+0020

line-break →
U+000A

line-break →
U+000D

line-break →
U+000D followed by U+000A

comment → @samp{//}
comment-text
line-break

multiline-comment
→ @samp{/*}
multiline-comment-text
@samp{*/}

comment-text →
comment-text-item
comment-text
_@{opt@}

comment-text-item
→ Any Unicode scalar value except U+000A or U+000D

multiline-comment-text
→
multiline-comment-text-item
multiline-comment-text
_@{opt@}

multiline-comment-text-item
→
multiline-comment

multiline-comment-text-item
→
comment-text-item

multiline-comment-text-item
→ Any Unicode scalar value except @samp{/*} or @samp{*/}

Grammar of an identifier

identifier →
identifier-head
identifier-characters
_@{opt@}

identifier → @samp{`}
identifier-head
identifier-characters
_@{opt@} @samp{`}

identifier →
implicit-parameter-name

identifier-list
→
identifier
@multitable {}
@item
@end multitable
identifier
@samp{,}
identifier-list

identifier-head
→ Upper- or lowercase letter A through Z

identifier-head
→ @samp{_}

identifier-head
→ U+00A8, U+00AA, U+00AD, U+00AF, U+00B2--U+00B5, or U+00B7--U+00BA

identifier-head
→ U+00BC--U+00BE, U+00C0--U+00D6, U+00D8--U+00F6, or U+00F8--U+00FF

identifier-head
→ U+0100--U+02FF, U+0370--U+167F, U+1681--U+180D, or U+180F--U+1DBF

identifier-head
→ U+1E00--U+1FFF

identifier-head
→ U+200B--U+200D, U+202A--U+202E, U+203F--U+2040, U+2054, or
U+2060--U+206F

identifier-head
→ U+2070--U+20CF, U+2100--U+218F, U+2460--U+24FF, or U+2776--U+2793

identifier-head
→ U+2C00--U+2DFF or U+2E80--U+2FFF

identifier-head
→ U+3004--U+3007, U+3021--U+302F, U+3031--U+303F, or U+3040--U+D7FF

identifier-head
→ U+F900--U+FD3D, U+FD40--U+FDCF, U+FDF0--U+FE1F, or U+FE30--U+FE44

identifier-head
→ U+FE47--U+FFFD

identifier-head
→ U+10000--U+1FFFD, U+20000--U+2FFFD, U+30000--U+3FFFD, or
U+40000--U+4FFFD

identifier-head
→ U+50000--U+5FFFD, U+60000--U+6FFFD, U+70000--U+7FFFD, or
U+80000--U+8FFFD

identifier-head
→ U+90000--U+9FFFD, U+A0000--U+AFFFD, U+B0000--U+BFFFD, or
U+C0000--U+CFFFD

identifier-head
→ U+D0000--U+DFFFD or U+E0000--U+EFFFD

identifier-character
→ Digit 0 through 9

identifier-character
→ U+0300--U+036F, U+1DC0--U+1DFF, U+20D0--U+20FF, or U+FE20--U+FE2F

identifier-character
→
identifier-head

identifier-characters
→
identifier-character
identifier-characters
_@{opt@}

implicit-parameter-name
→ @samp{$}
decimal-digits

Grammar of a literal

literal →
numeric-literal
@multitable {}
@item
@end multitable
string-literal
@multitable {}
@item
@end multitable
boolean-literal
@multitable {}
@item
@end multitable
nil-literal

numeric-literal
→ =-=@math{_opt}
integer-literal
@multitable {aaaaaaaaa}
@item =-=@math{_opt}
@end multitable
floating-point-literal

boolean-literal
→ @samp{true} | @samp{false}

nil-literal →
@samp{nil}

Grammar of an integer literal

integer-literal
→
binary-literal

integer-literal
→
octal-literal

integer-literal
→
decimal-literal

integer-literal
→
hexadecimal-literal

binary-literal
→ @samp{0b}
binary-digit
binary-literal-characters
_@{opt@}

binary-digit →
Digit 0 or 1

binary-literal-character
→
binary-digit
@multitable {aaa}
@item @samp{_}
@end multitable

binary-literal-characters
→
binary-literal-character
binary-literal-characters
_@{opt@}

octal-literal
→ @samp{0o}
octal-digit
octal-literal-characters
_@{opt@}

octal-digit →
Digit 0 through 7

octal-literal-character
→
octal-digit
@multitable {aaa}
@item @samp{_}
@end multitable

octal-literal-characters
→
octal-literal-character
octal-literal-characters
_@{opt@}

decimal-literal
→
decimal-digit
decimal-literal-characters
_@{opt@}

decimal-digit
→ Digit 0 through 9

decimal-digits
→
decimal-digit
decimal-digits
_@{opt@}

decimal-literal-character
→
decimal-digit
@multitable {aaa}
@item @samp{_}
@end multitable

decimal-literal-characters
→
decimal-literal-character
decimal-literal-characters
_@{opt@}

hexadecimal-literal
→ @samp{0x}
hexadecimal-digit
hexadecimal-literal-characters
_@{opt@}

hexadecimal-digit
→ Digit 0 through 9, a through f, or A through F

hexadecimal-literal-character
→
hexadecimal-digit
@multitable {aaa}
@item @samp{_}
@end multitable

hexadecimal-literal-characters
→
hexadecimal-literal-character
hexadecimal-literal-characters
_@{opt@}

Grammar of a floating-point literal

floating-point-literal
→
decimal-literal
decimal-fraction
_@{opt@}
decimal-exponent
_@{opt@}

floating-point-literal
→
hexadecimal-literal
hexadecimal-fraction
_@{opt@}
hexadecimal-exponent

decimal-fraction
→ @samp{.}
decimal-literal

decimal-exponent
→
floating-point-e
sign _@{opt@}
decimal-literal

hexadecimal-fraction
→ @samp{.}
hexadecimal-digit
hexadecimal-literal-characters
_@{opt@}

hexadecimal-exponent
→
floating-point-p
sign _@{opt@}
decimal-literal

floating-point-e
→ @samp{e} | @samp{E}

floating-point-p
→ @samp{p} | @samp{P}

sign → @samp{+} | @samp{-}

Grammar of a string literal

string-literal
→
static-string-literal
@multitable {}
@item
@end multitable
interpolated-string-literal

string-literal-opening-delimiter
→
extended-string-literal-delimiter
_@{opt@} @samp{"}

string-literal-closing-delimiter
→ @samp{"}
extended-string-literal-delimiter
_@{opt@}

static-string-literal
→
string-literal-opening-delimiter
quoted-text
_@{opt@}
string-literal-closing-delimiter

static-string-literal
→
multiline-string-literal-opening-delimiter
multiline-quoted-text
_@{opt@}
multiline-string-literal-closing-delimiter

multiline-string-literal-opening-delimiter
→
extended-string-literal-delimiter
@samp{"""}

multiline-string-literal-closing-delimiter
→ @samp{"""}
extended-string-literal-delimiter

extended-string-literal-delimiter
→ @samp{#}
extended-string-literal-delimiter
_@{opt@}

quoted-text →
quoted-text-item
quoted-text
_@{opt@}

quoted-text-item
→
escaped-character

quoted-text-item
→ Any Unicode scalar value except @samp{"}, @samp{\}, U+000A, or U+000D

multiline-quoted-text
→
multiline-quoted-text-item
multiline-quoted-text
_@{opt@}

multiline-quoted-text-item
→
escaped-character

multiline-quoted-text-item
→ Any Unicode scalar value except @samp{\}

multiline-quoted-text-item
→
escaped-newline

interpolated-string-literal
→
string-literal-opening-delimiter
interpolated-text
_@{opt@}
string-literal-closing-delimiter

interpolated-string-literal
→
multiline-string-literal-opening-delimiter
interpolated-text
_@{opt@}
multiline-string-literal-closing-delimiter

interpolated-text
→
interpolated-text-item
interpolated-text
_@{opt@}

interpolated-text-item
→ @samp{\(}
expression
@samp{)} |
quoted-text-item

multiline-interpolated-text
→
multiline-interpolated-text-item
multiline-interpolated-text
_@{opt@}

multiline-interpolated-text-item
→ @samp{\(}
expression
@samp{)} |
multiline-quoted-text-item

escape-sequence
→ @samp{\}
extended-string-literal-delimiter

escaped-character
→
escape-sequence
@samp{0} |
escape-sequence
@samp{\} |
escape-sequence
@samp{t} |
escape-sequence
@samp{n} |
escape-sequence
@samp{r} |
escape-sequence
@samp{"} |
escape-sequence
@samp{'}

escaped-character
→
escape-sequence
@samp{u} @samp{@{}
unicode-scalar-digits
@samp{@}}

unicode-scalar-digits
→ Between one and eight hexadecimal digits

escaped-newline
→
escape-sequence
whitespace
_@{opt@}
line-break

Grammar of operators

operator →
operator-head
operator-characters
_@{opt@}

operator →
dot-operator-head
dot-operator-characters

operator-head
→ @samp{/} | @samp{=} | @samp{-} | @samp{+} | @samp{!} | @samp{*} | @samp{%} | @samp{<} | @samp{>} | @samp{&} | @samp{|} | @samp{^}
@multitable {aaa} {aaa}
@item @samp{~}
@tab @samp{?}
@end multitable

operator-head
→ U+00A1--U+00A7

operator-head
→ U+00A9 or U+00AB

operator-head
→ U+00AC or U+00AE

operator-head
→ U+00B0--U+00B1

operator-head
→ U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7

operator-head
→ U+2016--U+2017

operator-head
→ U+2020--U+2027

operator-head
→ U+2030--U+203E

operator-head
→ U+2041--U+2053

operator-head
→ U+2055--U+205E

operator-head
→ U+2190--U+23FF

operator-head
→ U+2500--U+2775

operator-head
→ U+2794--U+2BFF

operator-head
→ U+2E00--U+2E7F

operator-head
→ U+3001--U+3003

operator-head
→ U+3008--U+3020

operator-head
→ U+3030

operator-character
→
operator-head

operator-character
→ U+0300--U+036F

operator-character
→ U+1DC0--U+1DFF

operator-character
→ U+20D0--U+20FF

operator-character
→ U+FE00--U+FE0F

operator-character
→ U+FE20--U+FE2F

operator-character
→ U+E0100--U+E01EF

operator-characters
→
operator-character
operator-characters
_@{opt@}

dot-operator-head
→ @samp{.}

dot-operator-character
→ @samp{.} |
operator-character

dot-operator-characters
→
dot-operator-character
dot-operator-characters
_@{opt@}

binary-operator
→
operator

prefix-operator
→
operator

postfix-operator
→
operator

@node Types 1
@section Types

Grammar of a type

type →
function-type

type →
array-type

type →
dictionary-type

type →
type-identifier

type →
tuple-type

type →
optional-type

type →
implicitly-unwrapped-optional-type

type →
protocol-composition-type

type →
opaque-type

type →
metatype-type

type →
self-type

type → @samp{Any}

type → @samp{(}
type @samp{)}

Grammar of a type annotation

type-annotation
→ @samp{:}
attributes
_@{opt@} =inout=@math{_opt}
type

Grammar of a type identifier

type-identifier
→ type-name
generic-argument-clause
_@{opt@} | type-name
generic-argument-clause
_@{opt@} @samp{.}
type-identifier

type-name →
identifier

Grammar of a tuple type

tuple-type → @samp{(}
@samp{)} | @samp{(}
tuple-type-element
@samp{,}
tuple-type-element-list
@samp{)}

tuple-type-element-list
→
tuple-type-element
@multitable {}
@item
@end multitable
tuple-type-element
@samp{,}
tuple-type-element-list

tuple-type-element
→ element-name
type-annotation
@multitable {aaaa}
@item type
@end multitable

element-name →
identifier

Grammar of a function type

function-type
→ attributes
_@{opt@}
function-type-argument-clause
@samp{throws=_@{opt@} =->}
type

function-type
→ attributes
_@{opt@}
function-type-argument-clause
@samp{rethrows} @samp{->} type

function-type-argument-clause
→ @samp{(} @samp{)}

function-type-argument-clause
→ @samp{(}
function-type-argument-list
@samp{...=_@{opt@} =)}

function-type-argument-list
→
function-type-argument
@multitable {}
@item
@end multitable
function-type-argument
@samp{,}
function-type-argument-list

function-type-argument
→ attributes
_@{opt@} =inout=@math{_opt}
type |
argument-label
type-annotation

argument-label
→
identifier

Grammar of an array type

array-type → @samp{[}
type @samp{]}

Grammar of a dictionary type

dictionary-type
→ @samp{[} type @samp{:}
type @samp{]}

Grammar of an optional type

optional-type
→ type @samp{?}

Grammar of an implicitly unwrapped optional type

implicitly-unwrapped-optional-type
→ type @samp{!}

Grammar of a protocol composition type

protocol-composition-type
→
type-identifier
@samp{&}
protocol-composition-continuation

protocol-composition-continuation
→
type-identifier
@multitable {}
@item
@end multitable
protocol-composition-type

Grammar of an opaque type

opaque-type →
@samp{some} type

Grammar of a metatype type

metatype-type
→ type @samp{.} @samp{Type} |
type @samp{.} @samp{Protocol}

Grammar of a type inheritance clause

type-inheritance-clause
→ @samp{:}
type-inheritance-list

type-inheritance-list
→
type-identifier
@multitable {}
@item
@end multitable
type-identifier
@samp{,}
type-inheritance-list

@node Expressions 1
@section Expressions

Grammar of an expression

expression →
try-operator
_@{opt@}
prefix-expression
binary-expressions
_@{opt@}

expression-list
→
expression
@multitable {}
@item
@end multitable
expression
@samp{,}
expression-list

Grammar of a prefix expression

prefix-expression
→
prefix-operator
_@{opt@}
postfix-expression

prefix-expression
→
in-out-expression

in-out-expression
→ @samp{&}
identifier

Grammar of a try expression

try-operator →
@samp{try} | @samp{try} @samp{?} | @samp{try} @samp{!}

Grammar of a binary expression

binary-expression
→
binary-operator
prefix-expression

binary-expression
→
assignment-operator
try-operator
_@{opt@}
prefix-expression

binary-expression
→
conditional-operator
try-operator
_@{opt@}
prefix-expression

binary-expression
→
type-casting-operator

binary-expressions
→
binary-expression
binary-expressions
_@{opt@}

Grammar of an assignment operator

assignment-operator
→ @samp{=}

Grammar of a conditional operator

conditional-operator
→ @samp{?}
expression
@samp{:}

Grammar of a type-casting operator

type-casting-operator
→ @samp{is} type

type-casting-operator
→ @samp{as} type

type-casting-operator
→ @samp{as} @samp{?} type

type-casting-operator
→ @samp{as} @samp{!} type

Grammar of a primary expression

primary-expression
→
identifier
generic-argument-clause
_@{opt@}

primary-expression
→
literal-expression

primary-expression
→
self-expression

primary-expression
→
superclass-expression

primary-expression
→
closure-expression

primary-expression
→
parenthesized-expression

primary-expression
→
tuple-expression

primary-expression
→
implicit-member-expression

primary-expression
→
wildcard-expression

primary-expression
→
key-path-expression

primary-expression
→
selector-expression

primary-expression
→
key-path-string-expression

Grammar of a literal expression

literal-expression
→ literal

literal-expression
→
array-literal
@multitable {}
@item
@end multitable
dictionary-literal
@multitable {}
@item
@end multitable
playground-literal

literal-expression
→ @samp{#file} | @samp{#line} | @samp{#column} | @samp{#function} | @samp{#dsohandle}

array-literal
→ @samp{[}
array-literal-items
_@{opt@} @samp{]}

array-literal-items
→
array-literal-item
=,=@math{_opt} |
array-literal-item
@samp{,}
array-literal-items

array-literal-item
→
expression

dictionary-literal
→ @samp{[}
dictionary-literal-items
@samp{]} | @samp{[} @samp{:} @samp{]}

dictionary-literal-items
→
dictionary-literal-item
=,=@math{_opt} |
dictionary-literal-item
@samp{,}
dictionary-literal-items

dictionary-literal-item
→
expression
@samp{:}
expression

playground-literal
→ @samp{#colorLiteral} @samp{(} @samp{red} @samp{:}
expression
@samp{,} @samp{green} @samp{:}
expression
@samp{,} @samp{blue} @samp{:}
expression
@samp{,} @samp{alpha} @samp{:}
expression
@samp{)}

playground-literal
→ @samp{#fileLiteral} @samp{(} @samp{resourceName} @samp{:}
expression
@samp{)}

playground-literal
→ @samp{#imageLiteral} @samp{(} @samp{resourceName} @samp{:}
expression
@samp{)}

Grammar of a self expression

self-expression
→ @samp{self} |
self-method-expression
@multitable {}
@item
@end multitable
self-subscript-expression
@multitable {}
@item
@end multitable
self-initializer-expression

self-method-expression
→ @samp{self} @samp{.}
identifier

self-subscript-expression
→ @samp{self} @samp{[}
function-call-argument-list
@samp{]}

self-initializer-expression
→ @samp{self} @samp{.} @samp{init}

Grammar of a superclass expression

superclass-expression
→
superclass-method-expression
@multitable {}
@item
@end multitable
superclass-subscript-expression
@multitable {}
@item
@end multitable
superclass-initializer-expression

superclass-method-expression
→ @samp{super} @samp{.}
identifier

superclass-subscript-expression
→ @samp{super} @samp{[}
function-call-argument-list
@samp{]}

superclass-initializer-expression
→ @samp{super} @samp{.} @samp{init}

Grammar of a closure expression

closure-expression
→ @samp{@{}
closure-signature
_@{opt@}
statements
_@{opt@} @samp{@}}

closure-signature
→
capture-list
_@{opt@}
closure-parameter-clause
=throws=@math{_opt}
function-result
_@{opt@} @samp{in}

closure-signature
→
capture-list
@samp{in}

closure-parameter-clause
→ @samp{(} @samp{)} | @samp{(}
closure-parameter-list
@samp{)} |
identifier-list

closure-parameter-list
→
closure-parameter
@multitable {}
@item
@end multitable
closure-parameter
@samp{,}
closure-parameter-list

closure-parameter
→
closure-parameter-name
type-annotation
_@{opt@}

closure-parameter
→
closure-parameter-name
type-annotation
@samp{...}

closure-parameter-name
→
identifier

capture-list →
@samp{[}
capture-list-items
@samp{]}

capture-list-items
→
capture-list-item
@multitable {}
@item
@end multitable
capture-list-item
@samp{,}
capture-list-items

capture-list-item
→
capture-specifier
_@{opt@}
expression

capture-specifier
→ @samp{weak} | @samp{unowned} | @samp{unowned(safe)} | @samp{unowned(unsafe)}

Grammar of a implicit member expression

implicit-member-expression
→ @samp{.}
identifier

Grammar of a parenthesized expression

parenthesized-expression
→ @samp{(}
expression
@samp{)}

Grammar of a tuple expression

tuple-expression
→ @samp{(} @samp{)} | @samp{(}
tuple-element
@samp{,}
tuple-element-list
@samp{)}

tuple-element-list
→
tuple-element
@multitable {}
@item
@end multitable
tuple-element
@samp{,}
tuple-element-list

tuple-element
→
expression
@multitable {}
@item
@end multitable
identifier
@samp{:}
expression

Grammar of a wildcard expression

wildcard-expression
→ @samp{_}

Grammar of a key-path expression

key-path-expression
→ @samp{\} type _@{opt@} @samp{.}
key-path-components

key-path-components
→
key-path-component
@multitable {}
@item
@end multitable
key-path-component
@samp{.}
key-path-components

key-path-component
→
identifier
key-path-postfixes
_@{opt@} |
key-path-postfixes

key-path-postfixes
→
key-path-postfix
key-path-postfixes
_@{opt@}

key-path-postfix
→ @samp{?} | @samp{!} | @samp{self} | @samp{[}
function-call-argument-list
@samp{]}

Grammar of a selector expression

selector-expression
→ @samp{#selector} @samp{(}
expression
@samp{)}

selector-expression
→ @samp{#selector} @samp{(} @samp{getter:}
expression
@samp{)}

selector-expression
→ @samp{#selector} @samp{(} @samp{setter:}
expression
@samp{)}

Grammar of a key-path string expression

key-path-string-expression
→ @samp{#keyPath} @samp{(}
expression
@samp{)}

Grammar of a postfix expression

postfix-expression
→
primary-expression

postfix-expression
→
postfix-expression
postfix-operator

postfix-expression
→
function-call-expression

postfix-expression
→
initializer-expression

postfix-expression
→
explicit-member-expression

postfix-expression
→
postfix-self-expression

postfix-expression
→
subscript-expression

postfix-expression
→
forced-value-expression

postfix-expression
→
optional-chaining-expression

Grammar of a function call expression

function-call-expression
→
postfix-expression
function-call-argument-clause

function-call-expression
→
postfix-expression
function-call-argument-clause
_@{opt@}
trailing-closure

function-call-argument-clause
→ @samp{(} @samp{)} | @samp{(}
function-call-argument-list
@samp{)}

function-call-argument-list
→
function-call-argument
@multitable {}
@item
@end multitable
function-call-argument
@samp{,}
function-call-argument-list

function-call-argument
→
expression
@multitable {}
@item
@end multitable
identifier
@samp{:}
expression

function-call-argument
→
operator
@multitable {}
@item
@end multitable
identifier
@samp{:}
operator

trailing-closure
→
closure-expression

Grammar of an initializer expression

initializer-expression
→
postfix-expression
@samp{.} @samp{init}

initializer-expression
→
postfix-expression
@samp{.} @samp{init} @samp{(}
argument-names
@samp{)}

Grammar of an explicit member expression

explicit-member-expression
→
postfix-expression
@samp{.}
decimal-digits

explicit-member-expression
→
postfix-expression
@samp{.}
identifier
generic-argument-clause
_@{opt@}

explicit-member-expression
→
postfix-expression
@samp{.}
identifier
@samp{(}
argument-names
@samp{)}

argument-names
→
argument-name
argument-names
_@{opt@}

argument-name
→
identifier
@samp{:}

Grammar of a postfix self expression

postfix-self-expression
→
postfix-expression
@samp{.} @samp{self}

Grammar of a subscript expression

subscript-expression
→
postfix-expression
@samp{[}
function-call-argument-list
@samp{]}

Grammar of a forced-value expression

forced-value-expression
→
postfix-expression
@samp{!}

Grammar of an optional-chaining expression

optional-chaining-expression
→
postfix-expression
@samp{?}

@node Statements 1
@section Statements

Grammar of a statement

statement →
expression
=;=@math{_opt}

statement →
declaration
=;=@math{_opt}

statement →
loop-statement
=;=@math{_opt}

statement →
branch-statement
=;=@math{_opt}

statement →
labeled-statement
=;=@math{_opt}

statement →
control-transfer-statement
=;=@math{_opt}

statement →
defer-statement
=;=@math{_opt}

statement →
do-statement
=;=@math{_opt}

statement →
compiler-control-statement

statements →
statement
statements
_@{opt@}

Grammar of a loop statement

loop-statement
→
for-in-statement

loop-statement
→
while-statement

loop-statement
→
repeat-while-statement

Grammar of a for-in statement

for-in-statement
→ @samp{for} @samp{case=_@{opt@}
pattern =in}
expression
where-clause
_@{opt@}
code-block

Grammar of a while statement

while-statement
→ @samp{while}
condition-list
code-block

condition-list
→ condition |
condition @samp{,}
condition-list

condition →
expression
@multitable {}
@item
@end multitable
availability-condition
@multitable {}
@item
@end multitable
case-condition
@multitable {}
@item
@end multitable
optional-binding-condition

case-condition
→ @samp{case} pattern
initializer

optional-binding-condition
→ @samp{let} pattern
initializer
@multitable {aaaaaaaaaaaaa}
@item @samp{var} pattern
@end multitable
initializer

Grammar of a repeat-while statement

repeat-while-statement
→ @samp{repeat}
code-block
@samp{while}
expression

Grammar of a branch statement

branch-statement
→
if-statement

branch-statement
→
guard-statement

branch-statement
→
switch-statement

Grammar of an if statement

if-statement →
@samp{if}
condition-list
code-block
else-clause
_@{opt@}

else-clause →
@samp{else}
code-block
@multitable {aaaaaa}
@item @samp{else}
@end multitable
if-statement

Grammar of a guard statement

guard-statement
→ @samp{guard}
condition-list
@samp{else}
code-block

Grammar of a switch statement

switch-statement
→ @samp{switch}
expression
@samp{@{}
switch-cases
_@{opt@} @samp{@}}

switch-cases →
switch-case
switch-cases
_@{opt@}

switch-case →
case-label
statements

switch-case →
default-label
statements

switch-case →
conditional-switch-case

case-label →
attributes
_@{opt@} @samp{case}
case-item-list
@samp{:}

case-item-list
→ pattern
where-clause
_@{opt@} | pattern
where-clause
_@{opt@} @samp{,}
case-item-list

default-label
→ attributes
_@{opt@} @samp{default} @samp{:}

where-clause →
@samp{where}
where-expression

where-expression
→
expression

conditional-switch-case
→
switch-if-directive-clause
switch-elseif-directive-clauses
_@{opt@}
switch-else-directive-clause
_@{opt@}
endif-directive

switch-if-directive-clause
→
if-directive
compilation-condition
switch-cases
_@{opt@}

switch-elseif-directive-clauses
→
elseif-directive-clause
switch-elseif-directive-clauses
_@{opt@}

switch-elseif-directive-clause
→
elseif-directive
compilation-condition
switch-cases
_@{opt@}

switch-else-directive-clause
→
else-directive
switch-cases
_@{opt@}

Grammar of a labeled statement

labeled-statement
→
statement-label
loop-statement

labeled-statement
→
statement-label
if-statement

labeled-statement
→
statement-label
switch-statement

labeled-statement
→
statement-label
do-statement

statement-label
→ label-name
@samp{:}

label-name →
identifier

Grammar of a control transfer statement

control-transfer-statement
→
break-statement

control-transfer-statement
→
continue-statement

control-transfer-statement
→
fallthrough-statement

control-transfer-statement
→
return-statement

control-transfer-statement
→
throw-statement

Grammar of a break statement

break-statement
→ @samp{break}
label-name
_@{opt@}

Grammar of a continue statement

continue-statement
→ @samp{continue}
label-name
_@{opt@}

Grammar of a fallthrough statement

fallthrough-statement
→ @samp{fallthrough}

Grammar of a return statement

return-statement
→ @samp{return}
expression
_@{opt@}

Grammar of a throw statement

throw-statement
→ @samp{throw}
expression

Grammar of a defer statement

defer-statement
→ @samp{defer}
code-block

Grammar of a do statement

do-statement →
@samp{do}
code-block
catch-clauses
_@{opt@}

catch-clauses
→
catch-clause
catch-clauses
_@{opt@}

catch-clause →
@samp{catch} pattern
_@{opt@}
where-clause
_@{opt@}
code-block

Grammar of a compiler control statement

compiler-control-statement
→
conditional-compilation-block

compiler-control-statement
→
line-control-statement

compiler-control-statement
→
diagnostic-statement

Grammar of a conditional compilation block

conditional-compilation-block
→
if-directive-clause
elseif-directive-clauses
_@{opt@}
else-directive-clause
_@{opt@}
endif-directive

if-directive-clause
→
if-directive
compilation-condition
statements
_@{opt@}

elseif-directive-clauses
→
elseif-directive-clause
elseif-directive-clauses
_@{opt@}

elseif-directive-clause
→
elseif-directive
compilation-condition
statements
_@{opt@}

else-directive-clause
→
else-directive
statements
_@{opt@}

if-directive →
@samp{#if}

elseif-directive
→ @samp{#elseif}

else-directive
→ @samp{#else}

endif-directive
→ @samp{#endif}

compilation-condition
→
platform-condition

compilation-condition
→
identifier

compilation-condition
→
boolean-literal

compilation-condition
→ @samp{(}
compilation-condition
@samp{)}

compilation-condition
→ @samp{!}
compilation-condition

compilation-condition
→
compilation-condition
@samp{&&}
compilation-condition

compilation-condition
→
compilation-condition
@samp{||}
compilation-condition

platform-condition
→ @samp{os} @samp{(}
operating-system
@samp{)}

platform-condition
→ @samp{arch} @samp{(}
architecture
@samp{)}

platform-condition
→ @samp{swift} @samp{(} @samp{>=}
swift-version
@samp{)} | @samp{swift} @samp{(} @samp{<}
swift-version
@samp{)}

platform-condition
→ @samp{compiler} @samp{(} @samp{>=}
swift-version
@samp{)} | @samp{compiler} @samp{(} @samp{<}
swift-version
@samp{)}

platform-condition
→ @samp{canImport} @samp{(}
module-name
@samp{)}

platform-condition
→ @samp{targetEnvironment} @samp{(}
environment
@samp{)}

operating-system
→ @samp{macOS} | @samp{iOS} | @samp{watchOS} | @samp{tvOS}

architecture →
@samp{i386} | @samp{x86_64} | @samp{arm} | @samp{arm64}

swift-version
→
decimal-digits
swift-version-continuation
_@{opt@}

swift-version-continuation
→ @samp{.}
decimal-digits
swift-version-continuation
_@{opt@}

module-name →
identifier

environment →
@samp{simulator}

Grammar of a line control statement

line-control-statement
→ @samp{#sourceLocation} @samp{(} @samp{file:}
file-name @samp{,}
@samp{line:}
line-number
@samp{)}

line-control-statement
→ @samp{#sourceLocation} @samp{(} @samp{)}

line-number → A
decimal integer greater than zero

file-name →
static-string-literal

Grammar of a compile-time diagnostic statement

diagnostic-statement
→ @samp{#error} @samp{(}
diagnostic-message
@samp{)}

diagnostic-statement
→ @samp{#warning} @samp{(}
diagnostic-message
@samp{)}

diagnostic-message
→
static-string-literal

Grammar of an availability condition

availability-condition
→ @samp{#available} @samp{(}
availability-arguments
@samp{)}

availability-arguments
→
availability-argument
@multitable {}
@item
@end multitable
availability-argument
@samp{,}
availability-arguments

availability-argument
→
platform-name
platform-version

availability-argument
→ @samp{*}

platform-name
→ @samp{iOS} | @samp{iOSApplicationExtension}

platform-name
→ @samp{macOS} | @samp{macOSApplicationExtension}

platform-name
→ @samp{watchOS}

platform-name
→ @samp{tvOS}

platform-version
→
decimal-digits

platform-version
→
decimal-digits
@samp{.}
decimal-digits

platform-version
→
decimal-digits
@samp{.}
decimal-digits
@samp{.}
decimal-digits

@node Declarations 1
@section Declarations

Grammar of a declaration

declaration →
import-declaration

declaration →
constant-declaration

declaration →
variable-declaration

declaration →
typealias-declaration

declaration →
function-declaration

declaration →
enum-declaration

declaration →
struct-declaration

declaration →
class-declaration

declaration →
protocol-declaration

declaration →
initializer-declaration

declaration →
deinitializer-declaration

declaration →
extension-declaration

declaration →
subscript-declaration

declaration →
operator-declaration

declaration →
precedence-group-declaration

declarations →
declaration
declarations
_@{opt@}

Grammar of a top-level declaration

top-level-declaration
→ statements
_@{opt@}

Grammar of a code block

code-block → @samp{@{}
statements
_@{opt@} @samp{@}}

Grammar of an import declaration

import-declaration
→ attributes
_@{opt@} @samp{import}
import-kind
_@{opt@}
import-path

import-kind →
@samp{typealias} | @samp{struct} | @samp{class} | @samp{enum} | @samp{protocol} | @samp{let} | @samp{var} |
@samp{func}

import-path →
import-path-identifier
@multitable {}
@item
@end multitable
import-path-identifier
@samp{.}
import-path

import-path-identifier
→
identifier
@multitable {}
@item
@end multitable
operator

Grammar of a constant declaration

constant-declaration
→ attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{let}
pattern-initializer-list

pattern-initializer-list
→
pattern-initializer
@multitable {}
@item
@end multitable
pattern-initializer
@samp{,}
pattern-initializer-list

pattern-initializer
→ pattern
initializer
_@{opt@}

initializer →
@samp{=}
expression

Grammar of a variable declaration

variable-declaration
→
variable-declaration-head
pattern-initializer-list

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
code-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-keyword-block

variable-declaration
→
variable-declaration-head
variable-name
initializer
willSet-didSet-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
initializer
_@{opt@}
willSet-didSet-block

variable-declaration-head
→ attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{var}

variable-name
→
identifier

getter-setter-block
→
code-block

getter-setter-block
→ @samp{@{}
getter-clause
setter-clause
_@{opt@} @samp{@}}

getter-setter-block
→ @samp{@{}
setter-clause
getter-clause
@samp{@}}

getter-clause
→ attributes
_@{opt@}
mutation-modifier
_@{opt@} @samp{get}
code-block

setter-clause
→ attributes
_@{opt@}
mutation-modifier
_@{opt@} @samp{set}
setter-name
_@{opt@}
code-block

setter-name →
@samp{(}
identifier
@samp{)}

getter-setter-keyword-block
→ @samp{@{}
getter-keyword-clause
setter-keyword-clause
_@{opt@} @samp{@}}

getter-setter-keyword-block
→ @samp{@{}
setter-keyword-clause
getter-keyword-clause
@samp{@}}

getter-keyword-clause
→ attributes
_@{opt@}
mutation-modifier
_@{opt@} @samp{get}

setter-keyword-clause
→ attributes
_@{opt@}
mutation-modifier
_@{opt@} @samp{set}

willSet-didSet-block
→ @samp{@{}
willSet-clause
didSet-clause
_@{opt@} @samp{@}}

willSet-didSet-block
→ @samp{@{}
didSet-clause
willSet-clause
_@{opt@} @samp{@}}

willSet-clause
→ attributes
_@{opt@} @samp{willSet}
setter-name
_@{opt@}
code-block

didSet-clause
→ attributes
_@{opt@} @samp{didSet}
setter-name
_@{opt@}
code-block

Grammar of a type alias declaration

typealias-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{typealias}
typealias-name
generic-parameter-clause
_@{opt@}
typealias-assignment

typealias-name
→
identifier

typealias-assignment
→ @samp{=} type

Grammar of a function declaration

function-declaration
→
function-head
function-name
generic-parameter-clause
_@{opt@}
function-signature
generic-where-clause
_@{opt@}
function-body
_@{opt@}

function-head
→ attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{func}

function-name
→
identifier
@multitable {}
@item
@end multitable
operator

function-signature
→
parameter-clause
=throws=@math{_opt}
function-result
_@{opt@}

function-signature
→
parameter-clause
@samp{rethrows}
function-result
_@{opt@}

function-result
→ @samp{->}
attributes
_@{opt@} type

function-body
→
code-block

parameter-clause
→ @samp{(} @samp{)} | @samp{(}
parameter-list
@samp{)}

parameter-list
→ parameter
@multitable {aaaaaaaaa}
@item parameter
@end multitable
@samp{,}
parameter-list

parameter →
external-parameter-name
_@{opt@}
local-parameter-name
type-annotation
default-argument-clause
_@{opt@}

parameter →
external-parameter-name
_@{opt@}
local-parameter-name
type-annotation

parameter →
external-parameter-name
_@{opt@}
local-parameter-name
type-annotation
@samp{...}

external-parameter-name
→
identifier

local-parameter-name
→
identifier

default-argument-clause
→ @samp{=}
expression

Grammar of an enumeration declaration

enum-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@}
union-style-enum

enum-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@}
raw-value-style-enum

union-style-enum
→ @samp{indirect=_@{opt@} =enum}
enum-name
generic-parameter-clause
_@{opt@}
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@} @samp{@{}
union-style-enum-members
_@{opt@} @samp{@}}

union-style-enum-members
→
union-style-enum-member
union-style-enum-members
_@{opt@}

union-style-enum-member
→
declaration
@multitable {}
@item
@end multitable
union-style-enum-case-clause
@multitable {}
@item
@end multitable
compiler-control-statement

union-style-enum-case-clause
→ attributes
_@{opt@} @samp{indirect=_@{opt@} =case}
union-style-enum-case-list

union-style-enum-case-list
→
union-style-enum-case
@multitable {}
@item
@end multitable
union-style-enum-case
@samp{,}
union-style-enum-case-list

union-style-enum-case
→
enum-case-name
tuple-type _@{opt@}

enum-name →
identifier

enum-case-name
→
identifier

raw-value-style-enum
→ @samp{enum}
enum-name
generic-parameter-clause
_@{opt@}
type-inheritance-clause
generic-where-clause
_@{opt@} @samp{@{}
raw-value-style-enum-members
@samp{@}}

raw-value-style-enum-members
→
raw-value-style-enum-member
raw-value-style-enum-members
_@{opt@}

raw-value-style-enum-member
→
declaration
@multitable {}
@item
@end multitable
raw-value-style-enum-case-clause
@multitable {}
@item
@end multitable
compiler-control-statement

raw-value-style-enum-case-clause
→ attributes
_@{opt@} @samp{case}
raw-value-style-enum-case-list

raw-value-style-enum-case-list
→
raw-value-style-enum-case
@multitable {}
@item
@end multitable
raw-value-style-enum-case
@samp{,}
raw-value-style-enum-case-list

raw-value-style-enum-case
→
enum-case-name
raw-value-assignment
_@{opt@}

raw-value-assignment
→ @samp{=}
raw-value-literal

raw-value-literal
→
numeric-literal
@multitable {}
@item
@end multitable
static-string-literal
@multitable {}
@item
@end multitable
boolean-literal

Grammar of a structure declaration

struct-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{struct}
struct-name
generic-parameter-clause
_@{opt@}
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@}
struct-body

struct-name →
identifier

struct-body →
@samp{@{}
struct-members
_@{opt@} @samp{@}}

struct-members
→
struct-member
struct-members
_@{opt@}

struct-member
→
declaration
@multitable {}
@item
@end multitable
compiler-control-statement

Grammar of a class declaration

class-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{final=_@{opt@} =class}
class-name
generic-parameter-clause
_@{opt@}
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@}
class-body

class-declaration
→ attributes
_@{opt@} @samp{final}
access-level-modifier
_@{opt@} @samp{class}
class-name
generic-parameter-clause
_@{opt@}
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@}
class-body

class-name →
identifier

class-body → @samp{@{}
class-members
_@{opt@} @samp{@}}

class-members
→
class-member
class-members
_@{opt@}

class-member →
declaration
@multitable {}
@item
@end multitable
compiler-control-statement

Grammar of a protocol declaration

protocol-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{protocol}
protocol-name
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@}
protocol-body

protocol-name
→
identifier

protocol-body
→ @samp{@{}
protocol-members
_@{opt@} @samp{@}}

protocol-members
→
protocol-member
protocol-members
_@{opt@}

protocol-member
→
protocol-member-declaration
@multitable {}
@item
@end multitable
compiler-control-statement

protocol-member-declaration
→
protocol-property-declaration

protocol-member-declaration
→
protocol-method-declaration

protocol-member-declaration
→
protocol-initializer-declaration

protocol-member-declaration
→
protocol-subscript-declaration

protocol-member-declaration
→
protocol-associated-type-declaration

protocol-member-declaration
→
typealias-declaration

Grammar of a protocol property declaration

protocol-property-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-keyword-block

Grammar of a protocol method declaration

protocol-method-declaration
→
function-head
function-name
generic-parameter-clause
_@{opt@}
function-signature
generic-where-clause
_@{opt@}

Grammar of a protocol initializer declaration

protocol-initializer-declaration
→
initializer-head
generic-parameter-clause
_@{opt@}
parameter-clause
=throws=@math{_opt}
generic-where-clause
_@{opt@}

protocol-initializer-declaration
→
initializer-head
generic-parameter-clause
_@{opt@}
parameter-clause
@samp{rethrows}
generic-where-clause
_@{opt@}

Grammar of a protocol subscript declaration

protocol-subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_@{opt@}
getter-setter-keyword-block

Grammar of a protocol associated type declaration

protocol-associated-type-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{associatedtype}
typealias-name
type-inheritance-clause
_@{opt@}
typealias-assignment
_@{opt@}
generic-where-clause
_@{opt@}

Grammar of an initializer declaration

initializer-declaration
→
initializer-head
generic-parameter-clause
_@{opt@}
parameter-clause
=throws=@math{_opt}
generic-where-clause
_@{opt@}
initializer-body

initializer-declaration
→
initializer-head
generic-parameter-clause
_@{opt@}
parameter-clause
@samp{rethrows}
generic-where-clause
_@{opt@}
initializer-body

initializer-head
→ attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{init}

initializer-head
→ attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{init} @samp{?}

initializer-head
→ attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{init} @samp{!}

initializer-body
→
code-block

Grammar of a deinitializer declaration

deinitializer-declaration
→ attributes
_@{opt@} @samp{deinit}
code-block

Grammar of an extension declaration

extension-declaration
→ attributes
_@{opt@}
access-level-modifier
_@{opt@} @samp{extension}
type-identifier
type-inheritance-clause
_@{opt@}
generic-where-clause
_@{opt@}
extension-body

extension-body
→ @samp{@{}
extension-members
_@{opt@} @samp{@}}

extension-members
→
extension-member
extension-members
_@{opt@}

extension-member
→
declaration
@multitable {}
@item
@end multitable
compiler-control-statement

Grammar of a subscript declaration

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_@{opt@}
code-block

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_@{opt@}
getter-setter-block

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_@{opt@}
getter-setter-keyword-block

subscript-head
→ attributes
_@{opt@}
declaration-modifiers
_@{opt@} @samp{subscript}
generic-parameter-clause
_@{opt@}
parameter-clause

subscript-result
→ @samp{->}
attributes
_@{opt@} type

Grammar of an operator declaration

operator-declaration
→
prefix-operator-declaration
@multitable {}
@item
@end multitable
postfix-operator-declaration
@multitable {}
@item
@end multitable
infix-operator-declaration

prefix-operator-declaration
→ @samp{prefix} @samp{operator}
operator

postfix-operator-declaration
→ @samp{postfix} @samp{operator}
operator

infix-operator-declaration
→ @samp{infix} @samp{operator}
operator
infix-operator-group
_@{opt@}

infix-operator-group
→ @samp{:}
precedence-group-name

Grammar of a precedence group declaration

precedence-group-declaration
→ @samp{precedencegroup}
precedence-group-name
@samp{@{}
precedence-group-attributes
_@{opt@} @samp{@}}

precedence-group-attributes
→
precedence-group-attribute
precedence-group-attributes
_@{opt@}

precedence-group-attribute
→
precedence-group-relation

precedence-group-attribute
→
precedence-group-assignment

precedence-group-attribute
→
precedence-group-associativity

precedence-group-relation
→ @samp{higherThan} @samp{:}
precedence-group-names

precedence-group-relation
→ @samp{lowerThan} @samp{:}
precedence-group-names

precedence-group-assignment
→ @samp{assignment} @samp{:}
boolean-literal

precedence-group-associativity
→ @samp{associativity} @samp{:} @samp{left}

precedence-group-associativity
→ @samp{associativity} @samp{:} @samp{right}

precedence-group-associativity
→ @samp{associativity} @samp{:} @samp{none}

precedence-group-names
→
precedence-group-name
@multitable {}
@item
@end multitable
precedence-group-name
@samp{,}
precedence-group-names

precedence-group-name
→
identifier

Grammar of a declaration modifier

declaration-modifier
→ @samp{class} | @samp{convenience} | @samp{dynamic} | @samp{final} | @samp{infix} | @samp{lazy} |
@samp{optional} | @samp{override} | @samp{postfix} | @samp{prefix} | @samp{required} | @samp{static} |
@samp{unowned} | @samp{unowned} @samp{(} @samp{safe} @samp{)} | @samp{unowned} @samp{(} @samp{unsafe} @samp{)} |
@samp{weak}

declaration-modifier
→
access-level-modifier

declaration-modifier
→
mutation-modifier

declaration-modifiers
→
declaration-modifier
declaration-modifiers
_@{opt@}

access-level-modifier
→ @samp{private} | @samp{private} @samp{(} @samp{set} @samp{)}

access-level-modifier
→ @samp{fileprivate} | @samp{fileprivate} @samp{(} @samp{set} @samp{)}

access-level-modifier
→ @samp{internal} | @samp{internal} @samp{(} @samp{set} @samp{)}

access-level-modifier
→ @samp{public} | @samp{public} @samp{(} @samp{set} @samp{)}

access-level-modifier
→ @samp{open} | @samp{open} @samp{(} @samp{set} @samp{)}

mutation-modifier
→ @samp{mutating} | @samp{nonmutating}

@node Attributes 1
@section Attributes

Grammar of an attribute

attribute → @samp{@@}
attribute-name
attribute-argument-clause
_@{opt@}

attribute-name
→
identifier

attribute-argument-clause
→ @samp{(}
balanced-tokens
_@{opt@} @samp{)}

attributes →
attribute
attributes
_@{opt@}

balanced-tokens
→
balanced-token
balanced-tokens
_@{opt@}

balanced-token
→ @samp{(}
balanced-tokens
_@{opt@} @samp{)}

balanced-token
→ @samp{[}
balanced-tokens
_@{opt@} @samp{]}

balanced-token
→ @samp{@{}
balanced-tokens
_@{opt@} @samp{@}}

balanced-token
→ Any identifier, keyword, literal, or operator

balanced-token
→ Any punctuation except @samp{(}, @samp{)}, @samp{[}, @samp{]}, @samp{@{}, or @samp{@}}

@node Patterns 1
@section Patterns

Grammar of a pattern

pattern →
wildcard-pattern
type-annotation
_@{opt@}

pattern →
identifier-pattern
type-annotation
_@{opt@}

pattern →
value-binding-pattern

pattern →
tuple-pattern
type-annotation
_@{opt@}

pattern →
enum-case-pattern

pattern →
optional-pattern

pattern →
type-casting-pattern

pattern →
expression-pattern

Grammar of a wildcard pattern

wildcard-pattern
→ @samp{_}

Grammar of an identifier pattern

identifier-pattern
→
identifier

Grammar of a value-binding pattern

value-binding-pattern
→ @samp{var} pattern |
@samp{let} pattern

Grammar of a tuple pattern

tuple-pattern
→ @samp{(}
tuple-pattern-element-list
_@{opt@} @samp{)}

tuple-pattern-element-list
→
tuple-pattern-element
@multitable {}
@item
@end multitable
tuple-pattern-element
@samp{,}
tuple-pattern-element-list

tuple-pattern-element
→ pattern |
identifier
@samp{:} pattern

Grammar of an enumeration case pattern

enum-case-pattern
→
type-identifier
_@{opt@} @samp{.}
enum-case-name
tuple-pattern
_@{opt@}

Grammar of an optional pattern

optional-pattern
→
identifier-pattern
@samp{?}

Grammar of a type casting pattern

type-casting-pattern
→ is-pattern |
as-pattern

is-pattern → @samp{is}
type

as-pattern →
pattern @samp{as}
type

Grammar of an expression pattern

expression-pattern
→
expression

@node Generic Parameters and Arguments 1
@section Generic Parameters and Arguments

Grammar of a generic parameter clause

generic-parameter-clause
→ @samp{<}
generic-parameter-list
@samp{>}

generic-parameter-list
→
generic-parameter
@multitable {}
@item
@end multitable
generic-parameter
@samp{,}
generic-parameter-list

generic-parameter
→ type-name

generic-parameter
→ type-name @samp{:}
type-identifier

generic-parameter
→ type-name @samp{:}
protocol-composition-type

generic-where-clause
→ @samp{where}
requirement-list

requirement-list
→
requirement
@multitable {}
@item
@end multitable
requirement
@samp{,}
requirement-list

requirement →
conformance-requirement
@multitable {}
@item
@end multitable
same-type-requirement

conformance-requirement
→
type-identifier
@samp{:}
type-identifier

conformance-requirement
→
type-identifier
@samp{:}
protocol-composition-type

same-type-requirement
→
type-identifier
@samp{==} type

Grammar of a generic argument clause

generic-argument-clause
→ @samp{<}
generic-argument-list
@samp{>}

generic-argument-list
→
generic-argument
@multitable {}
@item
@end multitable
generic-argument
@samp{,}
generic-argument-list

generic-argument
→ type

@node Index
@unnumbered Index

@printindex cp

@bye