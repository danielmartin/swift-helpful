This is swift-reference.info, produced by makeinfo version 6.7 from
swift-reference.texi.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Swift Reference: (swift-reference). The Swift programming language reference.
END-INFO-DIR-ENTRY


File: swift-reference.info,  Node: Top,  Next: Language Reference,  Up: (dir)

The Swift Programming Reference (Swift 5.2)
*******************************************

* Menu:

* Language Reference::
* About the Language Reference::
* Lexical Structure::
* Types::
* Expressions::
* Statements::
* Declarations::
* Attributes::
* Patterns::
* Generic Parameters and Arguments::
* Summary of the Grammar::
* Index::

— The Detailed Node Listing —

About the Language Reference

* How to Read the Grammar::

Lexical Structure

* Whitespace and Comments::
* Identifiers::
* Keywords and Punctuation::
* Literals::
* Operators::

Literals

* Integer Literals::
* Floating-Point Literals::
* String Literals::

Types

* Type Annotation::
* Type Identifier::
* Tuple Type::
* Function Type::
* Array Type::
* Dictionary Type::
* Optional Type::
* Implicitly Unwrapped Optional Type::
* Protocol Composition Type::
* Opaque Type::
* Metatype Type::
* Self Type::
* Type Inheritance Clause::
* Type Inference::

Function Type

* Restrictions for Nonescaping Closures::

Expressions

* Prefix Expressions::
* Binary Expressions::
* Primary Expressions::
* Postfix Expressions::

Prefix Expressions

* Try Operator::

Binary Expressions

* Assignment Operator::
* Type-Casting Operators::

Primary Expressions

* Literal Expression::
* Self Expression::
* Superclass Expression::
* Closure Expression::
* Implicit Member Expression::
* Parenthesized Expression::
* Tuple Expression::
* Wildcard Expression::
* Key-Path Expression::
* Selector Expression::
* Key-Path String Expression::

Postfix Expressions

* Function Call Expression::
* Initializer Expression::
* Explicit Member Expression::
* Postfix Self Expression::
* Subscript Expression::
* Forced-Value Expression::
* Optional-Chaining Expression::

Statements

* Loop Statements::
* Labeled Statement::
* Control Transfer Statements::
* Defer Statement::
* Do Statement::
* Compiler Control Statements::
* Availability Condition::

Loop Statements

* For-In Statement::
* While Statement::
* Repeat-While Statement::
* Branch Statements::
* If Statement::
* Guard Statement::

Control Transfer Statements

* Break Statement::
* Continue Statement::
* Fallthrough Statement::
* Return Statement::
* Throw Statement::

Compiler Control Statements

* Conditional Compilation Block::
* Line Control Statement::
* Compile-Time Diagnostic Statement::

Declarations

* Top-Level Code::
* Code Blocks::
* Import Declaration::
* Constant Declaration::
* Variable Declaration::
* Type Alias Declaration::
* Function Declaration::
* Enumeration Declaration::
* Structure Declaration::
* Class Declaration::
* Protocol Declaration::
* Initializer Declaration::
* Deinitializer Declaration::
* Extension Declaration::
* Subscript Declaration::
* Operator Declaration::
* Precedence Group Declaration::
* Declaration Modifiers::

Variable Declaration

* Stored Variables and Stored Variable Properties::
* Computed Variables and Computed Properties::
* Stored Variable Observers and Property Observers::
* Type Variable Properties::

Function Declaration

* Parameter Names::
* In-Out Parameters::
* Special Kinds of Parameters::
* Special Kinds of Methods::
* Methods with Special Names::
* Throwing Functions and Methods::
* Rethrowing Functions and Methods::
* Functions that Never Return::

Enumeration Declaration

* Enumerations with Cases of Any Type::
* Enumerations with Cases of a Raw-Value Type::
* Accessing Enumeration Cases::

Protocol Declaration

* Protocol Property Declaration::
* Protocol Method Declaration::
* Protocol Initializer Declaration::
* Protocol Subscript Declaration::
* Protocol Associated Type Declaration::

Initializer Declaration

* Failable Initializers::

Extension Declaration

* Conditional Conformance::
* Protocol Conformance Must Not Be Redundant::

Declaration Modifiers

* Access Control Levels::

Attributes

* Declaration Attributes::
* Type Attributes::
* Switch Case Attributes::

Declaration Attributes

* available::
* discardableResult::
* dynamicCallable::
* dynamicMemberLookup::
* frozen::
* GKInspectable::
* inlinable::
* nonobjc::
* NSApplicationMain::
* NSCopying::
* NSManaged::
* objc::
* objcMembers::
* propertyWrapper::
* requires_stored_property_inits::
* testable::
* UIApplicationMain::
* usableFromInline::
* warn_unqualified_access::
* Declaration Attributes Used by Interface Builder::

Type Attributes

* autoclosure::
* convention::
* escaping::

Switch Case Attributes

* unknown::

Patterns

* Wildcard Pattern::
* Identifier Pattern::
* Value-Binding Pattern::
* Tuple Pattern::
* Enumeration Case Pattern::
* Optional Pattern::
* Type-Casting Patterns::
* Expression Pattern::

Generic Parameters and Arguments

* Generic Parameter Clause::
* Generic Argument Clause::

Generic Parameter Clause

* Generic Where Clauses::

Summary of the Grammar

* Lexical Structure: Lexical Structure 1.
* Types: Types 1.
* Expressions: Expressions 1.
* Statements: Statements 1.
* Declarations: Declarations 1.
* Attributes: Attributes 1.
* Patterns: Patterns 1.
* Generic Parameters and Arguments: Generic Parameters and Arguments 1.



File: swift-reference.info,  Node: Language Reference,  Next: About the Language Reference,  Prev: Top,  Up: Top

1 Language Reference
********************

   • *note About the Language Reference::
   • *note Lexical Structure::
   • *note Types::
   • *note Expressions::
   • *note Statements::
   • *note Declarations::
   • *note Attributes::
   • *note Patterns::
   • *note Generic Parameters and Arguments: Generic Parameters and
     Arguments.
   • *note Summary of the Grammar::


File: swift-reference.info,  Node: About the Language Reference,  Next: Lexical Structure,  Prev: Language Reference,  Up: Top

2 About the Language Reference
******************************

This part of the book describes the formal grammar of the Swift
programming language.  The grammar described here is intended to help
you understand the language in more detail, rather than to allow you to
directly implement a parser or compiler.

   The Swift language is relatively small, because many common types,
functions, and operators that appear virtually everywhere in Swift code
are actually defined in the Swift standard library.  Although these
types, functions, and operators are not part of the Swift language
itself, they are used extensively in the discussions and code examples
in this part of the book.

* Menu:

* How to Read the Grammar::


File: swift-reference.info,  Node: How to Read the Grammar,  Up: About the Language Reference

2.1 How to Read the Grammar
===========================

The notation used to describe the formal grammar of the Swift
programming language follows a few conventions:

   • An arrow (→) is used to mark grammar productions and can be read as
     “can consist of.”

   • Syntactic categories are indicated by _italic_ text and appear on
     both sides of a grammar production rule.

   • Literal words and punctuation are indicated by boldface ‘constant
     width’ text and appear only on the right-hand side of a grammar
     production rule.

   • Alternative grammar productions are separated by vertical bars (|).
     When alternative productions are too long to read easily, they are
     broken into multiple grammar production rules on new lines.

   • In a few cases, regular font text is used to describe the
     right-hand side of a grammar production rule.

   • Optional syntactic categories and literals are marked by a trailing
     subscript, _opt_.

   As an example, the grammar of a getter-setter block is defined as
follows:

   Grammar of a getter-setter block

   → ‘{’ getter-clause setter-clause _{opt} ‘}’ | ‘{’ setter-clause
getter-clause ‘}’

   This definition indicates that a getter-setter block can consist of a
getter clause followed by an optional setter clause, enclosed in braces,
_or_ a setter clause followed by a getter clause, enclosed in braces.
The grammar production above is equivalent to the following two
productions, where the alternatives are spelled out explicitly:

   Grammar of a getter-setter block

   getter-setter-block → ‘{’ getter-clause setter-clause _{opt} ‘}’

   getter-setter-block → ‘{’ setter-clause getter-clause ‘}’


File: swift-reference.info,  Node: Lexical Structure,  Next: Types,  Prev: About the Language Reference,  Up: Top

3 Lexical Structure
*******************

The _lexical structure_ of Swift describes what sequence of characters
form valid tokens of the language.  These valid tokens form the
lowest-level building blocks of the language and are used to describe
the rest of the language in subsequent chapters.  A token consists of an
identifier, keyword, punctuation, literal, or operator.

   In most cases, tokens are generated from the characters of a Swift
source file by considering the longest possible substring from the input
text, within the constraints of the grammar that are specified below.
This behavior is referred to as _longest match_ or _maximal munch_.

* Menu:

* Whitespace and Comments::
* Identifiers::
* Keywords and Punctuation::
* Literals::
* Operators::


File: swift-reference.info,  Node: Whitespace and Comments,  Next: Identifiers,  Up: Lexical Structure

3.1 Whitespace and Comments
===========================

Whitespace has two uses: to separate tokens in the source file and to
help determine whether an operator is a prefix or postfix (see *note
Operators::), but is otherwise ignored.  The following characters are
considered whitespace: space (U+0020), line feed (U+000A), carriage
return (U+000D), horizontal tab (U+0009), vertical tab (U+000B), form
feed (U+000C) and null (U+0000).

   Comments are treated as whitespace by the compiler.  Single line
comments begin with ‘//’ and continue until a line feed (U+000A) or
carriage return (U+000D). Multiline comments begin with ‘/*’ and end
with ‘*/’.  Nesting multiline comments is allowed, but the comment
markers must be balanced.

   Comments can contain additional formatting and markup, as described
in Markup Formatting Reference
(https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html)
[<https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html>].

   Grammar of whitespace

   whitespace → whitespace-item whitespace _{opt}

   whitespace-item → line-break

   whitespace-item → comment

   whitespace-item → multiline-comment

   whitespace-item → U+0000, U+0009, U+000B, U+000C, or U+0020

   line-break → U+000A

   line-break → U+000D

   line-break → U+000D followed by U+000A

   comment → ‘//’ comment-text line-break

   multiline-comment → ‘/*’ multiline-comment-text ‘*/’

   comment-text → comment-text-item comment-text _{opt}

   comment-text-item → Any Unicode scalar value except U+000A or U+000D

   multiline-comment-text → multiline-comment-text-item
multiline-comment-text _{opt}

   multiline-comment-text-item → multiline-comment

   multiline-comment-text-item → comment-text-item

   multiline-comment-text-item → Any Unicode scalar value except ‘/*’ or
‘*/’


File: swift-reference.info,  Node: Identifiers,  Next: Keywords and Punctuation,  Prev: Whitespace and Comments,  Up: Lexical Structure

3.2 Identifiers
===============

_Identifiers_ begin with an uppercase or lowercase letter A through Z,
an underscore (‘_’), a noncombining alphanumeric Unicode character in
the Basic Multilingual Plane, or a character outside the Basic
Multilingual Plane that isn’t in a Private Use Area.  After the first
character, digits and combining Unicode characters are also allowed.

   To use a reserved word as an identifier, put a backtick (‘`’) before
and after it.  For example, ‘class’ is not a valid identifier, but
‘`class`’ is valid.  The backticks aren’t considered part of the
identifier; ‘`x`’ and ‘x’ have the same meaning.

   Inside a closure with no explicit parameter names, the parameters are
implicitly named ‘$0’, ‘$1’, ‘$2’, and so on.  These names are valid
identifiers within the scope of the closure.

   The compiler synthesizes identifiers that begin with a dollar sign
($) for properties that have a property wrapper projection.  Your code
can interact with these identifiers, but you can’t declare identifiers
with that prefix.  For more information, see the *note propertyWrapper::
section of the *note Attributes:: chapter.

   Grammar of an identifier

   identifier → identifier-head identifier-characters _{opt}

   identifier → ‘`’ identifier-head identifier-characters _{opt} ‘`’

   identifier → implicit-parameter-name

   identifier → property-wrapper-projection

   identifier-list → identifier
   identifier ‘,’ identifier-list

   identifier-head → Upper- or lowercase letter A through Z

   identifier-head → ‘_’

   identifier-head → U+00A8, U+00AA, U+00AD, U+00AF, U+00B2–U+00B5, or
U+00B7–U+00BA

   identifier-head → U+00BC–U+00BE, U+00C0–U+00D6, U+00D8–U+00F6, or
U+00F8–U+00FF

   identifier-head → U+0100–U+02FF, U+0370–U+167F, U+1681–U+180D, or
U+180F–U+1DBF

   identifier-head → U+1E00–U+1FFF

   identifier-head → U+200B–U+200D, U+202A–U+202E, U+203F–U+2040,
U+2054, or U+2060–U+206F

   identifier-head → U+2070–U+20CF, U+2100–U+218F, U+2460–U+24FF, or
U+2776–U+2793

   identifier-head → U+2C00–U+2DFF or U+2E80–U+2FFF

   identifier-head → U+3004–U+3007, U+3021–U+302F, U+3031–U+303F, or
U+3040–U+D7FF

   identifier-head → U+F900–U+FD3D, U+FD40–U+FDCF, U+FDF0–U+FE1F, or
U+FE30–U+FE44

   identifier-head → U+FE47–U+FFFD

   identifier-head → U+10000–U+1FFFD, U+20000–U+2FFFD, U+30000–U+3FFFD,
or U+40000–U+4FFFD

   identifier-head → U+50000–U+5FFFD, U+60000–U+6FFFD, U+70000–U+7FFFD,
or U+80000–U+8FFFD

   identifier-head → U+90000–U+9FFFD, U+A0000–U+AFFFD, U+B0000–U+BFFFD,
or U+C0000–U+CFFFD

   identifier-head → U+D0000–U+DFFFD or U+E0000–U+EFFFD

   identifier-character → Digit 0 through 9

   identifier-character → U+0300–U+036F, U+1DC0–U+1DFF, U+20D0–U+20FF,
or U+FE20–U+FE2F

   identifier-character → identifier-head

   identifier-characters → identifier-character identifier-characters
_{opt}

   implicit-parameter-name → ‘$’ decimal-digits

   property-wrapper-projection → ‘$’ identifier-characters


File: swift-reference.info,  Node: Keywords and Punctuation,  Next: Literals,  Prev: Identifiers,  Up: Lexical Structure

3.3 Keywords and Punctuation
============================

The following keywords are reserved and can’t be used as identifiers,
unless they’re escaped with backticks, as described above in *note
Identifiers::.  Keywords other than ‘inout’, ‘var’, and ‘let’ can be
used as parameter names in a function declaration or function call
without being escaped with backticks.  When a member has the same name
as a keyword, references to that member don’t need to be escaped with
backticks, except when there’s ambiguity between referring to the member
and using the keyword—for example, ‘self’, ‘Type’, and ‘Protocol’ have
special meaning in an explicit member expression, so they must be
escaped with backticks in that context.

   • Keywords used in declarations: ‘associatedtype’, ‘class’, ‘deinit’,
     ‘enum’, ‘extension’, ‘fileprivate’, ‘func’, ‘import’, ‘init’,
     ‘inout’, ‘internal’, ‘let’, ‘open’, ‘operator’, ‘private’,
     ‘protocol’, ‘public’, ‘rethrows’, ‘static’, ‘struct’, ‘subscript’,
     ‘typealias’, and ‘var’.

   • Keywords used in statements: ‘break’, ‘case’, ‘continue’,
     ‘default’, ‘defer’, ‘do’, ‘else’, ‘fallthrough’, ‘for’, ‘guard’,
     ‘if’, ‘in’, ‘repeat’, ‘return’, ‘switch’, ‘where’, and ‘while’.

   • Keywords used in expressions and types: ‘as’, ‘Any’, ‘catch’,
     ‘false’, ‘is’, ‘nil’, ‘super’, ‘self’, ‘Self’, ‘throw’, ‘throws’,
     ‘true’, and ‘try’.

   • Keywords used in patterns: ‘_’.

   • Keywords that begin with a number sign (‘#’): ‘#available’,
     ‘#colorLiteral’, ‘#column’, ‘#else’, ‘#elseif’, ‘#endif’, ‘#error’,
     ‘#file’, ‘#fileLiteral’, ‘#function’, ‘#if’, ‘#imageLiteral’,
     ‘#line’, ‘#selector’, ‘#sourceLocation’, and ‘#warning’.

   • Keywords reserved in particular contexts: ‘associativity’,
     ‘convenience’, ‘dynamic’, ‘didSet’, ‘final’, ‘get’, ‘infix’,
     ‘indirect’, ‘lazy’, ‘left’, ‘mutating’, ‘none’, ‘nonmutating’,
     ‘optional’, ‘override’, ‘postfix’, ‘precedence’, ‘prefix’,
     ‘Protocol’, ‘required’, ‘right’, ‘set’, ‘Type’, ‘unowned’, ‘weak’,
     and ‘willSet’.  Outside the context in which they appear in the
     grammar, they can be used as identifiers.

   The following tokens are reserved as punctuation and can’t be used as
custom operators: ‘(’, ‘)’, ‘{’, ‘}’, ‘[’, ‘]’, ‘.’, ‘,’, ‘:’, ‘;’, ‘=’,
‘@’, ‘#’, ‘&’ (as a prefix operator), ‘->’, ‘`’, ‘?’, and ‘!’ (as a
postfix operator).


File: swift-reference.info,  Node: Literals,  Next: Operators,  Prev: Keywords and Punctuation,  Up: Lexical Structure

3.4 Literals
============

A _literal_ is the source code representation of a value of a type, such
as a number or string.

   The following are examples of literals:

  1. 42 // Integer literal
  2. 3.14159 // Floating-point literal
  3. "Hello, world!"  // String literal
  4. true // Boolean literal

   A literal doesn’t have a type on its own.  Instead, a literal is
parsed as having infinite precision and Swift’s type inference attempts
to infer a type for the literal.  For example, in the declaration ‘let
x: Int8 = 42’, Swift uses the explicit type annotation (‘: Int8’) to
infer that the type of the integer literal ‘42’ is ‘Int8’.  If there
isn’t suitable type information available, Swift infers that the
literal’s type is one of the default literal types defined in the Swift
standard library.  The default types are ‘Int’ for integer literals,
‘Double’ for floating-point literals, ‘String’ for string literals, and
‘Bool’ for Boolean literals.  For example, in the declaration ‘let str =
"Hello, world"’, the default inferred type of the string literal
‘"Hello, world"’ is ‘String’.

   When specifying the type annotation for a literal value, the
annotation’s type must be a type that can be instantiated from that
literal value.  That is, the type must conform to one of the following
Swift standard library protocols: ‘ExpressibleByIntegerLiteral’ for
integer literals, ‘ExpressibleByFloatLiteral’ for floating-point
literals, ‘ExpressibleByStringLiteral’ for string literals,
‘ExpressibleByBooleanLiteral’ for Boolean literals,
‘ExpressibleByUnicodeScalarLiteral’ for string literals that contain
only a single Unicode scalar, and
‘ExpressibleByExtendedGraphemeClusterLiteral’ for string literals that
contain only a single extended grapheme cluster.  For example, ‘Int8’
conforms to the ‘ExpressibleByIntegerLiteral’ protocol, and therefore it
can be used in the type annotation for the integer literal ‘42’ in the
declaration ‘let x: Int8 = 42’.

   Grammar of a literal

   literal → numeric-literal
   string-literal
   boolean-literal
   nil-literal

   numeric-literal → =-=_opt integer-literal
=-=_opt
   floating-point-literal

   boolean-literal → ‘true’ | ‘false’

   nil-literal → ‘nil’

* Menu:

* Integer Literals::
* Floating-Point Literals::
* String Literals::


File: swift-reference.info,  Node: Integer Literals,  Next: Floating-Point Literals,  Up: Literals

3.4.1 Integer Literals
----------------------

_Integer literals_ represent integer values of unspecified precision.
By default, integer literals are expressed in decimal; you can specify
an alternate base using a prefix.  Binary literals begin with ‘0b’,
octal literals begin with ‘0o’, and hexadecimal literals begin with
‘0x’.

   Decimal literals contain the digits ‘0’ through ‘9’.  Binary literals
contain ‘0’ and ‘1’, octal literals contain ‘0’ through ‘7’, and
hexadecimal literals contain ‘0’ through ‘9’ as well as ‘A’ through ‘F’
in upper- or lowercase.

   Negative integers literals are expressed by prepending a minus sign
(‘-’) to an integer literal, as in ‘-42’.

   Underscores (‘_’) are allowed between digits for readability, but
they’re ignored and therefore don’t affect the value of the literal.
Integer literals can begin with leading zeros (‘0’), but they’re
likewise ignored and don’t affect the base or value of the literal.

   Unless otherwise specified, the default inferred type of an integer
literal is the Swift standard library type ‘Int’.  The Swift standard
library also defines types for various sizes of signed and unsigned
integers, as described in *note Integers: (swift)Integers.

   Grammar of an integer literal

   integer-literal → binary-literal

   integer-literal → octal-literal

   integer-literal → decimal-literal

   integer-literal → hexadecimal-literal

   binary-literal → ‘0b’ binary-digit binary-literal-characters _{opt}

   binary-digit → Digit 0 or 1

   binary-literal-character → binary-digit
‘_’

   binary-literal-characters → binary-literal-character
binary-literal-characters _{opt}

   octal-literal → ‘0o’ octal-digit octal-literal-characters _{opt}

   octal-digit → Digit 0 through 7

   octal-literal-character → octal-digit
‘_’

   octal-literal-characters → octal-literal-character
octal-literal-characters _{opt}

   decimal-literal → decimal-digit decimal-literal-characters _{opt}

   decimal-digit → Digit 0 through 9

   decimal-digits → decimal-digit decimal-digits _{opt}

   decimal-literal-character → decimal-digit
‘_’

   decimal-literal-characters → decimal-literal-character
decimal-literal-characters _{opt}

   hexadecimal-literal → ‘0x’ hexadecimal-digit
hexadecimal-literal-characters _{opt}

   hexadecimal-digit → Digit 0 through 9, a through f, or A through F

   hexadecimal-literal-character → hexadecimal-digit
‘_’

   hexadecimal-literal-characters → hexadecimal-literal-character
hexadecimal-literal-characters _{opt}


File: swift-reference.info,  Node: Floating-Point Literals,  Next: String Literals,  Prev: Integer Literals,  Up: Literals

3.4.2 Floating-Point Literals
-----------------------------

_Floating-point literals_ represent floating-point values of unspecified
precision.

   By default, floating-point literals are expressed in decimal (with no
prefix), but they can also be expressed in hexadecimal (with a ‘0x’
prefix).

   Decimal floating-point literals consist of a sequence of decimal
digits followed by either a decimal fraction, a decimal exponent, or
both.  The decimal fraction consists of a decimal point (‘.’) followed
by a sequence of decimal digits.  The exponent consists of an upper- or
lowercase ‘e’ prefix followed by a sequence of decimal digits that
indicates what power of 10 the value preceding the ‘e’ is multiplied by.
For example, ‘1.25e2’ represents 1.25 x 10^2, which evaluates to
‘125.0’.  Similarly, ‘1.25e-2’ represents 1.25 x 10^-2, which evaluates
to ‘0.0125’.

   Hexadecimal floating-point literals consist of a ‘0x’ prefix,
followed by an optional hexadecimal fraction, followed by a hexadecimal
exponent.  The hexadecimal fraction consists of a decimal point followed
by a sequence of hexadecimal digits.  The exponent consists of an upper-
or lowercase ‘p’ prefix followed by a sequence of decimal digits that
indicates what power of 2 the value preceding the ‘p’ is multiplied by.
For example, ‘0xFp2’ represents 15 x 2^2, which evaluates to ‘60’.
Similarly, ‘0xFp-2’ represents 15 x 2^-2, which evaluates to ‘3.75’.

   Negative floating-point literals are expressed by prepending a minus
sign (‘-’) to a floating-point literal, as in ‘-42.5’.

   Underscores (‘_’) are allowed between digits for readability, but
they’re ignored and therefore don’t affect the value of the literal.
Floating-point literals can begin with leading zeros (‘0’), but they’re
likewise ignored and don’t affect the base or value of the literal.

   Unless otherwise specified, the default inferred type of a
floating-point literal is the Swift standard library type ‘Double’,
which represents a 64-bit floating-point number.  The Swift standard
library also defines a ‘Float’ type, which represents a 32-bit
floating-point number.

   Grammar of a floating-point literal

   floating-point-literal → decimal-literal decimal-fraction _{opt}
decimal-exponent _{opt}

   floating-point-literal → hexadecimal-literal hexadecimal-fraction
_{opt} hexadecimal-exponent

   decimal-fraction → ‘.’ decimal-literal

   decimal-exponent → floating-point-e sign _{opt} decimal-literal

   hexadecimal-fraction → ‘.’ hexadecimal-digit
hexadecimal-literal-characters _{opt}

   hexadecimal-exponent → floating-point-p sign _{opt} decimal-literal

   floating-point-e → ‘e’ | ‘E’

   floating-point-p → ‘p’ | ‘P’

   sign → ‘+’ | ‘-’


File: swift-reference.info,  Node: String Literals,  Prev: Floating-Point Literals,  Up: Literals

3.4.3 String Literals
---------------------

A string literal is a sequence of characters surrounded by quotation
marks.  A single-line string literal is surrounded by double quotation
marks and has the following form:

  1. "characters"

   String literals can’t contain an unescaped double quotation mark
(‘"’), an unescaped backslash (‘\’), a carriage return, or a line feed.

   A multiline string literal is surrounded by three double quotation
marks and has the following form:

  1. """
  2. characters
  3. """

   Unlike a single-line string literal, a multiline string literal can
contain unescaped double quotation marks (‘"’), carriage returns, and
line feeds.  It can’t contain three unescaped double quotation marks
next to each other.

   The line break after the ‘"""’ that begins the multiline string
literal is not part of the string.  The line break before the ‘"""’ that
ends the literal is also not part of the string.  To make a multiline
string literal that begins or ends with a line feed, write a blank line
as its first or last line.

   A multiline string literal can be indented using any combination of
spaces and tabs; this indentation is not included in the string.  The
‘"""’ that ends the literal determines the indentation: Every nonblank
line in the literal must begin with exactly the same indentation that
appears before the closing ‘"""’; there’s no conversion between tabs and
spaces.  You can include additional spaces and tabs after that
indentation; those spaces and tabs appear in the string.

   Line breaks in a multiline string literal are normalized to use the
line feed character.  Even if your source file has a mix of carriage
returns and line feeds, all of the line breaks in the string will be the
same.

   In a multiline string literal, writing a backslash (‘\’) at the end
of a line omits that line break from the string.  Any whitespace between
the backslash and the line break is also omitted.  You can use this
syntax to hard wrap a multiline string literal in your source code,
without changing the value of the resulting string.

   Special characters can be included in string literals of both the
single-line and multiline forms using the following escape sequences:

   • Null character (‘\0’)

   • Backslash (‘\\’)

   • Horizontal tab (‘\t’)

   • Line feed (‘\n’)

   • Carriage return (‘\r’)

   • Double quotation mark (‘\"’)

   • Single quotation mark (‘\'’)

   • Unicode scalar (‘\u{=/n/’}=), where _n_ is a hexadecimal number
     that has one to eight digits

   The value of an expression can be inserted into a string literal by
placing the expression in parentheses after a backslash (‘\’).  The
interpolated expression can contain a string literal, but can’t contain
an unescaped backslash, a carriage return, or a line feed.

   For example, all of the following string literals have the same
value:

  1. "1 2 3"
  2. "1 2 \("3")"
  3. "1 2 \(3)"
  4. "1 2 \(1 + 2)"
  5. let x = 3; "1 2 \(x)"

   A string delimited by extended delimiters is a sequence of characters
surrounded by quotation marks and a balanced set of one or more number
signs (‘#’).  A string delimited by extended delimiters has the
following forms:

  1. #"characters"#
  2. 
  3. #"""
  4. characters
  5. """#

   Special characters in a string delimited by extended delimiters
appear in the resulting string as normal characters rather than as
special characters.  You can use extended delimiters to create strings
with characters that would ordinarily have a special effect such as
generating a string interpolation, starting an escape sequence, or
terminating the string.

   The following example shows a string literal and a string delimited
by extended delimiters that create equivalent string values:

  1. let string = #"\(x) \ " "#
  2. let escaped = "\\(x) \\ \" \"
  3. print(string)
  4. // Prints "\(x) \ " "
  5. print(string == escaped)
  6. // Prints "true"

   If you use more than one number sign to form a string delimited by
extended delimiters, don’t place whitespace in between the number signs:

  1. print(###"Line 1\###nLine 2"###) // OK
  2. print(# # #"Line 1\# # #nLine 2"# # #) // Error

   Multiline string literals that you create using extended delimiters
have the same indentation requirements as regular multiline string
literals.

   The default inferred type of a string literal is ‘String’.  For more
information about the ‘String’ type, see *note Strings and Characters:
(swift)Strings and Characters. and ‘String’
(https://developer.apple.com/documentation/swift/string)
[<https://developer.apple.com/documentation/swift/string>].

   String literals that are concatenated by the ‘+’ operator are
concatenated at compile time.  For example, the values of ‘textA’ and
‘textB’ in the example below are identical—no runtime concatenation is
performed.

  1. let textA = "Hello " + "world"
  2. let textB = "Hello world"

   Grammar of a string literal

   string-literal → static-string-literal
   interpolated-string-literal

   string-literal-opening-delimiter → extended-string-literal-delimiter
_{opt} ‘"’

   string-literal-closing-delimiter → ‘"’
extended-string-literal-delimiter _{opt}

   static-string-literal → string-literal-opening-delimiter quoted-text
_{opt} string-literal-closing-delimiter

   static-string-literal → multiline-string-literal-opening-delimiter
multiline-quoted-text _{opt} multiline-string-literal-closing-delimiter

   multiline-string-literal-opening-delimiter →
extended-string-literal-delimiter ‘"""’

   multiline-string-literal-closing-delimiter → ‘"""’
extended-string-literal-delimiter

   extended-string-literal-delimiter → ‘#’
extended-string-literal-delimiter _{opt}

   quoted-text → quoted-text-item quoted-text _{opt}

   quoted-text-item → escaped-character

   quoted-text-item → Any Unicode scalar value except ‘"’, ‘\’, U+000A,
or U+000D

   multiline-quoted-text → multiline-quoted-text-item
multiline-quoted-text _{opt}

   multiline-quoted-text-item → escaped-character

   multiline-quoted-text-item → Any Unicode scalar value except ‘\’

   multiline-quoted-text-item → escaped-newline

   interpolated-string-literal → string-literal-opening-delimiter
interpolated-text _{opt} string-literal-closing-delimiter

   interpolated-string-literal →
multiline-string-literal-opening-delimiter interpolated-text _{opt}
multiline-string-literal-closing-delimiter

   interpolated-text → interpolated-text-item interpolated-text _{opt}

   interpolated-text-item → ‘\(’ expression ‘)’ | quoted-text-item

   multiline-interpolated-text → multiline-interpolated-text-item
multiline-interpolated-text _{opt}

   multiline-interpolated-text-item → ‘\(’ expression ‘)’ |
multiline-quoted-text-item

   escape-sequence → ‘\’ extended-string-literal-delimiter

   escaped-character → escape-sequence ‘0’ | escape-sequence ‘\’ |
escape-sequence ‘t’ | escape-sequence ‘n’ | escape-sequence ‘r’ |
escape-sequence ‘"’ | escape-sequence ‘'’

   escaped-character → escape-sequence ‘u’ ‘{’ unicode-scalar-digits ‘}’

   unicode-scalar-digits → Between one and eight hexadecimal digits

   escaped-newline → escape-sequence whitespace _{opt} line-break


File: swift-reference.info,  Node: Operators,  Prev: Literals,  Up: Lexical Structure

3.5 Operators
=============

The Swift standard library defines a number of operators for your use,
many of which are discussed in *note Basic Operators: (swift)Basic
Operators. and *note Advanced Operators: (swift)Advanced Operators.  The
present section describes which characters can be used to define custom
operators.

   Custom operators can begin with one of the ASCII characters ‘/’, ‘=’,
‘-’, ‘+’, ‘!’, ‘*’, ‘%’, ‘<’, ‘>’, ‘&’, ‘|’, ‘^’, ‘?’, or ‘~’, or one of
the Unicode characters defined in the grammar below (which include
characters from the _Mathematical Operators_, _Miscellaneous Symbols_,
and _Dingbats_ Unicode blocks, among others).  After the first
character, combining Unicode characters are also allowed.

   You can also define custom operators that begin with a dot (‘.’).
These operators can contain additional dots.  For example, ‘.+.’ is
treated as a single operator.  If an operator doesn’t begin with a dot,
it can’t contain a dot elsewhere.  For example, ‘+.+’ is treated as the
‘+’ operator followed by the ‘.+’ operator.

   Although you can define custom operators that contain a question mark
(‘?’), they can’t consist of a single question mark character only.
Additionally, although operators can contain an exclamation mark (‘!’),
postfix operators can’t begin with either a question mark or an
exclamation mark.

   Note

   The tokens ‘=’, ‘->’, ‘//’, ‘/*’, ‘*/’, ‘.’, the prefix operators
‘<’, ‘&’, and ‘?’, the infix operator ‘?’, and the postfix operators
‘>’, ‘!’, and ‘?’ are reserved.  These tokens can’t be overloaded, nor
can they be used as custom operators.

   The whitespace around an operator is used to determine whether an
operator is used as a prefix operator, a postfix operator, or a binary
operator.  This behavior is summarized in the following rules:

   • If an operator has whitespace around both sides or around neither
     side, it’s treated as a binary operator.  As an example, the ‘+++’
     operator in ‘a+++b’ and ‘a +++ b’ is treated as a binary operator.

   • If an operator has whitespace on the left side only, it’s treated
     as a prefix unary operator.  As an example, the ‘+++’ operator in
     ‘a +++b’ is treated as a prefix unary operator.

   • If an operator has whitespace on the right side only, it’s treated
     as a postfix unary operator.  As an example, the ‘+++’ operator in
     ‘a+++ b’ is treated as a postfix unary operator.

   • If an operator has no whitespace on the left but is followed
     immediately by a dot (‘.’), it’s treated as a postfix unary
     operator.  As an example, the ‘+++’ operator in ‘a+++.b’ is treated
     as a postfix unary operator (‘a+++ .b’ rather than ‘a +++ .b’).

   For the purposes of these rules, the characters ‘(’, ‘[’, and ‘{’
before an operator, the characters ‘)’, ‘]’, and ‘}’ after an operator,
and the characters ‘,’, ‘;’, and ‘:’ are also considered whitespace.

   There’s one caveat to the rules above.  If the ‘!’ or ‘?’ predefined
operator has no whitespace on the left, it’s treated as a postfix
operator, regardless of whether it has whitespace on the right.  To use
the ‘?’ as the optional-chaining operator, it must not have whitespace
on the left.  To use it in the ternary conditional (‘?’  ‘:’) operator,
it must have whitespace around both sides.

   In certain constructs, operators with a leading ‘<’ or ‘>’ may be
split into two or more tokens.  The remainder is treated the same way
and may be split again.  As a result, there’s no need to use whitespace
to disambiguate between the closing ‘>’ characters in constructs like
‘Dictionary<String, Array<Int>>’.  In this example, the closing ‘>’
characters are not treated as a single token that may then be
misinterpreted as a bit shift ‘>>’ operator.

   To learn how to define new, custom operators, see *note Custom
Operators: (swift)Custom Operators. and *note Operator Declaration::.
To learn how to overload existing operators, see *note Operator Methods:
(swift)Operator Methods.

   Grammar of operators

   operator → operator-head operator-characters _{opt}

   operator → dot-operator-head dot-operator-characters

   operator-head → ‘/’ | ‘=’ | ‘-’ | ‘+’ | ‘!’ | ‘*’ | ‘%’ | ‘<’ | ‘>’ |
‘&’ | ‘|’ | ‘^’ | ‘~’ | ‘?’

   operator-head → U+00A1–U+00A7

   operator-head → U+00A9 or U+00AB

   operator-head → U+00AC or U+00AE

   operator-head → U+00B0–U+00B1

   operator-head → U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7

   operator-head → U+2016–U+2017

   operator-head → U+2020–U+2027

   operator-head → U+2030–U+203E

   operator-head → U+2041–U+2053

   operator-head → U+2055–U+205E

   operator-head → U+2190–U+23FF

   operator-head → U+2500–U+2775

   operator-head → U+2794–U+2BFF

   operator-head → U+2E00–U+2E7F

   operator-head → U+3001–U+3003

   operator-head → U+3008–U+3020

   operator-head → U+3030

   operator-character → operator-head

   operator-character → U+0300–U+036F

   operator-character → U+1DC0–U+1DFF

   operator-character → U+20D0–U+20FF

   operator-character → U+FE00–U+FE0F

   operator-character → U+FE20–U+FE2F

   operator-character → U+E0100–U+E01EF

   operator-characters → operator-character operator-characters _{opt}

   dot-operator-head → ‘.’

   dot-operator-character → ‘.’ | operator-character

   dot-operator-characters → dot-operator-character
dot-operator-characters _{opt}

   binary-operator → operator

   prefix-operator → operator

   postfix-operator → operator


File: swift-reference.info,  Node: Types,  Next: Expressions,  Prev: Lexical Structure,  Up: Top

4 Types
*******

In Swift, there are two kinds of types: named types and compound types.
A _named type_ is a type that can be given a particular name when it’s
defined.  Named types include classes, structures, enumerations, and
protocols.  For example, instances of a user-defined class named
‘MyClass’ have the type ‘MyClass’.  In addition to user-defined named
types, the Swift standard library defines many commonly used named
types, including those that represent arrays, dictionaries, and optional
values.

   Data types that are normally considered basic or primitive in other
languages—such as types that represent numbers, characters, and
strings—are actually named types, defined and implemented in the Swift
standard library using structures.  Because they’re named types, you can
extend their behavior to suit the needs of your program, using an
extension declaration, discussed in *note Extensions: (swift)Extensions.
and *note Extension Declaration::.

   A _compound type_ is a type without a name, defined in the Swift
language itself.  There are two compound types: function types and tuple
types.  A compound type may contain named types and other compound
types.  For example, the tuple type ‘(Int, (Int, Int))’ contains two
elements: The first is the named type ‘Int’, and the second is another
compound type ‘(Int, Int)’.

   You can put parentheses around a named type or a compound type.
However, adding parentheses around a type doesn’t have any effect.  For
example, ‘(Int)’ is equivalent to ‘Int’.

   This chapter discusses the types defined in the Swift language itself
and describes the type inference behavior of Swift.

   Grammar of a type

   type → function-type

   type → array-type

   type → dictionary-type

   type → type-identifier

   type → tuple-type

   type → optional-type

   type → implicitly-unwrapped-optional-type

   type → protocol-composition-type

   type → opaque-type

   type → metatype-type

   type → ‘Any’

   type → ‘Self’

   type → ‘(’ type ‘)’

* Menu:

* Type Annotation::
* Type Identifier::
* Tuple Type::
* Function Type::
* Array Type::
* Dictionary Type::
* Optional Type::
* Implicitly Unwrapped Optional Type::
* Protocol Composition Type::
* Opaque Type::
* Metatype Type::
* Self Type::
* Type Inheritance Clause::
* Type Inference::


File: swift-reference.info,  Node: Type Annotation,  Next: Type Identifier,  Up: Types

4.1 Type Annotation
===================

A _type annotation_ explicitly specifies the type of a variable or
expression.  Type annotations begin with a colon (‘:’) and end with a
type, as the following examples show:

  1. let someTuple: (Double, Double) = (3.14159, 2.71828)
  2. func someFunction(a: Int) { _* ... *_ }

   In the first example, the expression ‘someTuple’ is specified to have
the tuple type ‘(Double, Double)’.  In the second example, the parameter
‘a’ to the function ‘someFunction’ is specified to have the type ‘Int’.

   Type annotations can contain an optional list of type attributes
before the type.

   Grammar of a type annotation

   type-annotation → ‘:’ attributes _{opt} =inout=_opt type


File: swift-reference.info,  Node: Type Identifier,  Next: Tuple Type,  Prev: Type Annotation,  Up: Types

4.2 Type Identifier
===================

A _type identifier_ refers to either a named type or a type alias of a
named or compound type.

   Most of the time, a type identifier directly refers to a named type
with the same name as the identifier.  For example, ‘Int’ is a type
identifier that directly refers to the named type ‘Int’, and the type
identifier ‘Dictionary<String, Int>’ directly refers to the named type
‘Dictionary<String, Int>’.

   There are two cases in which a type identifier doesn’t refer to a
type with the same name.  In the first case, a type identifier refers to
a type alias of a named or compound type.  For instance, in the example
below, the use of ‘Point’ in the type annotation refers to the tuple
type ‘(Int, Int)’.

  1. typealias Point = (Int, Int)
  2. let origin: Point = (0, 0)

   In the second case, a type identifier uses dot (‘.’) syntax to refer
to named types declared in other modules or nested within other types.
For example, the type identifier in the following code references the
named type ‘MyType’ that is declared in the ‘ExampleModule’ module.

  1. var someValue: ExampleModule.MyType

   Grammar of a type identifier

   type-identifier → type-name generic-argument-clause _{opt} |
type-name generic-argument-clause _{opt} ‘.’ type-identifier

   type-name → identifier


File: swift-reference.info,  Node: Tuple Type,  Next: Function Type,  Prev: Type Identifier,  Up: Types

4.3 Tuple Type
==============

A _tuple type_ is a comma-separated list of types, enclosed in
parentheses.

   You can use a tuple type as the return type of a function to enable
the function to return a single tuple containing multiple values.  You
can also name the elements of a tuple type and use those names to refer
to the values of the individual elements.  An element name consists of
an identifier followed immediately by a colon (:).  For an example that
demonstrates both of these features, see *note Functions with Multiple
Return Values: (swift)Functions with Multiple Return Values.

   When an element of a tuple type has a name, that name is part of the
type.

  1. var someTuple = (top: 10, bottom: 12) // someTuple is of type (top:
     Int, bottom: Int)
  2. someTuple = (top: 4, bottom: 42) // OK: names match
  3. someTuple = (9, 99) // OK: names are inferred
  4. someTuple = (left: 5, right: 5) // Error: names don’t match

   All tuple types contain two or more types, except for ‘Void’ which is
a type alias for the empty tuple type, ‘()’.

   Grammar of a tuple type

   tuple-type → ‘(’ ‘)’ | ‘(’ tuple-type-element ‘,’
tuple-type-element-list ‘)’

   tuple-type-element-list → tuple-type-element
   tuple-type-element ‘,’ tuple-type-element-list

   tuple-type-element → element-name type-annotation
type

   element-name → identifier


File: swift-reference.info,  Node: Function Type,  Next: Array Type,  Prev: Tuple Type,  Up: Types

4.4 Function Type
=================

A _function type_ represents the type of a function, method, or closure
and consists of a parameter and return type separated by an arrow
(‘->’):

  1. (parameter type) -> return type

   The _parameter type_ is comma-separated list of types.  Because the
_return type_ can be a tuple type, function types support functions and
methods that return multiple values.

   A parameter of the function type ‘() -> T’ (where ‘T’ is any type)
can apply the ‘autoclosure’ attribute to implicitly create a closure at
its call sites.  This provides a syntactically convenient way to defer
the evaluation of an expression without needing to write an explicit
closure when you call the function.  For an example of an autoclosure
function type parameter, see *note Autoclosures: (swift)Autoclosures.

   A function type can have a variadic parameter in its _parameter
type_.  Syntactically, a variadic parameter consists of a base type name
followed immediately by three dots (‘...’), as in ‘Int...’.  A variadic
parameter is treated as an array that contains elements of the base type
name.  For instance, the variadic parameter ‘Int...’ is treated as
‘[Int]’.  For an example that uses a variadic parameter, see *note
Variadic Parameters: (swift)Variadic Parameters.

   To specify an in-out parameter, prefix the parameter type with the
‘inout’ keyword.  You can’t mark a variadic parameter or a return type
with the ‘inout’ keyword.  In-out parameters are discussed in *note
In-Out Parameters::.

   If a function type has only one parameter and that parameter’s type
is a tuple type, then the tuple type must be parenthesized when writing
the function’s type.  For example, ‘((Int, Int)) -> Void’ is the type of
a function that takes a single parameter of the tuple type ‘(Int, Int)’
and doesn’t return any value.  In contrast, without parentheses, ‘(Int,
Int) -> Void’ is the type of a function that takes two ‘Int’ parameters
and doesn’t return any value.  Likewise, because ‘Void’ is a type alias
for ‘()’, the function type ‘(Void) -> Void’ is the same as ‘(()) ->
()’—a function that takes a single argument that is an empty tuple.
These types are not the same as ‘() -> ()’—a function that takes no
arguments.

   Argument names in functions and methods are not part of the
corresponding function type.  For example:

  1. func someFunction(left: Int, right: Int) {}
  2. func anotherFunction(left: Int, right: Int) {}
  3. func functionWithDifferentLabels(top: Int, bottom: Int) {}
  4. 
  5. var f = someFunction // The type of f is (Int, Int) -> Void, not
     (left: Int, right: Int) -> Void.
  6. f = anotherFunction // OK
  7. f = functionWithDifferentLabels // OK
  8. 
  9. func functionWithDifferentArgumentTypes(left: Int, right: String)
     {}
  10. f = functionWithDifferentArgumentTypes // Error
  11. 
  12. func functionWithDifferentNumberOfArguments(left: Int, right: Int,
     top: Int) {}
  13. f = functionWithDifferentNumberOfArguments // Error

   Because argument labels are not part of a function’s type, you omit
them when writing a function type.

  1. var operation: (lhs: Int, rhs: Int) -> Int // Error
  2. var operation: (_ lhs: Int, _ rhs: Int) -> Int // OK
  3. var operation: (Int, Int) -> Int // OK

   If a function type includes more than a single arrow (‘->’), the
function types are grouped from right to left.  For example, the
function type ‘(Int) -> (Int) -> Int’ is understood as ‘(Int) -> ((Int)
-> Int)’—that is, a function that takes an ‘Int’ and returns another
function that takes and returns an ‘Int’.

   Function types that can throw or rethrow an error must be marked with
the ‘throws’ keyword.  The ‘throws’ keyword is part of a function’s
type, and nonthrowing functions are subtypes of throwing functions.  As
a result, you can use a nonthrowing function in the same places as a
throwing one.  Throwing and rethrowing functions are described in *note
Throwing Functions and Methods: Throwing Functions and Methods. and
*note Rethrowing Functions and Methods::.

* Menu:

* Restrictions for Nonescaping Closures::


File: swift-reference.info,  Node: Restrictions for Nonescaping Closures,  Up: Function Type

4.4.1 Restrictions for Nonescaping Closures
-------------------------------------------

A parameter that’s a nonescaping function can’t be stored in a property,
variable, or constant of type ‘Any’, because that might allow the value
to escape.

   A parameter that’s a nonescaping function can’t be passed as an
argument to another nonescaping function parameter.  This restriction
helps Swift perform more of its checks for conflicting access to memory
at compile time instead of at runtime.  For example:

  1. let external: (() -> Void) -> Void = { _ in () }
  2. func takesTwoFunctions(first: (() -> Void) -> Void, second: (() ->
     Void) -> Void) {
  3. first { first {} } // Error
  4. second { second {} } // Error
  5. 
  6. first { second {} } // Error
  7. second { first {} } // Error
  8. 
  9. first { external {} } // OK
  10. external { first {} } // OK
  11. }

   In the code above, both of the parameters to
‘takesTwoFunctions(first:second:)’ are functions.  Neither parameter is
marked ‘@escaping’, so they’re both nonescaping as a result.

   The four function calls marked “Error” in the example above cause
compiler errors.  Because the ‘first’ and ‘second’ parameters are
nonescaping functions, they can’t be passed as arguments to another
nonescaping function parameter.  In contrast, the two function calls
marked “OK” don’t cause a compiler error.  These function calls don’t
violate the restriction because ‘external’ isn’t one of the parameters
of ‘takesTwoFunctions(first:second:)’.

   If you need to avoid this restriction, mark one of the parameters as
escaping, or temporarily convert one of the nonescaping function
parameters to an escaping function by using the
‘withoutActuallyEscaping(_:do:)’ function.  For information about
avoiding conflicting access to memory, see *note Memory Safety:
(swift)Memory Safety.

   Grammar of a function type

   function-type → attributes _{opt} function-type-argument-clause
‘throws=_{opt} =->’ type

   function-type-argument-clause → ‘(’ ‘)’

   function-type-argument-clause → ‘(’ function-type-argument-list
‘...=_{opt} =)’

   function-type-argument-list → function-type-argument
   function-type-argument ‘,’ function-type-argument-list

   function-type-argument → attributes _{opt} =inout=_opt type |
argument-label type-annotation

   argument-label → identifier


File: swift-reference.info,  Node: Array Type,  Next: Dictionary Type,  Prev: Function Type,  Up: Types

4.5 Array Type
==============

The Swift language provides the following syntactic sugar for the Swift
standard library ‘Array<Element>’ type:

  1. [type]

   In other words, the following two declarations are equivalent:

  1. let someArray: Array<String> = ["Alex", "Brian", "Dave"]
  2. let someArray: [String] = ["Alex", "Brian", "Dave"]

   In both cases, the constant ‘someArray’ is declared as an array of
strings.  The elements of an array can be accessed through subscripting
by specifying a valid index value in square brackets: ‘someArray[0]’
refers to the element at index 0, ‘"Alex"’.

   You can create multidimensional arrays by nesting pairs of square
brackets, where the name of the base type of the elements is contained
in the innermost pair of square brackets.  For example, you can create a
three-dimensional array of integers using three sets of square brackets:

     var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]

   When accessing the elements in a multidimensional array, the
left-most subscript index refers to the element at that index in the
outermost array.  The next subscript index to the right refers to the
element at that index in the array that’s nested one level in.  And so
on.  This means that in the example above, ‘array3D[0]’ refers to ‘[[1,
2], [3, 4]]’, ‘array3D[0][1]’ refers to ‘[3, 4]’, and ‘array3D[0][1][1]’
refers to the value 4.

   For a detailed discussion of the Swift standard library ‘Array’ type,
see *note Arrays: (swift)Arrays.

   Grammar of an array type

   array-type → ‘[’ type ‘]’


File: swift-reference.info,  Node: Dictionary Type,  Next: Optional Type,  Prev: Array Type,  Up: Types

4.6 Dictionary Type
===================

The Swift language provides the following syntactic sugar for the Swift
standard library ‘Dictionary<Key, Value>’ type:

  1. [key type: value type]

   In other words, the following two declarations are equivalent:

  1. let someDictionary: [String: Int] = ["Alex": 31, "Paul": 39]
  2. let someDictionary: Dictionary<String, Int> = ["Alex": 31, "Paul":
     39]

   In both cases, the constant ‘someDictionary’ is declared as a
dictionary with strings as keys and integers as values.

   The values of a dictionary can be accessed through subscripting by
specifying the corresponding key in square brackets:
‘someDictionary["Alex"]’ refers to the value associated with the key
‘"Alex"’.  The subscript returns an optional value of the dictionary’s
value type.  If the specified key isn’t contained in the dictionary, the
subscript returns ‘nil’.

   The key type of a dictionary must conform to the Swift standard
library ‘Hashable’ protocol.

   For a detailed discussion of the Swift standard library ‘Dictionary’
type, see *note Dictionaries: (swift)Dictionaries.

   Grammar of a dictionary type

   dictionary-type → ‘[’ type ‘:’ type ‘]’


File: swift-reference.info,  Node: Optional Type,  Next: Implicitly Unwrapped Optional Type,  Prev: Dictionary Type,  Up: Types

4.7 Optional Type
=================

The Swift language defines the postfix ‘?’ as syntactic sugar for the
named type ‘Optional<Wrapped>’, which is defined in the Swift standard
library.  In other words, the following two declarations are equivalent:

  1. var optionalInteger: Int?
  2. var optionalInteger: Optional<Int>

   In both cases, the variable ‘optionalInteger’ is declared to have the
type of an optional integer.  Note that no whitespace may appear between
the type and the ‘?’.

   The type ‘Optional<Wrapped>’ is an enumeration with two cases, ‘none’
and ‘some(Wrapped)’, which are used to represent values that may or may
not be present.  Any type can be explicitly declared to be (or
implicitly converted to) an optional type.  If you don’t provide an
initial value when you declare an optional variable or property, its
value automatically defaults to ‘nil’.

   If an instance of an optional type contains a value, you can access
that value using the postfix operator ‘!’, as shown below:

  1. optionalInteger = 42
  2. optionalInteger!  // 42

   Using the ‘!’ operator to unwrap an optional that has a value of
‘nil’ results in a runtime error.

   You can also use optional chaining and optional binding to
conditionally perform an operation on an optional expression.  If the
value is ‘nil’, no operation is performed and therefore no runtime error
is produced.

   For more information and to see examples that show how to use
optional types, see *note Optionals: (swift)Optionals.

   Grammar of an optional type

   optional-type → type ‘?’


File: swift-reference.info,  Node: Implicitly Unwrapped Optional Type,  Next: Protocol Composition Type,  Prev: Optional Type,  Up: Types

4.8 Implicitly Unwrapped Optional Type
======================================

The Swift language defines the postfix ‘!’ as syntactic sugar for the
named type ‘Optional<Wrapped>’, which is defined in the Swift standard
library, with the additional behavior that it’s automatically unwrapped
when it’s accessed.  If you try to use an implicitly unwrapped optional
that has a value of ‘nil’, you’ll get a runtime error.  With the
exception of the implicit unwrapping behavior, the following two
declarations are equivalent:

  1. var implicitlyUnwrappedString: String!
  2. var explicitlyUnwrappedString: Optional<String>

   Note that no whitespace may appear between the type and the ‘!’.

   Because implicit unwrapping changes the meaning of the declaration
that contains that type, optional types that are nested inside a tuple
type or a generic type—such as the element types of a dictionary or
array—can’t be marked as implicitly unwrapped.  For example:

  1. let tupleOfImplicitlyUnwrappedElements: (Int!, Int!)  // Error
  2. let implicitlyUnwrappedTuple: (Int, Int)!  // OK
  3. 
  4. let arrayOfImplicitlyUnwrappedElements: [Int!]  // Error
  5. let implicitlyUnwrappedArray: [Int]!  // OK

   Because implicitly unwrapped optionals have the same
‘Optional<Wrapped>’ type as optional values, you can use implicitly
unwrapped optionals in all the same places in your code that you can use
optionals.  For example, you can assign values of implicitly unwrapped
optionals to variables, constants, and properties of optionals, and vice
versa.

   As with optionals, if you don’t provide an initial value when you
declare an implicitly unwrapped optional variable or property, its value
automatically defaults to ‘nil’.

   Use optional chaining to conditionally perform an operation on an
implicitly unwrapped optional expression.  If the value is ‘nil’, no
operation is performed and therefore no runtime error is produced.

   For more information about implicitly unwrapped optional types, see
*note Implicitly Unwrapped Optionals: (swift)Implicitly Unwrapped
Optionals.

   Grammar of an implicitly unwrapped optional type

   implicitly-unwrapped-optional-type → type ‘!’


File: swift-reference.info,  Node: Protocol Composition Type,  Next: Opaque Type,  Prev: Implicitly Unwrapped Optional Type,  Up: Types

4.9 Protocol Composition Type
=============================

A _protocol composition_ type defines a type that conforms to each
protocol in a list of specified protocols, or a type that is a subclass
of a given class and conforms to each protocol in a list of specified
protocols.  Protocol composition types may be used only when specifying
a type in type annotations, in generic parameter clauses, and in generic
‘where’ clauses.

   Protocol composition types have the following form:

  1. Protocol 1 & Protocol 2

   A protocol composition type allows you to specify a value whose type
conforms to the requirements of multiple protocols without explicitly
defining a new, named protocol that inherits from each protocol you want
the type to conform to.  For example, you can use the protocol
composition type ‘ProtocolA & ProtocolB & ProtocolC’ instead of
declaring a new protocol that inherits from ‘ProtocolA’, ‘ProtocolB’,
and ‘ProtocolC’.  Likewise, you can use ‘SuperClass & ProtocolA’ instead
of declaring a new protocol that is a subclass of ‘SuperClass’ and
conforms to ‘ProtocolA’.

   Each item in a protocol composition list is one of the following; the
list can contain at most one class:

   • The name of a class

   • The name of a protocol

   • A type alias whose underlying type is a protocol composition type,
     a protocol, or a class.

   When a protocol composition type contains type aliases, it’s possible
for the same protocol to appear more than once in the
definitions—duplicates are ignored.  For example, the definition of
‘PQR’ in the code below is equivalent to ‘P & Q & R’.

  1. typealias PQ = P & Q
  2. typealias PQR = PQ & Q & R

   Grammar of a protocol composition type

   protocol-composition-type → type-identifier ‘&’
protocol-composition-continuation

   protocol-composition-continuation → type-identifier
   protocol-composition-type


File: swift-reference.info,  Node: Opaque Type,  Next: Metatype Type,  Prev: Protocol Composition Type,  Up: Types

4.10 Opaque Type
================

An _opaque type_ defines a type that conforms to a protocol or protocol
composition, without specifying the underlying concrete type.

   Opaque types appear as the return type of a function or subscript, or
the type of a property.  Opaque types can’t appear as part of a tuple
type or a generic type, such as the element type of an array or the
wrapped type of an optional.

   Opaque types have the following form:

  1. some constraint

   The _constraint_ is a class type, protocol type, protocol composition
type, or ‘Any’.  A value can be used as an instance of the opaque type
only if it’s an instance of a type that conforms to the listed protocol
or protocol composition, or inherits from the listed class.  Code that
interacts with an opaque value can use the value only in ways that are
part of the interface defined by the _constraint_.

   Protocol declarations can’t include opaque types.  Classes can’t use
an opaque type as the return type of a nonfinal method.

   A function that uses an opaque type as its return type must return
values that share a single underlying type.  The return type can include
types that are part of the function’s generic type parameters.  For
example, a function ‘someFunction<T>()’ could return a value of type ‘T’
or ‘Dictionary<String, T>’.

   Grammar of an opaque type

   opaque-type → ‘some’ type


File: swift-reference.info,  Node: Metatype Type,  Next: Self Type,  Prev: Opaque Type,  Up: Types

4.11 Metatype Type
==================

A _metatype type_ refers to the type of any type, including class types,
structure types, enumeration types, and protocol types.

   The metatype of a class, structure, or enumeration type is the name
of that type followed by ‘.Type’.  The metatype of a protocol type—not
the concrete type that conforms to the protocol at runtime—is the name
of that protocol followed by ‘.Protocol’.  For example, the metatype of
the class type ‘SomeClass’ is ‘SomeClass.Type’ and the metatype of the
protocol ‘SomeProtocol’ is ‘SomeProtocol.Protocol’.

   You can use the postfix ‘self’ expression to access a type as a
value.  For example, ‘SomeClass.self’ returns ‘SomeClass’ itself, not an
instance of ‘SomeClass’.  And ‘SomeProtocol.self’ returns ‘SomeProtocol’
itself, not an instance of a type that conforms to ‘SomeProtocol’ at
runtime.  You can call the ‘type(of:)’ function with an instance of a
type to access that instance’s dynamic, runtime type as a value, as the
following example shows:

  1. class SomeBaseClass {
  2. class func printClassName() {
  3. print("SomeBaseClass")
  4. }
  5. }
  6. class SomeSubClass: SomeBaseClass {
  7. override class func printClassName() {
  8. print("SomeSubClass")
  9. }
  10. }
  11. let someInstance: SomeBaseClass = SomeSubClass()
  12. // The compile-time type of someInstance is SomeBaseClass,
  13. // and the runtime type of someInstance is SomeSubClass
  14. type(of: someInstance).printClassName()
  15. // Prints "SomeSubClass"

   For more information, see ‘type(of:)’
(https://developer.apple.com/documentation/swift/2885064-type)
[<https://developer.apple.com/documentation/swift/2885064-type>] in the
Swift standard library.

   Use an initializer expression to construct an instance of a type from
that type’s metatype value.  For class instances, the initializer that’s
called must be marked with the ‘required’ keyword or the entire class
marked with the ‘final’ keyword.

  1. class AnotherSubClass: SomeBaseClass {
  2. let string: String
  3. required init(string: String) {
  4. self.string = string
  5. }
  6. override class func printClassName() {
  7. print("AnotherSubClass")
  8. }
  9. }
  10. let metatype: AnotherSubClass.Type = AnotherSubClass.self
  11. let anotherInstance = metatype.init(string: "some string")

   Grammar of a metatype type

   metatype-type → type ‘.’  ‘Type’ | type ‘.’  ‘Protocol’


File: swift-reference.info,  Node: Self Type,  Next: Type Inheritance Clause,  Prev: Metatype Type,  Up: Types

4.12 Self Type
==============

Proposal
(https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md)

   The ‘Self’ type isn’t a specific type, but rather lets you
conveniently refer to the current type without repeating or knowing that
type’s name.

   In a protocol declaration or a protocol member declaration, the
‘Self’ type refers to the eventual type that conforms to the protocol.

   In a structure, class, or enumeration declaration, the ‘Self’ type
refers to the type introduced by the declaration.  Inside the
declaration for a member of a type, the ‘Self’ type refers to that type.
In the members of a class declaration, ‘Self’ can appear only as
follows:

   • As the return type of a method

   • As the return type of a read-only subscript

   • As the type of a read-only computed property

   • In the body of a method

   For example, the code below shows an instance method ‘f’ whose return
type is ‘Self’.

  1. class Superclass {
  2. func f() -> Self { return self }
  3. }
  4. let x = Superclass()
  5. print(type(of: x.f()))
  6. // Prints "Superclass"
  7. 
  8. class Subclass: Superclass { }
  9. let y = Subclass()
  10. print(type(of: y.f()))
  11. // Prints "Subclass"
  12. 
  13. let z: Superclass = Subclass()
  14. print(type(of: z.f()))
  15. // Prints "Subclass"

   The last part of the example above shows that ‘Self’ refers to the
runtime type ‘Subclass’ of the value of ‘z’, not the compile-time type
‘Superclass’ of the variable itself.

   Inside a nested type declaration, the ‘Self’ type refers to the type
introduced by the innermost type declaration.

   The ‘Self’ type refers to the same type as the ‘type(of:)’
(https://developer.apple.com/documentation/swift/2885064-type)
[<https://developer.apple.com/documentation/swift/2885064-type>]
function in the Swift standard library.  Writing ‘Self.someStaticMember’
to access a member of the current type is the same as writing ‘type(of:
self).someStaticMember’.

   Grammar of a Self type

   self-type → ‘Self’


File: swift-reference.info,  Node: Type Inheritance Clause,  Next: Type Inference,  Prev: Self Type,  Up: Types

4.13 Type Inheritance Clause
============================

A _type inheritance clause_ is used to specify which class a named type
inherits from and which protocols a named type conforms to.  A type
inheritance clause begins with a colon (‘:’), followed by a list of type
identifiers.

   Class types can inherit from a single superclass and conform to any
number of protocols.  When defining a class, the name of the superclass
must appear first in the list of type identifiers, followed by any
number of protocols the class must conform to.  If the class doesn’t
inherit from another class, the list can begin with a protocol instead.
For an extended discussion and several examples of class inheritance,
see *note Inheritance: (swift)Inheritance.

   Other named types can only inherit from or conform to a list of
protocols.  Protocol types can inherit from any number of other
protocols.  When a protocol type inherits from other protocols, the set
of requirements from those other protocols are aggregated together, and
any type that inherits from the current protocol must conform to all of
those requirements.

   A type inheritance clause in an enumeration definition can be either
a list of protocols, or in the case of an enumeration that assigns raw
values to its cases, a single, named type that specifies the type of
those raw values.  For an example of an enumeration definition that uses
a type inheritance clause to specify the type of its raw values, see
*note Raw Values: (swift)Raw Values.

   Grammar of a type inheritance clause

   type-inheritance-clause → ‘:’ type-inheritance-list

   type-inheritance-list → type-identifier
   type-identifier ‘,’ type-inheritance-list


File: swift-reference.info,  Node: Type Inference,  Prev: Type Inheritance Clause,  Up: Types

4.14 Type Inference
===================

Swift uses _type inference_ extensively, allowing you to omit the type
or part of the type of many variables and expressions in your code.  For
example, instead of writing ‘var x: Int = 0’, you can write ‘var x = 0’,
omitting the type completely—the compiler correctly infers that ‘x’
names a value of type ‘Int’.  Similarly, you can omit part of a type
when the full type can be inferred from context.  For example, if you
write ‘let dict: Dictionary = ["A": 1]’, the compiler infers that ‘dict’
has the type ‘Dictionary<String, Int>’.

   In both of the examples above, the type information is passed up from
the leaves of the expression tree to its root.  That is, the type of ‘x’
in ‘var x: Int = 0’ is inferred by first checking the type of ‘0’ and
then passing this type information up to the root (the variable ‘x’).

   In Swift, type information can also flow in the opposite
direction—from the root down to the leaves.  In the following example,
for instance, the explicit type annotation (‘: Float’) on the constant
‘eFloat’ causes the numeric literal ‘2.71828’ to have an inferred type
of ‘Float’ instead of ‘Double’.

  1. let e = 2.71828 // The type of e is inferred to be Double.
  2. let eFloat: Float = 2.71828 // The type of eFloat is Float.

   Type inference in Swift operates at the level of a single expression
or statement.  This means that all of the information needed to infer an
omitted type or part of a type in an expression must be accessible from
type-checking the expression or one of its subexpressions.


File: swift-reference.info,  Node: Expressions,  Next: Statements,  Prev: Types,  Up: Top

5 Expressions
*************

In Swift, there are four kinds of expressions: prefix expressions,
binary expressions, primary expressions, and postfix expressions.
Evaluating an expression returns a value, causes a side effect, or both.

   Prefix and binary expressions let you apply operators to smaller
expressions.  Primary expressions are conceptually the simplest kind of
expression, and they provide a way to access values.  Postfix
expressions, like prefix and binary expressions, let you build up more
complex expressions using postfixes such as function calls and member
access.  Each kind of expression is described in detail in the sections
below.

   Grammar of an expression

   expression → try-operator _{opt} prefix-expression binary-expressions
_{opt}

   expression-list → expression
   expression ‘,’ expression-list

* Menu:

* Prefix Expressions::
* Binary Expressions::
* Primary Expressions::
* Postfix Expressions::


File: swift-reference.info,  Node: Prefix Expressions,  Next: Binary Expressions,  Up: Expressions

5.1 Prefix Expressions
======================

_Prefix expressions_ combine an optional prefix operator with an
expression.  Prefix operators take one argument, the expression that
follows them.

   For information about the behavior of these operators, see *note
Basic Operators: (swift)Basic Operators. and *note Advanced Operators:
(swift)Advanced Operators.

   For information about the operators provided by the Swift standard
library, see Operator Declarations
(https://developer.apple.com/documentation/swift/operator_declarations)
[<https://developer.apple.com/documentation/swift/operator_declarations>].

   In addition to the standard library operators, you use ‘&’
immediately before the name of a variable that’s being passed as an
in-out argument to a function call expression.  For more information and
to see an example, see *note In-Out Parameters: In-Out Parameters.

   Grammar of a prefix expression

   prefix-expression → prefix-operator _{opt} postfix-expression

   prefix-expression → in-out-expression

   in-out-expression → ‘&’ identifier

* Menu:

* Try Operator::


File: swift-reference.info,  Node: Try Operator,  Up: Prefix Expressions

5.1.1 Try Operator
------------------

A _try expression_ consists of the ‘try’ operator followed by an
expression that can throw an error.  It has the following form:

  1. try expression

   An _optional-try expression_ consists of the ‘try?’ operator followed
by an expression that can throw an error.  It has the following form:

  1. try?  expression

   If the _expression_ does not throw an error, the value of the
optional-try expression is an optional containing the value of the
_expression_.  Otherwise, the value of the optional-try expression is
‘nil’.

   A _forced-try expression_ consists of the ‘try!’ operator followed by
an expression that can throw an error.  It has the following form:

  1. try!  expression

   If the _expression_ throws an error, a runtime error is produced.

   When the expression on the left-hand side of a binary operator is
marked with ‘try’, ‘try?’, or ‘try!’, that operator applies to the whole
binary expression.  That said, you can use parentheses to be explicit
about the scope of the operator’s application.

  1. sum = try someThrowingFunction() + anotherThrowingFunction() // try
     applies to both function calls
  2. sum = try (someThrowingFunction() + anotherThrowingFunction()) //
     try applies to both function calls
  3. sum = (try someThrowingFunction()) + anotherThrowingFunction() //
     Error: try applies only to the first function call

   A ‘try’ expression can’t appear on the right-hand side of a binary
operator, unless the binary operator is the assignment operator or the
‘try’ expression is enclosed in parentheses.

   For more information and to see examples of how to use ‘try’, ‘try?’,
and ‘try!’, see *note Error Handling: (swift)Error Handling.

   Grammar of a try expression

   try-operator → ‘try’ | ‘try’ ‘?’ | ‘try’ ‘!’


File: swift-reference.info,  Node: Binary Expressions,  Next: Primary Expressions,  Prev: Prefix Expressions,  Up: Expressions

5.2 Binary Expressions
======================

_Binary expressions_ combine an infix binary operator with the
expression that it takes as its left-hand and right-hand arguments.  It
has the following form:

  1. left-hand argument operator right-hand argument

   For information about the behavior of these operators, see *note
Basic Operators: (swift)Basic Operators. and *note Advanced Operators:
(swift)Advanced Operators.

   For information about the operators provided by the Swift standard
library, see Operator Declarations
(https://developer.apple.com/documentation/swift/operator_declarations)
[<https://developer.apple.com/documentation/swift/operator_declarations>].

   Note

   At parse time, an expression made up of binary operators is
represented as a flat list.  This list is transformed into a tree by
applying operator precedence.  For example, the expression ‘2 + 3 * 5’
is initially understood as a flat list of five items, ‘2’, ‘+’, ‘3’,
‘*’, and ‘5’.  This process transforms it into the tree (2 + (3 * 5)).

   Grammar of a binary expression

   binary-expression → binary-operator prefix-expression

   binary-expression → assignment-operator try-operator _{opt}
prefix-expression

   binary-expression → conditional-operator try-operator _{opt}
prefix-expression

   binary-expression → type-casting-operator

   binary-expressions → binary-expression binary-expressions _{opt}

* Menu:

* Assignment Operator::
* Type-Casting Operators::


File: swift-reference.info,  Node: Assignment Operator,  Next: Type-Casting Operators,  Up: Binary Expressions

5.2.1 Assignment Operator
-------------------------

The _assignment operator_ sets a new value for a given expression.  It
has the following form:

  1. expression = value

   The value of the _expression_ is set to the value obtained by
evaluating the _value_.  If the _expression_ is a tuple, the _value_
must be a tuple with the same number of elements.  (Nested tuples are
allowed.)  Assignment is performed from each part of the _value_ to the
corresponding part of the _expression_.  For example:

  1. (a, _, (b, c)) = ("test", 9.45, (12, 3))
  2. // a is "test", b is 12, c is 3, and 9.45 is ignored

   The assignment operator does not return any value.

   Grammar of an assignment operator

   assignment-operator → ‘=’

   *** Ternary Conditional Operator

   The _ternary conditional operator_ evaluates to one of two given
values based on the value of a condition.  It has the following form:

  1. condition ?  expression used if true : expression used if false

   If the _condition_ evaluates to ‘true’, the conditional operator
evaluates the first expression and returns its value.  Otherwise, it
evaluates the second expression and returns its value.  The unused
expression is not evaluated.

   For an example that uses the ternary conditional operator, see *note
Ternary Conditional Operator: (swift)Ternary Conditional Operator.

   Grammar of a conditional operator

   conditional-operator → ‘?’ expression ‘:’


File: swift-reference.info,  Node: Type-Casting Operators,  Prev: Assignment Operator,  Up: Binary Expressions

5.2.2 Type-Casting Operators
----------------------------

There are four type-casting operators: the ‘is’ operator, the ‘as’
operator, the ‘as?’ operator, and the ‘as!’ operator.

   They have the following form:

  1. expression is type
  2. expression as type
  3. expression as?  type
  4. expression as!  type

   The ‘is’ operator checks at runtime whether the _expression_ can be
cast to the specified _type_.  It returns ‘true’ if the _expression_ can
be cast to the specified _type_; otherwise, it returns ‘false’.

   The ‘as’ operator performs a cast when it is known at compile time
that the cast always succeeds, such as upcasting or bridging.  Upcasting
lets you use an expression as an instance of its type’s supertype,
without using an intermediate variable.  The following approaches are
equivalent:

  1. func f(_ any: Any) { print("Function for Any") }
  2. func f(_ int: Int) { print("Function for Int") }
  3. let x = 10
  4. f(x)
  5. // Prints "Function for Int"
  6. 
  7. let y: Any = x
  8. f(y)
  9. // Prints "Function for Any"
  10. 
  11. f(x as Any)
  12. // Prints "Function for Any"

   Bridging lets you use an expression of a Swift standard library type
such as ‘String’ as its corresponding Foundation type such as ‘NSString’
without needing to create a new instance.  For more information on
bridging, see Working with Foundation Types
(https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types)
[<https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types>].

   The ‘as?’ operator performs a conditional cast of the _expression_ to
the specified _type_.  The ‘as?’ operator returns an optional of the
specified _type_.  At runtime, if the cast succeeds, the value of
_expression_ is wrapped in an optional and returned; otherwise, the
value returned is ‘nil’.  If casting to the specified _type_ is
guaranteed to fail or is guaranteed to succeed, a compile-time error is
raised.

   The ‘as!’ operator performs a forced cast of the _expression_ to the
specified _type_.  The ‘as!’ operator returns a value of the specified
_type_, not an optional type.  If the cast fails, a runtime error is
raised.  The behavior of ‘x as! T’ is the same as the behavior of ‘(x
as? T)!’.

   For more information about type casting and to see examples that use
the type-casting operators, see *note Type Casting: (swift)Type Casting.

   Grammar of a type-casting operator

   type-casting-operator → ‘is’ type

   type-casting-operator → ‘as’ type

   type-casting-operator → ‘as’ ‘?’ type

   type-casting-operator → ‘as’ ‘!’ type


File: swift-reference.info,  Node: Primary Expressions,  Next: Postfix Expressions,  Prev: Binary Expressions,  Up: Expressions

5.3 Primary Expressions
=======================

_Primary expressions_ are the most basic kind of expression.  They can
be used as expressions on their own, and they can be combined with other
tokens to make prefix expressions, binary expressions, and postfix
expressions.

   Grammar of a primary expression

   primary-expression → identifier generic-argument-clause _{opt}

   primary-expression → literal-expression

   primary-expression → self-expression

   primary-expression → superclass-expression

   primary-expression → closure-expression

   primary-expression → parenthesized-expression

   primary-expression → tuple-expression

   primary-expression → implicit-member-expression

   primary-expression → wildcard-expression

   primary-expression → key-path-expression

   primary-expression → selector-expression

   primary-expression → key-path-string-expression

* Menu:

* Literal Expression::
* Self Expression::
* Superclass Expression::
* Closure Expression::
* Implicit Member Expression::
* Parenthesized Expression::
* Tuple Expression::
* Wildcard Expression::
* Key-Path Expression::
* Selector Expression::
* Key-Path String Expression::


File: swift-reference.info,  Node: Literal Expression,  Next: Self Expression,  Up: Primary Expressions

5.3.1 Literal Expression
------------------------

A _literal expression_ consists of either an ordinary literal (such as a
string or a number), an array or dictionary literal, a playground
literal, or one of the following special literals:

Literal        Type                 Value
------------------------------------------------------------------------------------------------------
‘#file’        ‘String’             The name of the file in which it appears.
‘#line’        ‘Int’                The line number on which it appears.
‘#column’      ‘Int’                The column number in which it begins.
‘#function’    ‘String’             The name of the declaration in which it appears.
‘#dsohandle’   ‘UnsafeRawPointer’   The DSO (dynamic shared object) handle in use where it appears.

   Inside a function, the value of ‘#function’ is the name of that
function, inside a method it is the name of that method, inside a
property getter or setter it is the name of that property, inside
special members like ‘init’ or ‘subscript’ it is the name of that
keyword, and at the top level of a file it is the name of the current
module.

   When used as the default value of a function or method parameter, the
special literal’s value is determined when the default value expression
is evaluated at the call site.

  1. func logFunctionName(string: String = #function) {
  2. print(string)
  3. }
  4. func myFunction() {
  5. logFunctionName() // Prints "myFunction()".
  6. }

   An _array literal_ is an ordered collection of values.  It has the
following form:

  1. [value 1, value 2, ...]

   The last expression in the array can be followed by an optional
comma.  The value of an array literal has type ‘[T]’, where ‘T’ is the
type of the expressions inside it.  If there are expressions of multiple
types, ‘T’ is their closest common supertype.  Empty array literals are
written using an empty pair of square brackets and can be used to create
an empty array of a specified type.

  1. var emptyArray: [Double] = []

   A _dictionary literal_ is an unordered collection of key-value pairs.
It has the following form:

  1. [key 1: value 1, key 2: value 2, ...]

   The last expression in the dictionary can be followed by an optional
comma.  The value of a dictionary literal has type ‘[Key: Value]’, where
‘Key’ is the type of its key expressions and ‘Value’ is the type of its
value expressions.  If there are expressions of multiple types, ‘Key’
and ‘Value’ are the closest common supertype for their respective
values.  An empty dictionary literal is written as a colon inside a pair
of brackets (‘[:]’) to distinguish it from an empty array literal.  You
can use an empty dictionary literal to create an empty dictionary
literal of specified key and value types.

  1. var emptyDictionary: [String: Double] = [:]

   A _playground literal_ is used by Xcode to create an interactive
representation of a color, file, or image within the program editor.
Playground literals in plain text outside of Xcode are represented using
a special literal syntax.

   For information on using playground literals in Xcode, see file, or
image literal
[<https://help.apple.com/xcode/mac/current/#/dev4c60242fc>] in Xcode
Help.

   Grammar of a literal expression

   literal-expression → literal

   literal-expression → array-literal
   dictionary-literal
   playground-literal

   literal-expression → ‘#file’ | ‘#line’ | ‘#column’ | ‘#function’ |
‘#dsohandle’

   array-literal → ‘[’ array-literal-items _{opt} ‘]’

   array-literal-items → array-literal-item =,=_opt | array-literal-item
‘,’ array-literal-items

   array-literal-item → expression

   dictionary-literal → ‘[’ dictionary-literal-items ‘]’ | ‘[’ ‘:’ ‘]’

   dictionary-literal-items → dictionary-literal-item =,=_opt |
dictionary-literal-item ‘,’ dictionary-literal-items

   dictionary-literal-item → expression ‘:’ expression

   playground-literal → ‘#colorLiteral’ ‘(’ ‘red’ ‘:’ expression ‘,’
‘green’ ‘:’ expression ‘,’ ‘blue’ ‘:’ expression ‘,’ ‘alpha’ ‘:’
expression ‘)’

   playground-literal → ‘#fileLiteral’ ‘(’ ‘resourceName’ ‘:’ expression
‘)’

   playground-literal → ‘#imageLiteral’ ‘(’ ‘resourceName’ ‘:’
expression ‘)’


File: swift-reference.info,  Node: Self Expression,  Next: Superclass Expression,  Prev: Literal Expression,  Up: Primary Expressions

5.3.2 Self Expression
---------------------

The ‘self’ expression is an explicit reference to the current type or
instance of the type in which it occurs.  It has the following forms:

  1. self
  2. self.member name
  3. self[subscript index]
  4. self(initializer arguments)
  5. self.init(initializer arguments)

   In an initializer, subscript, or instance method, ‘self’ refers to
the current instance of the type in which it occurs.  In a type method,
‘self’ refers to the current type in which it occurs.

   The ‘self’ expression is used to specify scope when accessing
members, providing disambiguation when there is another variable of the
same name in scope, such as a function parameter.  For example:

  1. class SomeClass {
  2. var greeting: String
  3. init(greeting: String) {
  4. self.greeting = greeting
  5. }
  6. }

   In a mutating method of a value type, you can assign a new instance
of that value type to ‘self’.  For example:

  1. struct Point {
  2. var x = 0.0, y = 0.0
  3. mutating func moveBy(x deltaX: Double, y deltaY: Double) {
  4. self = Point(x: x + deltaX, y: y + deltaY)
  5. }
  6. }

   Grammar of a self expression

   self-expression → ‘self’ | self-method-expression
   self-subscript-expression
   self-initializer-expression

   self-method-expression → ‘self’ ‘.’ identifier

   self-subscript-expression → ‘self’ ‘[’ function-call-argument-list
‘]’

   self-initializer-expression → ‘self’ ‘.’  ‘init’


File: swift-reference.info,  Node: Superclass Expression,  Next: Closure Expression,  Prev: Self Expression,  Up: Primary Expressions

5.3.3 Superclass Expression
---------------------------

A _superclass expression_ lets a class interact with its superclass.  It
has one of the following forms:

  1. super.member name
  2. super[subscript index]
  3. super.init(initializer arguments)

   The first form is used to access a member of the superclass.  The
second form is used to access the superclass’s subscript implementation.
The third form is used to access an initializer of the superclass.

   Subclasses can use a superclass expression in their implementation of
members, subscripting, and initializers to make use of the
implementation in their superclass.

   Grammar of a superclass expression

   superclass-expression → superclass-method-expression
   superclass-subscript-expression
   superclass-initializer-expression

   superclass-method-expression → ‘super’ ‘.’ identifier

   superclass-subscript-expression → ‘super’ ‘[’
function-call-argument-list ‘]’

   superclass-initializer-expression → ‘super’ ‘.’  ‘init’


File: swift-reference.info,  Node: Closure Expression,  Next: Implicit Member Expression,  Prev: Superclass Expression,  Up: Primary Expressions

5.3.4 Closure Expression
------------------------

A _closure expression_ creates a closure, also known as a _lambda_ or an
_anonymous function_ in other programming languages.  Like a function
declaration, a closure contains statements, and it captures constants
and variables from its enclosing scope.  It has the following form:

  1. { (parameters) -> return type in
  2. statements
  3. }

   The _parameters_ have the same form as the parameters in a function
declaration, as described in *note Function Declaration: Function
Declaration.

   There are several special forms that allow closures to be written
more concisely:

   • A closure can omit the types of its parameters, its return type, or
     both.  If you omit the parameter names and both types, omit the
     ‘in’ keyword before the statements.  If the omitted types can’t be
     inferred, a compile-time error is raised.

   • A closure may omit names for its parameters.  Its parameters are
     then implicitly named ‘$’ followed by their position: ‘$0’, ‘$1’,
     ‘$2’, and so on.

   • A closure that consists of only a single expression is understood
     to return the value of that expression.  The contents of this
     expression are also considered when performing type inference on
     the surrounding expression.

   The following closure expressions are equivalent:

  1. myFunction { (x: Int, y: Int) -> Int in
  2. return x + y
  3. }
  4. 
  5. myFunction { x, y in
  6. return x + y
  7. }
  8. 
  9. myFunction { return $0 + $1 }
  10. 
  11. myFunction { $0 + $1 }

   For information about passing a closure as an argument to a function,
see *note Function Call Expression::.

   Closure expressions can be used without being stored in a variable or
constant, such as when you immediately use a closure as part of a
function call.  The closure expressions passed to ‘myFunction’ in code
above are examples of this kind of immediate use.  As a result, whether
a closure expression is escaping or nonescaping depends on the
surrounding context of the expression.  A closure expression is
nonescaping if it is called immediately or passed as a nonescaping
function argument.  Otherwise, the closure expression is escaping.

   For more information about escaping closures, see *note Escaping
Closures: (swift)Escaping Closures.

  1. Capture Lists

     By default, a closure expression captures constants and variables
     from its surrounding scope with strong references to those values.
     You can use a _capture list_ to explicitly control how values are
     captured in a closure.

     A capture list is written as a comma-separated list of expressions
     surrounded by square brackets, before the list of parameters.  If
     you use a capture list, you must also use the ‘in’ keyword, even if
     you omit the parameter names, parameter types, and return type.

     The entries in the capture list are initialized when the closure is
     created.  For each entry in the capture list, a constant is
     initialized to the value of the constant or variable that has the
     same name in the surrounding scope.  For example in the code below,
     ‘a’ is included in the capture list but ‘b’ is not, which gives
     them different behavior.

       1. var a = 0
       2. var b = 0
       3. let closure = { [a] in
       4. print(a, b)
       5. }
       6. 
       7. a = 10
       8. b = 10
       9. closure()
       10. // Prints "0 10"

     There are two different things named ‘a’, the variable in the
     surrounding scope and the constant in the closure’s scope, but only
     one variable named ‘b’.  The ‘a’ in the inner scope is initialized
     with the value of the ‘a’ in the outer scope when the closure is
     created, but their values are not connected in any special way.
     This means that a change to the value of ‘a’ in the outer scope
     does not affect the value of ‘a’ in the inner scope, nor does a
     change to ‘a’ inside the closure affect the value of ‘a’ outside
     the closure.  In contrast, there is only one variable named ‘b’—the
     ‘b’ in the outer scope—so changes from inside or outside the
     closure are visible in both places.

     This distinction is not visible when the captured variable’s type
     has reference semantics.  For example, there are two things named
     ‘x’ in the code below, a variable in the outer scope and a constant
     in the inner scope, but they both refer to the same object because
     of reference semantics.

       1. class SimpleClass {
       2. var value: Int = 0
       3. }
       4. var x = SimpleClass()
       5. var y = SimpleClass()
       6. let closure = { [x] in
       7. print(x.value, y.value)
       8. }
       9. 
       10. x.value = 10
       11. y.value = 10
       12. closure()
       13. // Prints "10 10"

     If the type of the expression’s value is a class, you can mark the
     expression in a capture list with ‘weak’ or ‘unowned’ to capture a
     weak or unowned reference to the expression’s value.

       1. myFunction { print(self.title) } // implicit strong capture
       2. myFunction { [self] in print(self.title) } // explicit strong
          capture
       3. myFunction { [weak self] in print(self!.title) } // weak
          capture
       4. myFunction { [unowned self] in print(self.title) } // unowned
          capture

     You can also bind an arbitrary expression to a named value in a
     capture list.  The expression is evaluated when the closure is
     created, and the value is captured with the specified strength.
     For example:

       1. // Weak capture of "self.parent" as "parent"
       2. myFunction { [weak parent = self.parent] in
          print(parent!.title) }

     For more information and examples of closure expressions, see *note
     Closure Expressions: (swift)Closure Expressions.  For more
     information and examples of capture lists, see *note Resolving
     Strong Reference Cycles for Closures: (swift)Resolving Strong
     Reference Cycles for Closures.

     Grammar of a closure expression

     closure-expression → ‘{’ closure-signature _{opt} statements _{opt}
     ‘}’

     closure-signature → capture-list _{opt} closure-parameter-clause
     =throws=_opt function-result _{opt} ‘in’

     closure-signature → capture-list ‘in’

     closure-parameter-clause → ‘(’ ‘)’ | ‘(’ closure-parameter-list ‘)’
     | identifier-list

     closure-parameter-list → closure-parameter
     closure-parameter ‘,’ closure-parameter-list

     closure-parameter → closure-parameter-name type-annotation _{opt}

     closure-parameter → closure-parameter-name type-annotation ‘...’

     closure-parameter-name → identifier

     capture-list → ‘[’ capture-list-items ‘]’

     capture-list-items → capture-list-item
     capture-list-item ‘,’ capture-list-items

     capture-list-item → capture-specifier _{opt} expression

     capture-specifier → ‘weak’ | ‘unowned’ | ‘unowned(safe)’ |
     ‘unowned(unsafe)’


File: swift-reference.info,  Node: Implicit Member Expression,  Next: Parenthesized Expression,  Prev: Closure Expression,  Up: Primary Expressions

5.3.5 Implicit Member Expression
--------------------------------

An _implicit member expression_ is an abbreviated way to access a member
of a type, such as an enumeration case or a type method, in a context
where type inference can determine the implied type.  It has the
following form:

  1. .member name

   For example:

  1. var x = MyEnumeration.someValue
  2. x = .anotherValue

   Grammar of a implicit member expression

   implicit-member-expression → ‘.’ identifier


File: swift-reference.info,  Node: Parenthesized Expression,  Next: Tuple Expression,  Prev: Implicit Member Expression,  Up: Primary Expressions

5.3.6 Parenthesized Expression
------------------------------

A _parenthesized expression_ consists of an expression surrounded by
parentheses.  You can use parentheses to specify the precedence of
operations by explicitly grouping expressions.  Grouping parentheses
don’t change an expression’s type—for example, the type of ‘(1)’ is
simply ‘Int’.

   Grammar of a parenthesized expression

   parenthesized-expression → ‘(’ expression ‘)’


File: swift-reference.info,  Node: Tuple Expression,  Next: Wildcard Expression,  Prev: Parenthesized Expression,  Up: Primary Expressions

5.3.7 Tuple Expression
----------------------

A _tuple expression_ consists of a comma-separated list of expressions
surrounded by parentheses.  Each expression can have an optional
identifier before it, separated by a colon (‘:’).  It has the following
form:

  1. (identifier 1: expression 1, identifier 2: expression 2, ...)

   Each identifier in a tuple expression must be unique within the scope
of the tuple expression.  In a nested tuple expression, identifiers at
the same level of nesting must be unique.  For example, ‘(a: 10, a: 20)’
is invalid because the label ‘a’ appears twice at the same level.
However, ‘(a: 10, b: (a: 1, x: 2))’ is valid—although ‘a’ appears twice,
it appears once in the outer tuple and once in the inner tuple.

   A tuple expression can contain zero expressions, or it can contain
two or more expressions.  A single expression inside parentheses is a
parenthesized expression.

   Note

   Both an empty tuple expression and an empty tuple type are written
‘()’ in Swift.  Because ‘Void’ is a type alias for ‘()’, you can use it
to write an empty tuple type.  However, like all type aliases, ‘Void’ is
always a type—you can’t use it to write an empty tuple expression.

   Grammar of a tuple expression

   tuple-expression → ‘(’ ‘)’
‘(’
   tuple-element ‘,’ tuple-element-list ‘)’

   tuple-element-list → tuple-element
   tuple-element ‘,’ tuple-element-list

   tuple-element → expression
   identifier ‘:’ expression


File: swift-reference.info,  Node: Wildcard Expression,  Next: Key-Path Expression,  Prev: Tuple Expression,  Up: Primary Expressions

5.3.8 Wildcard Expression
-------------------------

A _wildcard expression_ is used to explicitly ignore a value during an
assignment.  For example, in the following assignment 10 is assigned to
‘x’ and 20 is ignored:

  1. (x, _) = (10, 20)
  2. // x is 10, and 20 is ignored

   Grammar of a wildcard expression

   wildcard-expression → ‘_’


File: swift-reference.info,  Node: Key-Path Expression,  Next: Selector Expression,  Prev: Wildcard Expression,  Up: Primary Expressions

5.3.9 Key-Path Expression
-------------------------

A _key-path expression_ refers to a property or subscript of a type.
You use key-path expressions in dynamic programming tasks, such as
key-value observing.  They have the following form:

  1. name.path

   The _type name_ is the name of a concrete type, including any generic
parameters, such as ‘String’, ‘[Int]’, or ‘Set<Int>’.

   The _path_ consists of property names, subscripts, optional-chaining
expressions, and forced unwrapping expressions.  Each of these key-path
components can be repeated as many times as needed, in any order.

   At compile time, a key-path expression is replaced by an instance of
the ‘KeyPath’ (https://developer.apple.com/documentation/swift/keypath)
[<https://developer.apple.com/documentation/swift/keypath>] class.

   To access a value using a key path, pass the key path to the
‘subscript(keyPath:)’ subscript, which is available on all types.  For
example:

  1. struct SomeStructure {
  2. var someValue: Int
  3. }
  4. 
  5. let s = SomeStructure(someValue: 12)
  6. let pathToProperty = .someValue
  7. 
  8. let value = s[keyPath: pathToProperty]
  9. // value is 12

   The _type name_ can be omitted in contexts where type inference can
determine the implied type.  The following code uses ‘\.someProperty’
instead of ‘\SomeClass.someProperty’:

  1. class SomeClass: NSObject {
  2. @objc dynamic var someProperty: Int
  3. init(someProperty: Int) {
  4. self.someProperty = someProperty
  5. }
  6. }
  7. 
  8. let c = SomeClass(someProperty: 10)
  9. c.observe(\.someProperty) { object, change in
  10. // ...
  11. }

   The _path_ can refer to ‘self’ to create the identity key path
(‘\.self’).  The identity key path refers to a whole instance, so you
can use it to access and change all of the data stored in a variable in
a single step.  For example:

  1. var compoundValue = (a: 1, b: 2)
  2. // Equivalent to compoundValue = (a: 10, b: 20)
  3. compoundValue[keyPath: \.self] = (a: 10, b: 20)

   The _path_ can contain multiple property names, separated by periods,
to refer to a property of a property’s value.  This code uses the key
path expression ‘\OuterStructure.outer.someValue’ to access the
‘someValue’ property of the ‘OuterStructure’ type’s ‘outer’ property:

  1. struct OuterStructure {
  2. var outer: SomeStructure
  3. init(someValue: Int) {
  4. self.outer = SomeStructure(someValue: someValue)
  5. }
  6. }
  7. 
  8. let nested = OuterStructure(someValue: 24)
  9. let nestedKeyPath = .outer.someValue
  10. 
  11. let nestedValue = nested[keyPath: nestedKeyPath]
  12. // nestedValue is 24

   The _path_ can include subscripts using brackets, as long as the
subscript’s parameter type conforms to the ‘Hashable’ protocol.  This
example uses a subscript in a key path to access the second element of
an array:

  1. let greetings = ["hello", "hola", "bonjour", "안녕"]
  2. let myGreeting = greetings[keyPath: \[String].[1]]
  3. // myGreeting is ’hola’

   The value used in a subscript can be a named value or a literal.
Values are captured in key paths using value semantics.  The following
code uses the variable ‘index’ in both a key-path expression and in a
closure to access the third element of the ‘greetings’ array.  When
‘index’ is modified, the key-path expression still references the third
element, while the closure uses the new index.

  1. var index = 2
  2. let path = \[String].[index]
  3. let fn: ([String]) -> String = { strings in strings[index] }
  4. 
  5. print(greetings[keyPath: path])
  6. // Prints "bonjour"
  7. print(fn(greetings))
  8. // Prints "bonjour"
  9. 
  10. // Setting ’index’ to a new value doesn’t affect ’path’
  11. index += 1
  12. print(greetings[keyPath: path])
  13. // Prints "bonjour"
  14. 
  15. // Because ’fn’ closes over ’index’, it uses the new value
  16. print(fn(greetings))
  17. // Prints "안녕"

   The _path_ can use optional chaining and forced unwrapping.  This
code uses optional chaining in a key path to access a property of an
optional string:

  1. let firstGreeting: String?  = greetings.first
  2. print(firstGreeting?.count as Any)
  3. // Prints "Optional(5)"
  4. 
  5. // Do the same thing using a key path.
  6. let count = greetings[keyPath: \[String].first?.count]
  7. print(count as Any)
  8. // Prints "Optional(5)"

   You can mix and match components of key paths to access values that
are deeply nested within a type.  The following code accesses different
values and properties of a dictionary of arrays by using key-path
expressions that combine these components.

  1. let interestingNumbers = ["prime": [2, 3, 5, 7, 11, 13, 17],
  2. "triangular": [1, 3, 6, 10, 15, 21, 28],
  3. "hexagonal": [1, 6, 15, 28, 45, 66, 91]]
  4. print(interestingNumbers[keyPath: \[String: [Int]].["prime"]] as
     Any)
  5. // Prints "Optional([2, 3, 5, 7, 11, 13, 17])"
  6. print(interestingNumbers[keyPath: \[String: [Int]].["prime"]![0]])
  7. // Prints "2"
  8. print(interestingNumbers[keyPath: \[String:
     [Int]].["hexagonal"]!.count])
  9. // Prints "7"
  10. print(interestingNumbers[keyPath: \[String:
     [Int]].["hexagonal"]!.count.bitWidth])
  11. // Prints "64"

   For more information about using key paths in code that interacts
with Objective-C APIs, see Using Objective-C Runtime Features in Swift
(https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift)
[<https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift>].
For information about key-value coding and key-value observing, see
Key-Value Coding Programming Guide
(https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i)
[<https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i>]
and Key-Value Observing Programming Guide
(https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i)
[<https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i>].

   Grammar of a key-path expression

   key-path-expression → ‘\’ type _{opt} ‘.’ key-path-components

   key-path-components → key-path-component
   key-path-component ‘.’ key-path-components

   key-path-component → identifier key-path-postfixes _{opt} |
key-path-postfixes

   key-path-postfixes → key-path-postfix key-path-postfixes _{opt}

   key-path-postfix → ‘?’ | ‘!’ | ‘self’ | ‘[’
function-call-argument-list ‘]’


File: swift-reference.info,  Node: Selector Expression,  Next: Key-Path String Expression,  Prev: Key-Path Expression,  Up: Primary Expressions

5.3.10 Selector Expression
--------------------------

A selector expression lets you access the selector used to refer to a
method or to a property’s getter or setter in Objective-C. It has the
following form:

  1. #selector(method name)
  2. #selector(getter: property name)
  3. #selector(setter: property name)

   The _method name_ and _property name_ must be a reference to a method
or a property that is available in the Objective-C runtime.  The value
of a selector expression is an instance of the ‘Selector’ type.  For
example:

  1. class SomeClass: NSObject {
  2. @objc let property: String
  3. @objc(doSomethingWithInt:)
  4. func doSomething(_ x: Int) {}
  5. 
  6. init(property: String) {
  7. self.property = property
  8. }
  9. }
  10. let selectorForMethod = #selector(SomeClass.doSomething(_:))
  11. let selectorForPropertyGetter = #selector(getter:
     SomeClass.property)

   When creating a selector for a property’s getter, the _property name_
can be a reference to a variable or constant property.  In contrast,
when creating a selector for a property’s setter, the _property name_
must be a reference to a variable property only.

   The _method name_ can contain parentheses for grouping, as well the
‘as’ operator to disambiguate between methods that share a name but have
different type signatures.  For example:

  1. extension SomeClass {
  2. @objc(doSomethingWithString:)
  3. func doSomething(_ x: String) { }
  4. }
  5. let anotherSelector = #selector(SomeClass.doSomething(_:) as
     (SomeClass) -> (String) -> Void)

   Because a selector is created at compile time, not at runtime, the
compiler can check that a method or property exists and that they’re
exposed to the Objective-C runtime.

   Note

   Although the _method name_ and the _property name_ are expressions,
they’re never evaluated.

   For more information about using selectors in Swift code that
interacts with Objective-C APIs, see Using Objective-C Runtime Features
in Swift
(https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift)
[<https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift>].

   Grammar of a selector expression

   selector-expression → ‘#selector’ ‘(’ expression ‘)’

   selector-expression → ‘#selector’ ‘(’ ‘getter:’ expression ‘)’

   selector-expression → ‘#selector’ ‘(’ ‘setter:’ expression ‘)’


File: swift-reference.info,  Node: Key-Path String Expression,  Prev: Selector Expression,  Up: Primary Expressions

5.3.11 Key-Path String Expression
---------------------------------

A key-path string expression lets you access the string used to refer to
a property in Objective-C, for use in key-value coding and key-value
observing APIs.  It has the following form:

  1. #keyPath(property name)

   The _property name_ must be a reference to a property that is
available in the Objective-C runtime.  At compile time, the key-path
string expression is replaced by a string literal.  For example:

  1. class SomeClass: NSObject {
  2. @objc var someProperty: Int
  3. init(someProperty: Int) {
  4. self.someProperty = someProperty
  5. }
  6. }
  7. 
  8. let c = SomeClass(someProperty: 12)
  9. let keyPath = #keyPath(SomeClass.someProperty)
  10. 
  11. if let value = c.value(forKey: keyPath) {
  12. print(value)
  13. }
  14. // Prints "12"

   When you use a key-path string expression within a class, you can
refer to a property of that class by writing just the property name,
without the class name.

  1. extension SomeClass {
  2. func getSomeKeyPath() -> String {
  3. return #keyPath(someProperty)
  4. }
  5. }
  6. print(keyPath == c.getSomeKeyPath())
  7. // Prints "true"

   Because the key path string is created at compile time, not at
runtime, the compiler can check that the property exists and that the
property is exposed to the Objective-C runtime.

   For more information about using key paths in Swift code that
interacts with Objective-C APIs, see Using Objective-C Runtime Features
in Swift
(https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift)
[<https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift>].
For information about key-value coding and key-value observing, see
Key-Value Coding Programming Guide
(https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i)
[<https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i>]
and Key-Value Observing Programming Guide
(https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i)
[<https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i>].

   Note

   Although the _property name_ is an expression, it is never evaluated.

   Grammar of a key-path string expression

   key-path-string-expression → ‘#keyPath’ ‘(’ expression ‘)’


File: swift-reference.info,  Node: Postfix Expressions,  Prev: Primary Expressions,  Up: Expressions

5.4 Postfix Expressions
=======================

_Postfix expressions_ are formed by applying a postfix operator or other
postfix syntax to an expression.  Syntactically, every primary
expression is also a postfix expression.

   For information about the behavior of these operators, see *note
Basic Operators: (swift)Basic Operators. and *note Advanced Operators:
(swift)Advanced Operators.

   For information about the operators provided by the Swift standard
library, see Operator Declarations
(https://developer.apple.com/documentation/swift/operator_declarations)
[<https://developer.apple.com/documentation/swift/operator_declarations>].

   Grammar of a postfix expression

   postfix-expression → primary-expression

   postfix-expression → postfix-expression postfix-operator

   postfix-expression → function-call-expression

   postfix-expression → initializer-expression

   postfix-expression → explicit-member-expression

   postfix-expression → postfix-self-expression

   postfix-expression → subscript-expression

   postfix-expression → forced-value-expression

   postfix-expression → optional-chaining-expression

* Menu:

* Function Call Expression::
* Initializer Expression::
* Explicit Member Expression::
* Postfix Self Expression::
* Subscript Expression::
* Forced-Value Expression::
* Optional-Chaining Expression::


File: swift-reference.info,  Node: Function Call Expression,  Next: Initializer Expression,  Up: Postfix Expressions

5.4.1 Function Call Expression
------------------------------

A _function call expression_ consists of a function name followed by a
comma-separated list of the function’s arguments in parentheses.
Function call expressions have the following form:

  1. function name(argument value 1, argument value 2)

   The _function name_ can be any expression whose value is of a
function type.

   If the function definition includes names for its parameters, the
function call must include names before its argument values separated by
a colon (‘:’).  This kind of function call expression has the following
form:

  1. function name(argument name 1: argument value 1, argument name 2:
     argument value 2)

   A function call expression can include a trailing closure in the form
of a closure expression immediately after the closing parenthesis.  The
trailing closure is understood as an argument to the function, added
after the last parenthesized argument.  The following function calls are
equivalent:

  1. // someFunction takes an integer and a closure as its arguments
  2. someFunction(x: x, f: {$0 == 13})
  3. someFunction(x: x) {$0 == 13}

   If the trailing closure is the function’s only argument, the
parentheses can be omitted.

  1. // someMethod takes a closure as its only argument
  2. myData.someMethod() {$0 == 13}
  3. myData.someMethod {$0 == 13}

   A class, structure, or enumeration type can enable syntactic sugar
for function call syntax by declaring one of several methods, as
described in *note Methods with Special Names::.

   Grammar of a function call expression

   function-call-expression → postfix-expression
function-call-argument-clause

   function-call-expression → postfix-expression
function-call-argument-clause _{opt} trailing-closure

   function-call-argument-clause → ‘(’ ‘)’ | ‘(’
function-call-argument-list ‘)’

   function-call-argument-list → function-call-argument
   function-call-argument ‘,’ function-call-argument-list

   function-call-argument → expression
   identifier ‘:’ expression

   function-call-argument → operator
   identifier ‘:’ operator

   trailing-closure → closure-expression


File: swift-reference.info,  Node: Initializer Expression,  Next: Explicit Member Expression,  Prev: Function Call Expression,  Up: Postfix Expressions

5.4.2 Initializer Expression
----------------------------

An _initializer expression_ provides access to a type’s initializer.  It
has the following form:

  1. expression.init(initializer arguments)

   You use the initializer expression in a function call expression to
initialize a new instance of a type.  You also use an initializer
expression to delegate to the initializer of a superclass.

  1. class SomeSubClass: SomeSuperClass {
  2. override init() {
  3. // subclass initialization goes here
  4. super.init()
  5. }
  6. }

   Like a function, an initializer can be used as a value.  For example:

  1. // Type annotation is required because String has multiple
     initializers.
  2. let initializer: (Int) -> String = String.init
  3. let oneTwoThree = [1, 2, 3].map(initializer).reduce("", +)
  4. print(oneTwoThree)
  5. // Prints "123"

   If you specify a type by name, you can access the type’s initializer
without using an initializer expression.  In all other cases, you must
use an initializer expression.

  1. let s1 = SomeType.init(data: 3) // Valid
  2. let s2 = SomeType(data: 1) // Also valid
  3. 
  4. let s3 = type(of: someValue).init(data: 7) // Valid
  5. let s4 = type(of: someValue)(data: 5) // Error

   Grammar of an initializer expression

   initializer-expression → postfix-expression ‘.’  ‘init’

   initializer-expression → postfix-expression ‘.’  ‘init’ ‘(’
argument-names ‘)’


File: swift-reference.info,  Node: Explicit Member Expression,  Next: Postfix Self Expression,  Prev: Initializer Expression,  Up: Postfix Expressions

5.4.3 Explicit Member Expression
--------------------------------

An _explicit member expression_ allows access to the members of a named
type, a tuple, or a module.  It consists of a period (‘.’) between the
item and the identifier of its member.

  1. expression.member name

   The members of a named type are named as part of the type’s
declaration or extension.  For example:

  1. class SomeClass {
  2. var someProperty = 42
  3. }
  4. let c = SomeClass()
  5. let y = c.someProperty // Member access

   The members of a tuple are implicitly named using integers in the
order they appear, starting from zero.  For example:

  1. var t = (10, 20, 30)
  2. t.0 = t.1
  3. // Now t is (20, 20, 30)

   The members of a module access the top-level declarations of that
module.

   Types declared with the ‘dynamicMemberLookup’ attribute include
members that are looked up at runtime, as described in *note
Attributes::.

   To distinguish between methods or initializers whose names differ
only by the names of their arguments, include the argument names in
parentheses, with each argument name followed by a colon (‘:’).  Write
an underscore (‘_’) for an argument with no name.  To distinguish
between overloaded methods, use a type annotation.  For example:

  1. class SomeClass {
  2. func someMethod(x: Int, y: Int) {}
  3. func someMethod(x: Int, z: Int) {}
  4. func overloadedMethod(x: Int, y: Int) {}
  5. func overloadedMethod(x: Int, y: Bool) {}
  6. }
  7. let instance = SomeClass()
  8. 
  9. let a = instance.someMethod // Ambiguous
  10. let b = instance.someMethod(x:y:) // Unambiguous
  11. 
  12. let d = instance.overloadedMethod // Ambiguous
  13. let d = instance.overloadedMethod(x:y:) // Still ambiguous
  14. let d: (Int, Bool) -> Void = instance.overloadedMethod(x:y:) //
     Unambiguous

   If a period appears at the beginning of a line, it is understood as
part of an explicit member expression, not as an implicit member
expression.  For example, the following listing shows chained method
calls split over several lines:

  1. let x = [10, 3, 20, 15, 4]
  2. .sorted()
  3. .filter { $0 > 5 }
  4. .map { $0 * 100 }

   Grammar of an explicit member expression

   explicit-member-expression → postfix-expression ‘.’ decimal-digits

   explicit-member-expression → postfix-expression ‘.’ identifier
generic-argument-clause _{opt}

   explicit-member-expression → postfix-expression ‘.’ identifier ‘(’
argument-names ‘)’

   argument-names → argument-name argument-names _{opt}

   argument-name → identifier ‘:’


File: swift-reference.info,  Node: Postfix Self Expression,  Next: Subscript Expression,  Prev: Explicit Member Expression,  Up: Postfix Expressions

5.4.4 Postfix Self Expression
-----------------------------

A postfix ‘self’ expression consists of an expression or the name of a
type, immediately followed by ‘.self’.  It has the following forms:

  1. expression.self
  2. type.self

   The first form evaluates to the value of the _expression_.  For
example, ‘x.self’ evaluates to ‘x’.

   The second form evaluates to the value of the _type_.  Use this form
to access a type as a value.  For example, because ‘SomeClass.self’
evaluates to the ‘SomeClass’ type itself, you can pass it to a function
or method that accepts a type-level argument.

   Grammar of a postfix self expression

   postfix-self-expression → postfix-expression ‘.’  ‘self’


File: swift-reference.info,  Node: Subscript Expression,  Next: Forced-Value Expression,  Prev: Postfix Self Expression,  Up: Postfix Expressions

5.4.5 Subscript Expression
--------------------------

A _subscript expression_ provides subscript access using the getter and
setter of the corresponding subscript declaration.  It has the following
form:

  1. expression[index expressions]

   To evaluate the value of a subscript expression, the subscript getter
for the _expression_’s type is called with the _index expressions_
passed as the subscript parameters.  To set its value, the subscript
setter is called in the same way.

   For information about subscript declarations, see *note Protocol
Subscript Declaration::X.

   Grammar of a subscript expression

   subscript-expression → postfix-expression ‘[’
function-call-argument-list ‘]’


File: swift-reference.info,  Node: Forced-Value Expression,  Next: Optional-Chaining Expression,  Prev: Subscript Expression,  Up: Postfix Expressions

5.4.6 Forced-Value Expression
-----------------------------

A _forced-value expression_ unwraps an optional value that you are
certain is not ‘nil’.  It has the following form:

  1. expression!

   If the value of the _expression_ is not ‘nil’, the optional value is
unwrapped and returned with the corresponding non-optional type.
Otherwise, a runtime error is raised.

   The unwrapped value of a forced-value expression can be modified,
either by mutating the value itself, or by assigning to one of the
value’s members.  For example:

  1. var x: Int?  = 0
  2. x!  += 1
  3. // x is now 1
  4. 
  5. var someDictionary = ["a": [1, 2, 3], "b": [10, 20]]
  6. someDictionary["a"]![0] = 100
  7. // someDictionary is now ["a": [100, 2, 3], "b": [10, 20]]

   Grammar of a forced-value expression

   forced-value-expression → postfix-expression ‘!’


File: swift-reference.info,  Node: Optional-Chaining Expression,  Prev: Forced-Value Expression,  Up: Postfix Expressions

5.4.7 Optional-Chaining Expression
----------------------------------

An _optional-chaining expression_ provides a simplified syntax for using
optional values in postfix expressions.  It has the following form:

  1. expression?

   The postfix ‘?’ operator makes an optional-chaining expression from
an expression without changing the expression’s value.

   Optional-chaining expressions must appear within a postfix
expression, and they cause the postfix expression to be evaluated in a
special way.  If the value of the optional-chaining expression is ‘nil’,
all of the other operations in the postfix expression are ignored and
the entire postfix expression evaluates to ‘nil’.  If the value of the
optional-chaining expression is not ‘nil’, the value of the
optional-chaining expression is unwrapped and used to evaluate the rest
of the postfix expression.  In either case, the value of the postfix
expression is still of an optional type.

   If a postfix expression that contains an optional-chaining expression
is nested inside other postfix expressions, only the outermost
expression returns an optional type.  In the example below, when ‘c’ is
not ‘nil’, its value is unwrapped and used to evaluate ‘.property’, the
value of which is used to evaluate ‘.performAction()’.  The entire
expression ‘c?.property.performAction()’ has a value of an optional
type.

  1. var c: SomeClass?
  2. var result: Bool?  = c?.property.performAction()

   The following example shows the behavior of the example above without
using optional chaining.

  1. var result: Bool?
  2. if let unwrappedC = c {
  3. result = unwrappedC.property.performAction()
  4. }

   The unwrapped value of an optional-chaining expression can be
modified, either by mutating the value itself, or by assigning to one of
the value’s members.  If the value of the optional-chaining expression
is ‘nil’, the expression on the right-hand side of the assignment
operator is not evaluated.  For example:

  1. func someFunctionWithSideEffects() -> Int {
  2. return 42 // No actual side effects.
  3. }
  4. var someDictionary = ["a": [1, 2, 3], "b": [10, 20]]
  5. 
  6. someDictionary["not here"]?[0] = someFunctionWithSideEffects()
  7. // someFunctionWithSideEffects is not evaluated
  8. // someDictionary is still ["a": [1, 2, 3], "b": [10, 20]]
  9. 
  10. someDictionary["a"]?[0] = someFunctionWithSideEffects()
  11. // someFunctionWithSideEffects is evaluated and returns 42
  12. // someDictionary is now ["a": [42, 2, 3], "b": [10, 20]]

   Grammar of an optional-chaining expression

   optional-chaining-expression → postfix-expression ‘?’


File: swift-reference.info,  Node: Statements,  Next: Declarations,  Prev: Expressions,  Up: Top

6 Statements
************

In Swift, there are three kinds of statements: simple statements,
compiler control statements, and control flow statements.  Simple
statements are the most common and consist of either an expression or a
declaration.  Compiler control statements allow the program to change
aspects of the compiler’s behavior and include a conditional compilation
block and a line control statement.

   Control flow statements are used to control the flow of execution in
a program.  There are several types of control flow statements in Swift,
including loop statements, branch statements, and control transfer
statements.  Loop statements allow a block of code to be executed
repeatedly, branch statements allow a certain block of code to be
executed only when certain conditions are met, and control transfer
statements provide a way to alter the order in which code is executed.
In addition, Swift provides a ‘do’ statement to introduce scope, and
catch and handle errors, and a ‘defer’ statement for running cleanup
actions just before the current scope exits.

   A semicolon (‘;’) can optionally appear after any statement and is
used to separate multiple statements if they appear on the same line.

   Grammar of a statement

   statement → expression =;=_opt

   statement → declaration =;=_opt

   statement → loop-statement =;=_opt

   statement → branch-statement =;=_opt

   statement → labeled-statement =;=_opt

   statement → control-transfer-statement =;=_opt

   statement → defer-statement =;=_opt

   statement → do-statement =;=_opt

   statement → compiler-control-statement

   statements → statement statements _{opt}

* Menu:

* Loop Statements::
* Labeled Statement::
* Control Transfer Statements::
* Defer Statement::
* Do Statement::
* Compiler Control Statements::
* Availability Condition::


File: swift-reference.info,  Node: Loop Statements,  Next: Labeled Statement,  Up: Statements

6.1 Loop Statements
===================

Loop statements allow a block of code to be executed repeatedly,
depending on the conditions specified in the loop.  Swift has three loop
statements: a ‘for’-‘in’ statement, a ‘while’ statement, and a
‘repeat’-‘while’ statement.

   Control flow in a loop statement can be changed by a ‘break’
statement and a ‘continue’ statement and is discussed in *note Break
Statement:: and *note Continue Statement:: below.

   Grammar of a loop statement

   loop-statement → for-in-statement

   loop-statement → while-statement

   loop-statement → repeat-while-statement

* Menu:

* For-In Statement::
* While Statement::
* Repeat-While Statement::
* Branch Statements::
* If Statement::
* Guard Statement::


File: swift-reference.info,  Node: For-In Statement,  Next: While Statement,  Up: Loop Statements

6.1.1 For-In Statement
----------------------

A ‘for’-‘in’ statement allows a block of code to be executed once for
each item in a collection (or any type) that conforms to the ‘Sequence’
(https://developer.apple.com/documentation/swift/sequence)
[<https://developer.apple.com/documentation/swift/sequence>] protocol.

   A ‘for’-‘in’ statement has the following form:

  1. for item in collection {
  2. statements
  3. }

   The ‘makeIterator()’ method is called on the _collection_ expression
to obtain a value of an iterator type—that is, a type that conforms to
the ‘IteratorProtocol’
(https://developer.apple.com/documentation/swift/iteratorprotocol)
[<https://developer.apple.com/documentation/swift/iteratorprotocol>]
protocol.  The program begins executing a loop by calling the ‘next()’
method on the iterator.  If the value returned is not ‘nil’, it is
assigned to the _item_ pattern, the program executes the _statements_,
and then continues execution at the beginning of the loop.  Otherwise,
the program does not perform assignment or execute the _statements_, and
it is finished executing the ‘for’-‘in’ statement.

   Grammar of a for-in statement

   for-in-statement → ‘for’ ‘case=_{opt} pattern =in’ expression
where-clause _{opt} code-block


File: swift-reference.info,  Node: While Statement,  Next: Repeat-While Statement,  Prev: For-In Statement,  Up: Loop Statements

6.1.2 While Statement
---------------------

A ‘while’ statement allows a block of code to be executed repeatedly, as
long as a condition remains true.

   A ‘while’ statement has the following form:

  1. while condition {
  2. statements
  3. }

   A ‘while’ statement is executed as follows:

  1. The _condition_ is evaluated.

     If ‘true’, execution continues to step 2.  If ‘false’, the program
     is finished executing the ‘while’ statement.

  2. The program executes the _statements_, and execution returns to
     step
       1. 
   Because the value of the _condition_ is evaluated before the
_statements_ are executed, the _statements_ in a ‘while’ statement can
be executed zero or more times.

   The value of the _condition_ must be of type ‘Bool’ or a type bridged
to ‘Bool’.  The condition can also be an optional binding declaration,
as discussed in *note Optional Binding: (swift)Optional Binding.

   Grammar of a while statement

   while-statement → ‘while’ condition-list code-block

   condition-list → condition | condition ‘,’ condition-list

   condition → expression
   availability-condition
   case-condition
   optional-binding-condition

   case-condition → ‘case’ pattern initializer

   optional-binding-condition → ‘let’ pattern initializer
‘var’ pattern
   initializer


File: swift-reference.info,  Node: Repeat-While Statement,  Next: Branch Statements,  Prev: While Statement,  Up: Loop Statements

6.1.3 Repeat-While Statement
----------------------------

A ‘repeat’-‘while’ statement allows a block of code to be executed one
or more times, as long as a condition remains true.

   A ‘repeat’-‘while’ statement has the following form:

  1. repeat {
  2. statements
  3. } while condition

   A ‘repeat’-‘while’ statement is executed as follows:

  1. The program executes the _statements_, and execution continues to
     step 2.

  2. The _condition_ is evaluated.

     If ‘true’, execution returns to step 1.  If ‘false’, the program is
     finished executing the ‘repeat’-‘while’ statement.

   Because the value of the _condition_ is evaluated after the
_statements_ are executed, the _statements_ in a ‘repeat’-‘while’
statement are executed at least once.

   The value of the _condition_ must be of type ‘Bool’ or a type bridged
to ‘Bool’.  The condition can also be an optional binding declaration,
as discussed in *note Optional Binding: (swift)Optional Binding.

   Grammar of a repeat-while statement

   repeat-while-statement → ‘repeat’ code-block ‘while’ expression


File: swift-reference.info,  Node: Branch Statements,  Next: If Statement,  Prev: Repeat-While Statement,  Up: Loop Statements

6.1.4 Branch Statements
-----------------------

Branch statements allow the program to execute certain parts of code
depending on the value of one or more conditions.  The values of the
conditions specified in a branch statement control how the program
branches and, therefore, what block of code is executed.  Swift has
three branch statements: an ‘if’ statement, a ‘guard’ statement, and a
‘switch’ statement.

   Control flow in an ‘if’ statement or a ‘switch’ statement can be
changed by a ‘break’ statement and is discussed in *note Break
Statement:: below.

   Grammar of a branch statement

   branch-statement → if-statement

   branch-statement → guard-statement

   branch-statement → switch-statement


File: swift-reference.info,  Node: If Statement,  Next: Guard Statement,  Prev: Branch Statements,  Up: Loop Statements

6.1.5 If Statement
------------------

An ‘if’ statement is used for executing code based on the evaluation of
one or more conditions.

   There are two basic forms of an ‘if’ statement.  In each form, the
opening and closing braces are required.

   The first form allows code to be executed only when a condition is
true and has the following form:

  1. if condition {
  2. statements
  3. }

   The second form of an ‘if’ statement provides an additional _else
clause_ (introduced by the ‘else’ keyword) and is used for executing one
part of code when the condition is true and another part of code when
the same condition is false.  When a single else clause is present, an
‘if’ statement has the following form:

  1. if condition {
  2. statements to execute if condition is true
  3. } else {
  4. statements to execute if condition is false
  5. }

   The else clause of an ‘if’ statement can contain another ‘if’
statement to test more than one condition.  An ‘if’ statement chained
together in this way has the following form:

  1. if condition 1 {
  2. statements to execute if condition 1 is true
  3. } else if condition 2 {
  4. statements to execute if condition 2 is true
  5. } else {
  6. statements to execute if both conditions are false
  7. }

   The value of any condition in an ‘if’ statement must be of type
‘Bool’ or a type bridged to ‘Bool’.  The condition can also be an
optional binding declaration, as discussed in *note Optional Binding:
(swift)Optional Binding.

   Grammar of an if statement

   if-statement → ‘if’ condition-list code-block else-clause _{opt}

   else-clause → ‘else’ code-block
‘else’
   if-statement


File: swift-reference.info,  Node: Guard Statement,  Prev: If Statement,  Up: Loop Statements

6.1.6 Guard Statement
---------------------

A ‘guard’ statement is used to transfer program control out of a scope
if one or more conditions aren’t met.

   A ‘guard’ statement has the following form:

  1. guard condition else {
  2. statements
  3. }

   The value of any condition in a ‘guard’ statement must be of type
‘Bool’ or a type bridged to ‘Bool’.  The condition can also be an
optional binding declaration, as discussed in *note Optional Binding:
(swift)Optional Binding.

   Any constants or variables assigned a value from an optional binding
declaration in a ‘guard’ statement condition can be used for the rest of
the guard statement’s enclosing scope.

   The ‘else’ clause of a ‘guard’ statement is required, and must either
call a function with the ‘Never’ return type or transfer program control
outside the guard statement’s enclosing scope using one of the following
statements:

   • ‘return’

   • ‘break’

   • ‘continue’

   • ‘throw’

   Control transfer statements are discussed in *note Control Transfer
Statements:: below.  For more information on functions with the ‘Never’
return type, see *note Functions that Never Return::.

   Grammar of a guard statement

   guard-statement → ‘guard’ condition-list ‘else’ code-block

  1. Switch Statement

     A ‘switch’ statement allows certain blocks of code to be executed
     depending on the value of a control expression.

     A ‘switch’ statement has the following form:

       1. switch control expression {
       2. case pattern 1:
       3. statements
       4. case pattern 2 where condition:
       5. statements
       6. case pattern 3 where condition,
       7. pattern 4 where condition:
       8. statements
       9. default:
       10. statements
       11. }

     The _control expression_ of the ‘switch’ statement is evaluated and
     then compared with the patterns specified in each case.  If a match
     is found, the program executes the _statements_ listed within the
     scope of that case.  The scope of each case can’t be empty.  As a
     result, you must include at least one statement following the colon
     (‘:’) of each case label.  Use a single ‘break’ statement if you
     don’t intend to execute any code in the body of a matched case.

     The values of expressions your code can branch on are very
     flexible.  For example, in addition to the values of scalar types,
     such as integers and characters, your code can branch on the values
     of any type, including floating-point numbers, strings, tuples,
     instances of custom classes, and optionals.  The value of the
     _control expression_ can even be matched to the value of a case in
     an enumeration and checked for inclusion in a specified range of
     values.  For examples of how to use these various types of values
     in ‘switch’ statements, see *note Switch: (swift)Switch. in *note
     Control Flow: (swift)Control Flow.

     A ‘switch’ case can optionally contain a ‘where’ clause after each
     pattern.  A _where clause_ is introduced by the ‘where’ keyword
     followed by an expression, and is used to provide an additional
     condition before a pattern in a case is considered matched to the
     _control expression_.  If a ‘where’ clause is present, the
     _statements_ within the relevant case are executed only if the
     value of the _control expression_ matches one of the patterns of
     the case and the expression of the ‘where’ clause evaluates to
     ‘true’.  For example, a _control expression_ matches the case in
     the example below only if it is a tuple that contains two elements
     of the same value, such as ‘(1, 1)’.

       1. case let (x, y) where x == y:

     As the above example shows, patterns in a case can also bind
     constants using the ‘let’ keyword (they can also bind variables
     using the ‘var’ keyword).  These constants (or variables) can then
     be referenced in a corresponding ‘where’ clause and throughout the
     rest of the code within the scope of the case.  If the case
     contains multiple patterns that match the control expression, all
     of the patterns must contain the same constant or variable
     bindings, and each bound variable or constant must have the same
     type in all of the case’s patterns.

     A ‘switch’ statement can also include a default case, introduced by
     the ‘default’ keyword.  The code within a default case is executed
     only if no other cases match the control expression.  A ‘switch’
     statement can include only one default case, which must appear at
     the end of the ‘switch’ statement.

     Although the actual execution order of pattern-matching operations,
     and in particular the evaluation order of patterns in cases, is
     unspecified, pattern matching in a ‘switch’ statement behaves as if
     the evaluation is performed in source order—that is, the order in
     which they appear in source code.  As a result, if multiple cases
     contain patterns that evaluate to the same value, and thus can
     match the value of the control expression, the program executes
     only the code within the first matching case in source order.

  2. Switch Statements Must Be Exhaustive

     In Swift, every possible value of the control expression’s type
     must match the value of at least one pattern of a case.  When this
     simply isn’t feasible (for example, when the control expression’s
     type is ‘Int’), you can include a default case to satisfy the
     requirement.

       1. Switching Over Future Enumeration Cases

          A _nonfrozen enumeration_ is a special kind of enumeration
          that may gain new enumeration cases in the future—even after
          you compile and ship an app.  Switching over a nonfrozen
          enumeration requires extra consideration.  When a library’s
          authors mark an enumeration as nonfrozen, they reserve the
          right to add new enumeration cases, and any code that
          interacts with that enumeration _must_ be able to handle those
          future cases without being recompiled.  Code that’s compiled
          in library evolution mode, code in the standard library, Swift
          overlays for Apple frameworks, and C and Objective-C code can
          declare nonfrozen enumerations.  For information about frozen
          and nonfrozen enumerations, see *note frozen::.

          When switching over a nonfrozen enumeration value, you always
          need to include a default case, even if every case of the
          enumeration already has a corresponding switch case.  You can
          apply the ‘@unknown’ attribute to the default case, which
          indicates that the default case should match only enumeration
          cases that are added in the future.  Swift produces a warning
          if the default case matches any enumeration case that is known
          at compiler time.  This future warning informs you that the
          library author added a new case to the enumeration that
          doesn’t have a corresponding switch case.

          The following example switches over all three existing cases
          of the standard library’s ‘Mirror.AncestorRepresentation’
          (https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation)
          [<https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation>]
          enumeration.  If you add additional cases in the future, the
          compiler generates a warning to indicate that you need to
          update the switch statement to take the new cases into
          account.

               let representation: Mirror.AncestorRepresentation = .generated
               switch representation {
               case .customized:
                   print("Use the nearest ancestor's implementation.")
               case .generated:
                   print("Generate a default mirror for all ancestor classes.")
               case .suppressed:
                   print("Suppress the representation of all ancestor classes.")
               @unknown default:
                   print("Use a representation that was unknown when this code was compiled.")
               }
               // Prints "Generate a default mirror for all ancestor classes."

  3. Execution Does Not Fall Through Cases Implicitly

     After the code within a matched case has finished executing, the
     program exits from the ‘switch’ statement.  Program execution does
     not continue or “fall through” to the next case or default case.
     That said, if you want execution to continue from one case to the
     next, explicitly include a ‘fallthrough’ statement, which simply
     consists of the ‘fallthrough’ keyword, in the case from which you
     want execution to continue.  For more information about the
     ‘fallthrough’ statement, see *note Fallthrough Statement:: below.

     Grammar of a switch statement

     switch-statement → ‘switch’ expression ‘{’ switch-cases _{opt} ‘}’

     switch-cases → switch-case switch-cases _{opt}

     switch-case → case-label statements

     switch-case → default-label statements

     switch-case → conditional-switch-case

     case-label → attributes _{opt} ‘case’ case-item-list ‘:’

     case-item-list → pattern where-clause _{opt} | pattern where-clause
     _{opt} ‘,’ case-item-list

     default-label → attributes _{opt} ‘default’ ‘:’

     where-clause → ‘where’ where-expression

     where-expression → expression

     conditional-switch-case → switch-if-directive-clause
     switch-elseif-directive-clauses _{opt} switch-else-directive-clause
     _{opt} endif-directive

     switch-if-directive-clause → if-directive compilation-condition
     switch-cases _{opt}

     switch-elseif-directive-clauses → elseif-directive-clause
     switch-elseif-directive-clauses _{opt}

     switch-elseif-directive-clause → elseif-directive
     compilation-condition switch-cases _{opt}

     switch-else-directive-clause → else-directive switch-cases _{opt}


File: swift-reference.info,  Node: Labeled Statement,  Next: Control Transfer Statements,  Prev: Loop Statements,  Up: Statements

6.2 Labeled Statement
=====================

You can prefix a loop statement, an ‘if’ statement, a ‘switch’
statement, or a ‘do’ statement with a _statement label_, which consists
of the name of the label followed immediately by a colon (:).  Use
statement labels with ‘break’ and ‘continue’ statements to be explicit
about how you want to change control flow in a loop statement or a
‘switch’ statement, as discussed in *note Break Statement: Break
Statement. and *note Continue Statement:: below.

   The scope of a labeled statement is the entire statement following
the statement label.  You can nest labeled statements, but the name of
each statement label must be unique.

   For more information and to see examples of how to use statement
labels, see *note Labeled Statements: (swift)Labeled Statements. in
*note Control Flow: (swift)Control Flow.

   Grammar of a labeled statement

   labeled-statement → statement-label loop-statement

   labeled-statement → statement-label if-statement

   labeled-statement → statement-label switch-statement

   labeled-statement → statement-label do-statement

   statement-label → label-name ‘:’

   label-name → identifier


File: swift-reference.info,  Node: Control Transfer Statements,  Next: Defer Statement,  Prev: Labeled Statement,  Up: Statements

6.3 Control Transfer Statements
===============================

Control transfer statements can change the order in which code in your
program is executed by unconditionally transferring program control from
one piece of code to another.  Swift has five control transfer
statements: a ‘break’ statement, a ‘continue’ statement, a ‘fallthrough’
statement, a ‘return’ statement, and a ‘throw’ statement.

   Grammar of a control transfer statement

   control-transfer-statement → break-statement

   control-transfer-statement → continue-statement

   control-transfer-statement → fallthrough-statement

   control-transfer-statement → return-statement

   control-transfer-statement → throw-statement

* Menu:

* Break Statement::
* Continue Statement::
* Fallthrough Statement::
* Return Statement::
* Throw Statement::


File: swift-reference.info,  Node: Break Statement,  Next: Continue Statement,  Up: Control Transfer Statements

6.3.1 Break Statement
---------------------

A ‘break’ statement ends program execution of a loop, an ‘if’ statement,
or a ‘switch’ statement.  A ‘break’ statement can consist of only the
‘break’ keyword, or it can consist of the ‘break’ keyword followed by
the name of a statement label, as shown below.

  1. break
  2. break label name

   When a ‘break’ statement is followed by the name of a statement
label, it ends program execution of the loop, ‘if’ statement, or
‘switch’ statement named by that label.

   When a ‘break’ statement is not followed by the name of a statement
label, it ends program execution of the ‘switch’ statement or the
innermost enclosing loop statement in which it occurs.  You can’t use an
unlabeled ‘break’ statement to break out of an ‘if’ statement.

   In both cases, program control is then transferred to the first line
of code following the enclosing loop or ‘switch’ statement, if any.

   For examples of how to use a ‘break’ statement, see *note Break:
(swift)Break. and *note Labeled Statements: (swift)Labeled Statements.
in *note Control Flow: (swift)Control Flow.

   Grammar of a break statement

   break-statement → ‘break’ label-name _{opt}


File: swift-reference.info,  Node: Continue Statement,  Next: Fallthrough Statement,  Prev: Break Statement,  Up: Control Transfer Statements

6.3.2 Continue Statement
------------------------

A ‘continue’ statement ends program execution of the current iteration
of a loop statement but does not stop execution of the loop statement.
A ‘continue’ statement can consist of only the ‘continue’ keyword, or it
can consist of the ‘continue’ keyword followed by the name of a
statement label, as shown below.

  1. continue
  2. continue label name

   When a ‘continue’ statement is followed by the name of a statement
label, it ends program execution of the current iteration of the loop
statement named by that label.

   When a ‘continue’ statement is not followed by the name of a
statement label, it ends program execution of the current iteration of
the innermost enclosing loop statement in which it occurs.

   In both cases, program control is then transferred to the condition
of the enclosing loop statement.

   In a ‘for’ statement, the increment expression is still evaluated
after the ‘continue’ statement is executed, because the increment
expression is evaluated after the execution of the loop’s body.

   For examples of how to use a ‘continue’ statement, see *note
Continue: (swift)Continue. and *note Labeled Statements: (swift)Labeled
Statements. in *note Control Flow: (swift)Control Flow.

   Grammar of a continue statement

   continue-statement → ‘continue’ label-name _{opt}


File: swift-reference.info,  Node: Fallthrough Statement,  Next: Return Statement,  Prev: Continue Statement,  Up: Control Transfer Statements

6.3.3 Fallthrough Statement
---------------------------

A ‘fallthrough’ statement consists of the ‘fallthrough’ keyword and
occurs only in a case block of a ‘switch’ statement.  A ‘fallthrough’
statement causes program execution to continue from one case in a
‘switch’ statement to the next case.  Program execution continues to the
next case even if the patterns of the case label do not match the value
of the ‘switch’ statement’s control expression.

   A ‘fallthrough’ statement can appear anywhere inside a ‘switch’
statement, not just as the last statement of a case block, but it can’t
be used in the final case block.  It also cannot transfer control into a
case block whose pattern contains value binding patterns.

   For an example of how to use a ‘fallthrough’ statement in a ‘switch’
statement, see *note Control Transfer Statements: Control Transfer
Statements. in *note Control Flow: (swift)Control Flow.

   Grammar of a fallthrough statement

   fallthrough-statement → ‘fallthrough’


File: swift-reference.info,  Node: Return Statement,  Next: Throw Statement,  Prev: Fallthrough Statement,  Up: Control Transfer Statements

6.3.4 Return Statement
----------------------

A ‘return’ statement occurs in the body of a function or method
definition and causes program execution to return to the calling
function or method.  Program execution continues at the point
immediately following the function or method call.

   A ‘return’ statement can consist of only the ‘return’ keyword, or it
can consist of the ‘return’ keyword followed by an expression, as shown
below.

  1. return
  2. return expression

   When a ‘return’ statement is followed by an expression, the value of
the expression is returned to the calling function or method.  If the
value of the expression does not match the value of the return type
declared in the function or method declaration, the expression’s value
is converted to the return type before it is returned to the calling
function or method.

   Note

   As described in *note Failable Initializers::, a special form of the
‘return’ statement (‘return nil’) can be used in a failable initializer
to indicate initialization failure.

   When a ‘return’ statement is not followed by an expression, it can be
used only to return from a function or method that does not return a
value (that is, when the return type of the function or method is ‘Void’
or ‘()’).

   Grammar of a return statement

   return-statement → ‘return’ expression _{opt}


File: swift-reference.info,  Node: Throw Statement,  Prev: Return Statement,  Up: Control Transfer Statements

6.3.5 Throw Statement
---------------------

A ‘throw’ statement occurs in the body of a throwing function or method,
or in the body of a closure expression whose type is marked with the
‘throws’ keyword.

   A ‘throw’ statement causes a program to end execution of the current
scope and begin error propagation to its enclosing scope.  The error
that’s thrown continues to propagate until it’s handled by a ‘catch’
clause of a ‘do’ statement.

   A ‘throw’ statement consists of the ‘throw’ keyword followed by an
expression, as shown below.

  1. throw expression

   The value of the _expression_ must have a type that conforms to the
‘Error’ protocol.

   For an example of how to use a ‘throw’ statement, see *note
Propagating Errors Using Throwing Functions: (swift)Propagating Errors
Using Throwing Functions. in *note Error Handling: (swift)Error
Handling.

   Grammar of a throw statement

   throw-statement → ‘throw’ expression


File: swift-reference.info,  Node: Defer Statement,  Next: Do Statement,  Prev: Control Transfer Statements,  Up: Statements

6.4 Defer Statement
===================

A ‘defer’ statement is used for executing code just before transferring
program control outside of the scope that the ‘defer’ statement appears
in.

   A ‘defer’ statement has the following form:

  1. defer {
  2. statements
  3. }

   The statements within the ‘defer’ statement are executed no matter
how program control is transferred.  This means that a ‘defer’ statement
can be used, for example, to perform manual resource management such as
closing file descriptors, and to perform actions that need to happen
even if an error is thrown.

   If multiple ‘defer’ statements appear in the same scope, the order
they appear is the reverse of the order they are executed.  Executing
the last ‘defer’ statement in a given scope first means that statements
inside that last ‘defer’ statement can refer to resources that will be
cleaned up by other ‘defer’ statements.

  1. func f() {
  2. defer { print("First defer") }
  3. defer { print("Second defer") }
  4. print("End of function")
  5. }
  6. f()
  7. // Prints "End of function"
  8. // Prints "Second defer"
  9. // Prints "First defer"

   The statements in the ‘defer’ statement can’t transfer program
control outside of the ‘defer’ statement.

   Grammar of a defer statement

   defer-statement → ‘defer’ code-block


File: swift-reference.info,  Node: Do Statement,  Next: Compiler Control Statements,  Prev: Defer Statement,  Up: Statements

6.5 Do Statement
================

The ‘do’ statement is used to introduce a new scope and can optionally
contain one or more ‘catch’ clauses, which contain patterns that match
against defined error conditions.  Variables and constants declared in
the scope of a ‘do’ statement can be accessed only within that scope.

   A ‘do’ statement in Swift is similar to curly braces (‘{}’) in C used
to delimit a code block, and does not incur a performance cost at
runtime.

   A ‘do’ statement has the following form:

  1. do {
  2. try expression
  3. statements
  4. } catch pattern 1 {
  5. statements
  6. } catch pattern 2 where condition {
  7. statements
  8. }

   Like a ‘switch’ statement, the compiler attempts to infer whether
‘catch’ clauses are exhaustive.  If such a determination can be made,
the error is considered handled.  Otherwise, the error can propagate out
of the containing scope, which means the error must be handled by an
enclosing ‘catch’ clause or the containing function must be declared
with ‘throws’.

   To ensure that an error is handled, use a ‘catch’ clause with a
pattern that matches all errors, such as a wildcard pattern (‘_’).  If a
‘catch’ clause does not specify a pattern, the ‘catch’ clause matches
and binds any error to a local constant named ‘error’.  For more
information about the patterns you can use in a ‘catch’ clause, see
*note Patterns::.

   To see an example of how to use a ‘do’ statement with several ‘catch’
clauses, see *note Handling Errors: (swift)Handling Errors.

   Grammar of a do statement

   do-statement → ‘do’ code-block catch-clauses _{opt}

   catch-clauses → catch-clause catch-clauses _{opt}

   catch-clause → ‘catch’ pattern _{opt} where-clause _{opt} code-block


File: swift-reference.info,  Node: Compiler Control Statements,  Next: Availability Condition,  Prev: Do Statement,  Up: Statements

6.6 Compiler Control Statements
===============================

Compiler control statements allow the program to change aspects of the
compiler’s behavior.  Swift has three compiler control statements: a
conditional compilation block a line control statement, and a
compile-time diagnostic statement.

   Grammar of a compiler control statement

   compiler-control-statement → conditional-compilation-block

   compiler-control-statement → line-control-statement

   compiler-control-statement → diagnostic-statement

* Menu:

* Conditional Compilation Block::
* Line Control Statement::
* Compile-Time Diagnostic Statement::


File: swift-reference.info,  Node: Conditional Compilation Block,  Next: Line Control Statement,  Up: Compiler Control Statements

6.6.1 Conditional Compilation Block
-----------------------------------

A conditional compilation block allows code to be conditionally compiled
depending on the value of one or more compilation conditions.

   Every conditional compilation block begins with the ‘#if’ compilation
directive and ends with the ‘#endif’ compilation directive.  A simple
conditional compilation block has the following form:

  1. #if compilation condition
  2. statements
  3. #endif

   Unlike the condition of an ‘if’ statement, the _compilation
condition_ is evaluated at compile time.  As a result, the _statements_
are compiled and executed only if the _compilation condition_ evaluates
to ‘true’ at compile time.

   The _compilation condition_ can include the ‘true’ and ‘false’
Boolean literals, an identifier used with the ‘-D’ command line flag, or
any of the platform conditions listed in the table below.

Platform condition      Valid arguments
---------------------------------------------------------------------
‘os()’                  ‘macOS’, ‘iOS’, ‘watchOS’, ‘tvOS’, ‘Linux’
‘arch()’                ‘i386’, ‘x86_64’, ‘arm’, ‘arm64’
‘swift()’               ‘>=’ or ‘<’ followed by a version number
‘compiler()’            ‘>=’ or ‘<’ followed by a version number
‘canImport()’           A module name
‘targetEnvironment()’   ‘simulator’, ‘macCatalyst’

   The version number for the ‘swift()’ and ‘compiler()’ platform
conditions consists of a major number, optional minor number, optional
patch number, and so on, with a dot (‘.’) separating each part of the
version number.  There must not be whitespace between the comparison
operator and the version number.  The version for ‘compiler()’ is the
compiler version, regardless of the Swift version setting passed to the
compiler.  The version for ‘swift()’ is the language version currently
being compiled.  For example, if you compile your code using the Swift 5
compiler in Swift 4.2 mode, the compiler version is 5 and the language
version is 4.2.  With those settings, the following code prints all
three messages:

  1. #if compiler(>=5)
  2. print("Compiled with the Swift 5 compiler or later")
  3. #endif
  4. #if swift(>=4.2)
  5. print("Compiled in Swift 4.2 mode or later")
  6. #endif
  7. #if compiler(>=5) && swift(<5)
  8. print("Compiled with the Swift 5 compiler or later in a Swift mode
     earlier than 5")
  9. #endif
  10. // Prints "Compiled with the Swift 5 compiler or later"
  11. // Prints "Compiled in Swift 4.2 mode or later"
  12. // Prints "Compiled with the Swift 5 compiler or later in a Swift
     mode earlier than 5"

   The argument for the ‘canImport()’ platform condition is the name of
a module that may not be present on all platforms.  This condition tests
whether it’s possible to import the module, but doesn’t actually import
it.  If the module is present, the platform condition returns ‘true’;
otherwise, it returns ‘false’.

   The ‘targetEnvironment()’ platform condition returns ‘true’ when code
is compiled for a simulator; otherwise, it returns ‘false’.

   Note

   The ‘arch(arm)’ platform condition does not return ‘true’ for ARM 64
devices.  The ‘arch(i386)’ platform condition returns ‘true’ when code
is compiled for the 32–bit iOS simulator.

   You can combine compilation conditions using the logical operators
‘&&’, ‘||’, and ‘!’ and use parentheses for grouping.  These operators
have the same associativity and precedence as the logical operators that
are used to combine ordinary Boolean expressions.

   Similar to an ‘if’ statement, you can add multiple conditional
branches to test for different compilation conditions.  You can add any
number of additional branches using ‘#elseif’ clauses.  You can also add
a final additional branch using an ‘#else’ clause.  Conditional
compilation blocks that contain multiple branches have the following
form:

  1. #if compilation condition 1
  2. statements to compile if compilation condition 1 is true
  3. #elseif compilation condition 2
  4. statements to compile if compilation condition 2 is true
  5. #else
  6. statements to compile if both compilation conditions are false
  7. #endif

   Note

   Each statement in the body of a conditional compilation block is
parsed even if it’s not compiled.  However, there is an exception if the
compilation condition includes a ‘swift()’ platform condition: The
statements are parsed only if the compiler’s version of Swift matches
what is specified in the platform condition.  This exception ensures
that an older compiler doesn’t attempt to parse syntax introduced in a
newer version of Swift.

   Grammar of a conditional compilation block

   conditional-compilation-block → if-directive-clause
elseif-directive-clauses _{opt} else-directive-clause _{opt}
endif-directive

   if-directive-clause → if-directive compilation-condition statements
_{opt}

   elseif-directive-clauses → elseif-directive-clause
elseif-directive-clauses _{opt}

   elseif-directive-clause → elseif-directive compilation-condition
statements _{opt}

   else-directive-clause → else-directive statements _{opt}

   if-directive → ‘#if’

   elseif-directive → ‘#elseif’

   else-directive → ‘#else’

   endif-directive → ‘#endif’

   compilation-condition → platform-condition

   compilation-condition → identifier

   compilation-condition → boolean-literal

   compilation-condition → ‘(’ compilation-condition ‘)’

   compilation-condition → ‘!’ compilation-condition

   compilation-condition → compilation-condition ‘&&’
compilation-condition

   compilation-condition → compilation-condition ‘||’
compilation-condition

   platform-condition → ‘os’ ‘(’ operating-system ‘)’

   platform-condition → ‘arch’ ‘(’ architecture ‘)’

   platform-condition → ‘swift’ ‘(’ ‘>=’ swift-version ‘)’ | ‘swift’ ‘(’
‘<’ swift-version ‘)’

   platform-condition → ‘compiler’ ‘(’ ‘>=’ swift-version ‘)’ |
‘compiler’ ‘(’ ‘<’ swift-version ‘)’

   platform-condition → ‘canImport’ ‘(’ module-name ‘)’

   platform-condition → ‘targetEnvironment’ ‘(’ environment ‘)’

   operating-system → ‘macOS’
‘iOS’   ‘watchOS’   ‘tvOS’

   architecture → ‘i386’ | ‘x86_64’ | ‘arm’ | ‘arm64’

   swift-version → decimal-digits swift-version-continuation _{opt}

   swift-version-continuation → ‘.’ decimal-digits
swift-version-continuation _{opt}

   module-name → identifier

   environment → ‘simulator’ | ‘macCatalyst’


File: swift-reference.info,  Node: Line Control Statement,  Next: Compile-Time Diagnostic Statement,  Prev: Conditional Compilation Block,  Up: Compiler Control Statements

6.6.2 Line Control Statement
----------------------------

A line control statement is used to specify a line number and filename
that can be different from the line number and filename of the source
code being compiled.  Use a line control statement to change the source
code location used by Swift for diagnostic and debugging purposes.

   A line control statement has the following forms:

  1. #sourceLocation(file: filename, line: line number)
  2. #sourceLocation()

   The first form of a line control statement changes the values of the
‘#line’ and ‘#file’ literal expressions, beginning with the line of code
following the line control statement.  The _line number_ changes the
value of ‘#line’ and is any integer literal greater than zero.  The
_filename_ changes the value of ‘#file’ and is a string literal.

   The second form of a line control statement, ‘#sourceLocation()’,
resets the source code location back to the default line numbering and
filename.

   Grammar of a line control statement

   line-control-statement → ‘#sourceLocation’ ‘(’ ‘file:’ file-name ‘,’
‘line:’ line-number ‘)’

   line-control-statement → ‘#sourceLocation’ ‘(’ ‘)’

   line-number → A decimal integer greater than zero

   file-name → static-string-literal


File: swift-reference.info,  Node: Compile-Time Diagnostic Statement,  Prev: Line Control Statement,  Up: Compiler Control Statements

6.6.3 Compile-Time Diagnostic Statement
---------------------------------------

A compile-time diagnostic statement causes the compiler to emit an error
or a warning during compilation.  A compile-time diagnostic statement
has the following forms:

  1. #error("error message")
  2. #warning("warning message")

   The first form emits the _error message_ as a fatal error and
terminates the compilation process.  The second form emits the _warning
message_ as a nonfatal warning and allows compilation to proceed.  You
write the diagnostic message as a static string literal.  Static string
literals can’t use features like string interpolation or concatenation,
but they can use the multiline string literal syntax.

   Grammar of a compile-time diagnostic statement

   diagnostic-statement → ‘#error’ ‘(’ diagnostic-message ‘)’

   diagnostic-statement → ‘#warning’ ‘(’ diagnostic-message ‘)’

   diagnostic-message → static-string-literal


File: swift-reference.info,  Node: Availability Condition,  Prev: Compiler Control Statements,  Up: Statements

6.7 Availability Condition
==========================

An _availability condition_ is used as a condition of an ‘if’, ‘while’,
and ‘guard’ statement to query the availability of APIs at runtime,
based on specified platforms arguments.

   An availability condition has the following form:

  1. if #available(platform name version, ..., *) {
  2. statements to execute if the APIs are available
  3. } else {
  4. fallback statements to execute if the APIs are unavailable
  5. }

   You use an availability condition to execute a block of code,
depending on whether the APIs you want to use are available at runtime.
The compiler uses the information from the availability condition when
it verifies that the APIs in that block of code are available.

   The availability condition takes a comma-separated list of platform
names and versions.  Use ‘iOS’, ‘macOS’, ‘watchOS’, and ‘tvOS’ for the
platform names, and include the corresponding version numbers.  The ‘*’
argument is required and specifies that on any other platform, the body
of the code block guarded by the availability condition executes on the
minimum deployment target specified by your target.

   Unlike Boolean conditions, you can’t combine availability conditions
using logical operators such as ‘&&’ and ‘||’.

   Grammar of an availability condition

   availability-condition → ‘#available’ ‘(’ availability-arguments ‘)’

   availability-arguments → availability-argument
   availability-argument ‘,’ availability-arguments

   availability-argument → platform-name platform-version

   availability-argument → ‘*’

   platform-name → ‘iOS’ | ‘iOSApplicationExtension’

   platform-name → ‘macOS’ | ‘macOSApplicationExtension’

   platform-name → ‘watchOS’

   platform-name → ‘tvOS’

   platform-version → decimal-digits

   platform-version → decimal-digits ‘.’ decimal-digits

   platform-version → decimal-digits ‘.’ decimal-digits ‘.’
decimal-digits


File: swift-reference.info,  Node: Declarations,  Next: Attributes,  Prev: Statements,  Up: Top

7 Declarations
**************

A _declaration_ introduces a new name or construct into your program.
For example, you use declarations to introduce functions and methods, to
introduce variables and constants, and to define enumeration, structure,
class, and protocol types.  You can also use a declaration to extend the
behavior of an existing named type and to import symbols into your
program that are declared elsewhere.

   In Swift, most declarations are also definitions in the sense that
they are implemented or initialized at the same time they are declared.
That said, because protocols don’t implement their members, most
protocol members are declarations only.  For convenience and because the
distinction isn’t that important in Swift, the term _declaration_ covers
both declarations and definitions.

   Grammar of a declaration

   declaration → import-declaration

   declaration → constant-declaration

   declaration → variable-declaration

   declaration → typealias-declaration

   declaration → function-declaration

   declaration → enum-declaration

   declaration → struct-declaration

   declaration → class-declaration

   declaration → protocol-declaration

   declaration → initializer-declaration

   declaration → deinitializer-declaration

   declaration → extension-declaration

   declaration → subscript-declaration

   declaration → operator-declaration

   declaration → precedence-group-declaration

   declarations → declaration declarations _{opt}

* Menu:

* Top-Level Code::
* Code Blocks::
* Import Declaration::
* Constant Declaration::
* Variable Declaration::
* Type Alias Declaration::
* Function Declaration::
* Enumeration Declaration::
* Structure Declaration::
* Class Declaration::
* Protocol Declaration::
* Initializer Declaration::
* Deinitializer Declaration::
* Extension Declaration::
* Subscript Declaration::
* Operator Declaration::
* Precedence Group Declaration::
* Declaration Modifiers::


File: swift-reference.info,  Node: Top-Level Code,  Next: Code Blocks,  Up: Declarations

7.1 Top-Level Code
==================

The top-level code in a Swift source file consists of zero or more
statements, declarations, and expressions.  By default, variables,
constants, and other named declarations that are declared at the
top-level of a source file are accessible to code in every source file
that is part of the same module.  You can override this default behavior
by marking the declaration with an access-level modifier, as described
in *note Access Control Levels::.

   Grammar of a top-level declaration

   top-level-declaration → statements _{opt}


File: swift-reference.info,  Node: Code Blocks,  Next: Import Declaration,  Prev: Top-Level Code,  Up: Declarations

7.2 Code Blocks
===============

A _code block_ is used by a variety of declarations and control
structures to group statements together.  It has the following form:

  1. {
  2. statements
  3. }

   The _statements_ inside a code block include declarations,
expressions, and other kinds of statements and are executed in order of
their appearance in source code.

   Grammar of a code block

   code-block → ‘{’ statements _{opt} ‘}’


File: swift-reference.info,  Node: Import Declaration,  Next: Constant Declaration,  Prev: Code Blocks,  Up: Declarations

7.3 Import Declaration
======================

An _import declaration_ lets you access symbols that are declared
outside the current file.  The basic form imports the entire module; it
consists of the ‘import’ keyword followed by a module name:

  1. import module

   Providing more detail limits which symbols are imported—you can
specify a specific submodule or a specific declaration within a module
or submodule.  When this detailed form is used, only the imported symbol
(and not the module that declares it) is made available in the current
scope.

  1. import import kind module.symbol name
  2. import module.submodule

   Grammar of an import declaration

   import-declaration → attributes _{opt} ‘import’ import-kind _{opt}
import-path

   import-kind → ‘typealias’ | ‘struct’ | ‘class’ | ‘enum’ | ‘protocol’
| ‘let’ | ‘var’ | ‘func’

   import-path → import-path-identifier
   import-path-identifier ‘.’ import-path

   import-path-identifier → identifier
   operator


File: swift-reference.info,  Node: Constant Declaration,  Next: Variable Declaration,  Prev: Import Declaration,  Up: Declarations

7.4 Constant Declaration
========================

A _constant declaration_ introduces a constant named value into your
program.  Constant declarations are declared using the ‘let’ keyword and
have the following form:

  1. let constant name: type = expression

   A constant declaration defines an immutable binding between the
_constant name_ and the value of the initializer _expression_; after the
value of a constant is set, it cannot be changed.  That said, if a
constant is initialized with a class object, the object itself can
change, but the binding between the constant name and the object it
refers to can’t.

   When a constant is declared at global scope, it must be initialized
with a value.  When a constant declaration occurs in the context of a
function or method, it can be initialized later, as long as it is
guaranteed to have a value set before the first time its value is read.
When a constant declaration occurs in the context of a class or
structure declaration, it is considered a _constant property_.  Constant
declarations are not computed properties and therefore do not have
getters or setters.

   If the _constant name_ of a constant declaration is a tuple pattern,
the name of each item in the tuple is bound to the corresponding value
in the initializer _expression_.

  1. let (firstNumber, secondNumber) = (10, 42)

   In this example, ‘firstNumber’ is a named constant for the value
‘10’, and ‘secondNumber’ is a named constant for the value ‘42’.  Both
constants can now be used independently:

  1. print("The first number is \(firstNumber).")
  2. // Prints "The first number is 10."
  3. print("The second number is \(secondNumber).")
  4. // Prints "The second number is 42."

   The type annotation (‘:’ _type_) is optional in a constant
declaration when the type of the _constant name_ can be inferred, as
described in *note Type Inference::.

   To declare a constant type property, mark the declaration with the
‘static’ declaration modifier.  A constant type property of a class is
always implicitly final; you can’t mark it with the ‘class’ or ‘final’
declaration modifier to allow or disallow overriding by subclasses.
Type properties are discussed in *note Type Properties: (swift)Type
Properties.

   For more information about constants and for guidance about when to
use them, see *note Constants and Variables: (swift)Constants and
Variables. and *note Stored Properties: (swift)Stored Properties.

   Grammar of a constant declaration

   constant-declaration → attributes _{opt} declaration-modifiers _{opt}
‘let’ pattern-initializer-list

   pattern-initializer-list → pattern-initializer
   pattern-initializer ‘,’ pattern-initializer-list

   pattern-initializer → pattern initializer _{opt}

   initializer → ‘=’ expression


File: swift-reference.info,  Node: Variable Declaration,  Next: Type Alias Declaration,  Prev: Constant Declaration,  Up: Declarations

7.5 Variable Declaration
========================

A _variable declaration_ introduces a variable named value into your
program and is declared using the ‘var’ keyword.

   Variable declarations have several forms that declare different kinds
of named, mutable values, including stored and computed variables and
properties, stored variable and property observers, and static variable
properties.  The appropriate form to use depends on the scope at which
the variable is declared and the kind of variable you intend to declare.

   Note

   You can also declare properties in the context of a protocol
declaration, as described in *note Protocol Property Declaration:
Protocol Property Declaration.

   You can override a property in a subclass by marking the subclass’s
property declaration with the ‘override’ declaration modifier, as
described in *note Overriding: (swift)Overriding.

* Menu:

* Stored Variables and Stored Variable Properties::
* Computed Variables and Computed Properties::
* Stored Variable Observers and Property Observers::
* Type Variable Properties::


File: swift-reference.info,  Node: Stored Variables and Stored Variable Properties,  Next: Computed Variables and Computed Properties,  Up: Variable Declaration

7.5.1 Stored Variables and Stored Variable Properties
-----------------------------------------------------

The following form declares a stored variable or stored variable
property:

  1. var variable name: type = expression

   You define this form of a variable declaration at global scope, the
local scope of a function, or in the context of a class or structure
declaration.  When a variable declaration of this form is declared at
global scope or the local scope of a function, it is referred to as a
_stored variable_.  When it is declared in the context of a class or
structure declaration, it is referred to as a _stored variable
property_.

   The initializer _expression_ can’t be present in a protocol
declaration, but in all other contexts, the initializer _expression_ is
optional.  That said, if no initializer _expression_ is present, the
variable declaration must include an explicit type annotation (‘:’
_type_).

   As with constant declarations, if the _variable name_ is a tuple
pattern, the name of each item in the tuple is bound to the
corresponding value in the initializer _expression_.

   As their names suggest, the value of a stored variable or a stored
variable property is stored in memory.


File: swift-reference.info,  Node: Computed Variables and Computed Properties,  Next: Stored Variable Observers and Property Observers,  Prev: Stored Variables and Stored Variable Properties,  Up: Variable Declaration

7.5.2 Computed Variables and Computed Properties
------------------------------------------------

The following form declares a computed variable or computed property:

  1. var variable name: type {
  2. get {
  3. statements
  4. }
  5. set(setter name) {
  6. statements
  7. }
  8. }

   You define this form of a variable declaration at global scope, the
local scope of a function, or in the context of a class, structure,
enumeration, or extension declaration.  When a variable declaration of
this form is declared at global scope or the local scope of a function,
it is referred to as a _computed variable_.  When it is declared in the
context of a class, structure, or extension declaration, it is referred
to as a _computed property_.

   The getter is used to read the value, and the setter is used to write
the value.  The setter clause is optional, and when only a getter is
needed, you can omit both clauses and simply return the requested value
directly, as described in *note Read-Only Computed Properties:
(swift)Read-Only Computed Properties.  But if you provide a setter
clause, you must also provide a getter clause.

   The _setter name_ and enclosing parentheses is optional.  If you
provide a setter name, it is used as the name of the parameter to the
setter.  If you do not provide a setter name, the default parameter name
to the setter is ‘newValue’, as described in *note Shorthand Setter
Declaration: (swift)Shorthand Setter Declaration.

   Unlike stored named values and stored variable properties, the value
of a computed named value or a computed property is not stored in
memory.

   For more information and to see examples of computed properties, see
*note Computed Properties: (swift)Computed Properties.


File: swift-reference.info,  Node: Stored Variable Observers and Property Observers,  Next: Type Variable Properties,  Prev: Computed Variables and Computed Properties,  Up: Variable Declaration

7.5.3 Stored Variable Observers and Property Observers
------------------------------------------------------

You can also declare a stored variable or property with ‘willSet’ and
‘didSet’ observers.  A stored variable or property declared with
observers has the following form:

  1. var variable name: type = expression {
  2. willSet(setter name) {
  3. statements
  4. }
  5. didSet(setter name) {
  6. statements
  7. }
  8. }

   You define this form of a variable declaration at global scope, the
local scope of a function, or in the context of a class or structure
declaration.  When a variable declaration of this form is declared at
global scope or the local scope of a function, the observers are
referred to as _stored variable observers_.  When it is declared in the
context of a class or structure declaration, the observers are referred
to as _property observers_.

   You can add property observers to any stored property.  You can also
add property observers to any inherited property (whether stored or
computed) by overriding the property within a subclass, as described in
*note Overriding Property Observers: (swift)Overriding Property
Observers.

   The initializer _expression_ is optional in the context of a class or
structure declaration, but required elsewhere.  The _type_ annotation is
optional when the type can be inferred from the initializer
_expression_.

   The ‘willSet’ and ‘didSet’ observers provide a way to observe (and to
respond appropriately) when the value of a variable or property is being
set.  The observers are not called when the variable or property is
first initialized.  Instead, they are called only when the value is set
outside of an initialization context.

   A ‘willSet’ observer is called just before the value of the variable
or property is set.  The new value is passed to the ‘willSet’ observer
as a constant, and therefore it can’t be changed in the implementation
of the ‘willSet’ clause.  The ‘didSet’ observer is called immediately
after the new value is set.  In contrast to the ‘willSet’ observer, the
old value of the variable or property is passed to the ‘didSet’ observer
in case you still need access to it.  That said, if you assign a value
to a variable or property within its own ‘didSet’ observer clause, that
new value that you assign will replace the one that was just set and
passed to the ‘willSet’ observer.

   The _setter name_ and enclosing parentheses in the ‘willSet’ and
‘didSet’ clauses are optional.  If you provide setter names, they are
used as the parameter names to the ‘willSet’ and ‘didSet’ observers.  If
you do not provide setter names, the default parameter name to the
‘willSet’ observer is ‘newValue’ and the default parameter name to the
‘didSet’ observer is ‘oldValue’.

   The ‘didSet’ clause is optional when you provide a ‘willSet’ clause.
Likewise, the ‘willSet’ clause is optional when you provide a ‘didSet’
clause.

   For more information and to see an example of how to use property
observers, see *note Property Observers: (swift)Property Observers.


File: swift-reference.info,  Node: Type Variable Properties,  Prev: Stored Variable Observers and Property Observers,  Up: Variable Declaration

7.5.4 Type Variable Properties
------------------------------

To declare a type variable property, mark the declaration with the
‘static’ declaration modifier.  Classes can mark type computed
properties with the ‘class’ declaration modifier instead to allow
subclasses to override the superclass’s implementation.  Type properties
are discussed in *note Type Properties: (swift)Type Properties.

   Note

   In a class declaration, the ‘static’ keyword has the same effect as
marking the declaration with both the ‘class’ and ‘final’ declaration
modifiers.

   Grammar of a variable declaration

   variable-declaration → variable-declaration-head
pattern-initializer-list

   variable-declaration → variable-declaration-head variable-name
type-annotation code-block

   variable-declaration → variable-declaration-head variable-name
type-annotation getter-setter-block

   variable-declaration → variable-declaration-head variable-name
type-annotation getter-setter-keyword-block

   variable-declaration → variable-declaration-head variable-name
initializer willSet-didSet-block

   variable-declaration → variable-declaration-head variable-name
type-annotation initializer _{opt} willSet-didSet-block

   variable-declaration-head → attributes _{opt} declaration-modifiers
_{opt} ‘var’

   variable-name → identifier

   getter-setter-block → code-block

   getter-setter-block → ‘{’ getter-clause setter-clause _{opt} ‘}’

   getter-setter-block → ‘{’ setter-clause getter-clause ‘}’

   getter-clause → attributes _{opt} mutation-modifier _{opt} ‘get’
code-block

   setter-clause → attributes _{opt} mutation-modifier _{opt} ‘set’
setter-name _{opt} code-block

   setter-name → ‘(’ identifier ‘)’

   getter-setter-keyword-block → ‘{’ getter-keyword-clause
setter-keyword-clause _{opt} ‘}’

   getter-setter-keyword-block → ‘{’ setter-keyword-clause
getter-keyword-clause ‘}’

   getter-keyword-clause → attributes _{opt} mutation-modifier _{opt}
‘get’

   setter-keyword-clause → attributes _{opt} mutation-modifier _{opt}
‘set’

   willSet-didSet-block → ‘{’ willSet-clause didSet-clause _{opt} ‘}’

   willSet-didSet-block → ‘{’ didSet-clause willSet-clause _{opt} ‘}’

   willSet-clause → attributes _{opt} ‘willSet’ setter-name _{opt}
code-block

   didSet-clause → attributes _{opt} ‘didSet’ setter-name _{opt}
code-block


File: swift-reference.info,  Node: Type Alias Declaration,  Next: Function Declaration,  Prev: Variable Declaration,  Up: Declarations

7.6 Type Alias Declaration
==========================

A _type alias declaration_ introduces a named alias of an existing type
into your program.  Type alias declarations are declared using the
‘typealias’ keyword and have the following form:

  1. typealias name = existing type

   After a type alias is declared, the aliased _name_ can be used
instead of the _existing type_ everywhere in your program.  The
_existing type_ can be a named type or a compound type.  Type aliases do
not create new types; they simply allow a name to refer to an existing
type.

   A type alias declaration can use generic parameters to give a name to
an existing generic type.  The type alias can provide concrete types for
some or all of the generic parameters of the existing type.  For
example:

  1. typealias StringDictionary<Value> = Dictionary<String, Value>
  2. 
  3. // The following dictionaries have the same type.
  4. var dictionary1: StringDictionary<Int> = [:]
  5. var dictionary2: Dictionary<String, Int> = [:]

   When a type alias is declared with generic parameters, the
constraints on those parameters must match exactly the constraints on
the existing type’s generic parameters.  For example:

  1. typealias DictionaryOfInts<Key: Hashable> = Dictionary<Key, Int>

   Because the type alias and the existing type can be used
interchangeably, the type alias can’t introduce additional generic
constraints.

   A type alias can forward an existing type’s generic parameters by
omitting all generic parameters from the declaration.  For example, the
‘Diccionario’ type alias declared here has the same generic parameters
and constraints as ‘Dictionary’.

  1. typealias Diccionario = Dictionary

   Inside a protocol declaration, a type alias can give a shorter and
more convenient name to a type that is used frequently.  For example:

  1. protocol Sequence {
  2. associatedtype Iterator: IteratorProtocol
  3. typealias Element = Iterator.Element
  4. }
  5. 
  6. func sum<T: Sequence>(_ sequence: T) -> Int where T.Element == Int
     {
  7. // ...
  8. }

   Without this type alias, the ‘sum’ function would have to refer to
the associated type as ‘T.Iterator.Element’ instead of ‘T.Element’.

   See also *note Protocol Associated Type Declaration: Protocol
Associated Type Declaration.

   Grammar of a type alias declaration

   typealias-declaration → attributes _{opt} access-level-modifier
_{opt} ‘typealias’ typealias-name generic-parameter-clause _{opt}
typealias-assignment

   typealias-name → identifier

   typealias-assignment → ‘=’ type


File: swift-reference.info,  Node: Function Declaration,  Next: Enumeration Declaration,  Prev: Type Alias Declaration,  Up: Declarations

7.7 Function Declaration
========================

A _function declaration_ introduces a function or method into your
program.  A function declared in the context of class, structure,
enumeration, or protocol is referred to as a _method_.  Function
declarations are declared using the ‘func’ keyword and have the
following form:

  1. func function name(parameters) -> return type {
  2. statements
  3. }

   If the function has a return type of ‘Void’, the return type can be
omitted as follows:

  1. func function name(parameters) {
  2. statements
  3. }

   The type of each parameter must be included—it can’t be inferred.  If
you write ‘inout’ in front of a parameter’s type, the parameter can be
modified inside the scope of the function.  In-out parameters are
discussed in detail in *note In-Out Parameters::, below.

   Functions can return multiple values using a tuple type as the return
type of the function.

   A function definition can appear inside another function declaration.
This kind of function is known as a _nested function_.

   A nested function is nonescaping if it captures a value that is
guaranteed to never escape—such as an in-out parameter—or passed as a
nonescaping function argument.  Otherwise, the nested function is an
escaping function.

   For a discussion of nested functions, see *note Nested Functions:
(swift)Nested Functions.

* Menu:

* Parameter Names::
* In-Out Parameters::
* Special Kinds of Parameters::
* Special Kinds of Methods::
* Methods with Special Names::
* Throwing Functions and Methods::
* Rethrowing Functions and Methods::
* Functions that Never Return::


File: swift-reference.info,  Node: Parameter Names,  Next: In-Out Parameters,  Up: Function Declaration

7.7.1 Parameter Names
---------------------

Function parameters are a comma-separated list where each parameter has
one of several forms.  The order of arguments in a function call must
match the order of parameters in the function’s declaration.  The
simplest entry in a parameter list has the following form:

  1. parameter name: parameter type

   A parameter has a name, which is used within the function body, as
well as an argument label, which is used when calling the function or
method.  By default, parameter names are also used as argument labels.
For example:

  1. func f(x: Int, y: Int) -> Int { return x + y }
  2. f(x: 1, y: 2) // both x and y are labeled

   You can override the default behavior for argument labels with one of
the following forms:

  1. argument label parameter name: parameter type
  2. _ parameter name: parameter type

   A name before the parameter name gives the parameter an explicit
argument label, which can be different from the parameter name.  The
corresponding argument must use the given argument label in function or
method calls.

   An underscore (‘_’) before a parameter name suppresses the argument
label.  The corresponding argument must have no label in function or
method calls.

  1. func repeatGreeting(_ greeting: String, count n: Int) { _* Greet n
     times *_ }
  2. repeatGreeting("Hello, world!", count: 2) // count is labeled,
     greeting is not


File: swift-reference.info,  Node: In-Out Parameters,  Next: Special Kinds of Parameters,  Prev: Parameter Names,  Up: Function Declaration

7.7.2 In-Out Parameters
-----------------------

In-out parameters are passed as follows:

  1. When the function is called, the value of the argument is copied.

  2. In the body of the function, the copy is modified.

  3. When the function returns, the copy’s value is assigned to the
     original argument.

   This behavior is known as _copy-in copy-out_ or _call by value
result_.  For example, when a computed property or a property with
observers is passed as an in-out parameter, its getter is called as part
of the function call and its setter is called as part of the function
return.

   As an optimization, when the argument is a value stored at a physical
address in memory, the same memory location is used both inside and
outside the function body.  The optimized behavior is known as _call by
reference_; it satisfies all of the requirements of the copy-in copy-out
model while removing the overhead of copying.  Write your code using the
model given by copy-in copy-out, without depending on the
call-by-reference optimization, so that it behaves correctly with or
without the optimization.

   Within a function, don’t access a value that was passed as an in-out
argument, even if the original value is available in the current scope.
Accessing the original is a simultaneous access of the value, which
violates Swift’s memory exclusivity guarantee.  For the same reason, you
can’t pass the same value to multiple in-out parameters.

   For more information about memory safety and memory exclusivity, see
*note Memory Safety: (swift)Memory Safety.

   A closure or nested function that captures an in-out parameter must
be nonescaping.  If you need to capture an in-out parameter without
mutating it or to observe changes made by other code, use a capture list
to explicitly capture the parameter immutably.

  1. func someFunction(a: inout Int) -> () -> Int {
  2. return { [a] in return a + 1 }
  3. }

   If you need to capture and mutate an in-out parameter, use an
explicit local copy, such as in multithreaded code that ensures all
mutation has finished before the function returns.

  1. func multithreadedFunction(queue: DispatchQueue, x: inout Int) {
  2. // Make a local copy and manually copy it back.
  3. var localX = x
  4. defer { x = localX }
  5. 
  6. // Operate on localX asynchronously, then wait before returning.
  7. queue.async { someMutatingOperation(&localX) }
  8. queue.sync {}
  9. }

   For more discussion and examples of in-out parameters, see *note
In-Out Parameters::.


File: swift-reference.info,  Node: Special Kinds of Parameters,  Next: Special Kinds of Methods,  Prev: In-Out Parameters,  Up: Function Declaration

7.7.3 Special Kinds of Parameters
---------------------------------

Parameters can be ignored, take a variable number of values, and provide
default values using the following forms:

  1. _ : parameter type
  2. parameter name: parameter type...
  3. parameter name: parameter type = default argument value

   An underscore (‘_’) parameter is explicitly ignored and can’t be
accessed within the body of the function.

   A parameter with a base type name followed immediately by three dots
(‘...’) is understood as a variadic parameter.  A function can have at
most one variadic parameter.  A variadic parameter is treated as an
array that contains elements of the base type name.  For example, the
variadic parameter ‘Int...’ is treated as ‘[Int]’.  For an example that
uses a variadic parameter, see *note Variadic Parameters:
(swift)Variadic Parameters.

   A parameter with an equals sign (‘=’) and an expression after its
type is understood to have a default value of the given expression.  The
given expression is evaluated when the function is called.  If the
parameter is omitted when calling the function, the default value is
used instead.

  1. func f(x: Int = 42) -> Int { return x }
  2. f() // Valid, uses default value
  3. f(x: 7) // Valid, uses the value provided
  4. f(7) // Invalid, missing argument label


File: swift-reference.info,  Node: Special Kinds of Methods,  Next: Methods with Special Names,  Prev: Special Kinds of Parameters,  Up: Function Declaration

7.7.4 Special Kinds of Methods
------------------------------

Methods on an enumeration or a structure that modify ‘self’ must be
marked with the ‘mutating’ declaration modifier.

   Methods that override a superclass method must be marked with the
‘override’ declaration modifier.  It’s a compile-time error to override
a method without the ‘override’ modifier or to use the ‘override’
modifier on a method that doesn’t override a superclass method.

   Methods associated with a type rather than an instance of a type must
be marked with the ‘static’ declaration modifier for enumerations and
structures, or with either the ‘static’ or ‘class’ declaration modifier
for classes.  A class type method marked with the ‘class’ declaration
modifier can be overridden by a subclass implementation; a class type
method marked with ‘class final’ or ‘static’ can’t be overridden.


File: swift-reference.info,  Node: Methods with Special Names,  Next: Throwing Functions and Methods,  Prev: Special Kinds of Methods,  Up: Function Declaration

7.7.5 Methods with Special Names
--------------------------------

Several methods that have special names enable syntactic sugar for
function call syntax.  If a type defines one of these methods, instances
of the type can be used in function call syntax.  The function call is
understood to be a call to one of the specially named methods on that
instance.

   A class, structure, or enumeration type can support function call
syntax by defining a ‘dynamicallyCall(withArguments:)’ method or a
‘dynamicallyCall(withKeywordArguments:)’ method, as described in *note
dynamicCallable::, or by defining a call-as-function method, as
described below.  If the type defines both a call-as-function method and
one of the methods used by the ‘dynamicCallable’ attribute, the compiler
gives preference to the call-as-function method in circumstances where
either method could be used.

   The name of a call-as-function method is ‘callAsFunction()’, or
another name that begins with ‘callAsFunction(’ and adds labeled or
unlabeled arguments—for example, ‘callAsFunction(_:_:)’ and
‘callAsFunction(something:)’ are also valid call-as-function method
names.

   The following function calls are equivalent:

  1. struct CallableStruct {
  2. var value: Int
  3. func callAsFunction(_ number: Int, scale: Int) {
  4. print(scale * (number + value))
  5. }
  6. }
  7. let callable = CallableStruct(value: 100)
  8. callable(4, scale: 2)
  9. callable.callAsFunction(4, scale: 2)
  10. // Both function calls print 208.

   The call-as-function methods and the methods from the
‘dynamicCallable’ attribute make different trade-offs between how much
information you encode into the type system and how much dynamic
behavior is possible at runtime.  When you declare a call-as-function
method, you specify the number of arguments, and each argument’s type
and label.  The ‘dynamicCallable’ attribute’s methods specify only the
type used to hold the array of arguments.

   Defining a call-as-function method, or a method from the
‘dynamicCallable’ attribute, doesn’t let you use an instance of that
type as if it were a function in any context other than a function call
expression.  For example:

  1. let someFunction1: (Int, Int) -> Void = callable(_:scale:) // Error
  2. let someFunction2: (Int, Int) -> Void =
     callable.callAsFunction(_:scale:)

   The ‘subscript(dynamicMemberLookup:)’ subscript enables syntactic
sugar for member lookup, as described in *note dynamicMemberLookup::.


File: swift-reference.info,  Node: Throwing Functions and Methods,  Next: Rethrowing Functions and Methods,  Prev: Methods with Special Names,  Up: Function Declaration

7.7.6 Throwing Functions and Methods
------------------------------------

Functions and methods that can throw an error must be marked with the
‘throws’ keyword.  These functions and methods are known as _throwing
functions_ and _throwing methods_.  They have the following form:

  1. func function name(parameters) throws -> return type {
  2. statements
  3. }

   Calls to a throwing function or method must be wrapped in a ‘try’ or
‘try!’ expression (that is, in the scope of a ‘try’ or ‘try!’ operator).

   The ‘throws’ keyword is part of a function’s type, and nonthrowing
functions are subtypes of throwing functions.  As a result, you can use
a nonthrowing function in the same places as a throwing one.

   You can’t overload a function based only on whether the function can
throw an error.  That said, you can overload a function based on whether
a function _parameter_ can throw an error.

   A throwing method can’t override a nonthrowing method, and a throwing
method can’t satisfy a protocol requirement for a nonthrowing method.
That said, a nonthrowing method can override a throwing method, and a
nonthrowing method can satisfy a protocol requirement for a throwing
method.


File: swift-reference.info,  Node: Rethrowing Functions and Methods,  Next: Functions that Never Return,  Prev: Throwing Functions and Methods,  Up: Function Declaration

7.7.7 Rethrowing Functions and Methods
--------------------------------------

A function or method can be declared with the ‘rethrows’ keyword to
indicate that it throws an error only if one of its function parameters
throws an error.  These functions and methods are known as _rethrowing
functions_ and _rethrowing methods_.  Rethrowing functions and methods
must have at least one throwing function parameter.

  1. func someFunction(callback: () throws -> Void) rethrows {
  2. try callback()
  3. }

   A rethrowing function or method can contain a ‘throw’ statement only
inside a ‘catch’ clause.  This lets you call the throwing function
inside a ‘do’-‘catch’ statement and handle errors in the ‘catch’ clause
by throwing a different error.  In addition, the ‘catch’ clause must
handle only errors thrown by one of the rethrowing function’s throwing
parameters.  For example, the following is invalid because the ‘catch’
clause would handle the error thrown by ‘alwaysThrows()’.

  1. func alwaysThrows() throws {
  2. throw SomeError.error
  3. }
  4. func someFunction(callback: () throws -> Void) rethrows {
  5. do {
  6. try callback()
  7. try alwaysThrows() // Invalid, alwaysThrows() isn’t a throwing
     parameter
  8. } catch {
  9. throw AnotherError.error
  10. }
  11. }

   A throwing method can’t override a rethrowing method, and a throwing
method can’t satisfy a protocol requirement for a rethrowing method.
That said, a rethrowing method can override a throwing method, and a
rethrowing method can satisfy a protocol requirement for a throwing
method.


File: swift-reference.info,  Node: Functions that Never Return,  Prev: Rethrowing Functions and Methods,  Up: Function Declaration

7.7.8 Functions that Never Return
---------------------------------

Swift defines a ‘Never’ type, which indicates that a function or method
doesn’t return to its caller.  Functions and methods with the ‘Never’
return type are called _nonreturning_.  Nonreturning functions and
methods either cause an irrecoverable error or begin a sequence of work
that continues indefinitely.  This means that code that would otherwise
run immediately after the call is never executed.  Throwing and
rethrowing functions can transfer program control to an appropriate
‘catch’ block, even when they are nonreturning.

   A nonreturning function or method can be called to conclude the
‘else’ clause of a guard statement, as discussed in *note Guard
Statement::.

   You can override a nonreturning method, but the new method must
preserve its return type and nonreturning behavior.

   Grammar of a function declaration

   function-declaration → function-head function-name
generic-parameter-clause _{opt} function-signature generic-where-clause
_{opt} function-body _{opt}

   function-head → attributes _{opt} declaration-modifiers _{opt} ‘func’

   function-name → identifier
   operator

   function-signature → parameter-clause =throws=_opt function-result
_{opt}

   function-signature → parameter-clause ‘rethrows’ function-result
_{opt}

   function-result → ‘->’ attributes _{opt} type

   function-body → code-block

   parameter-clause → ‘(’ ‘)’ | ‘(’ parameter-list ‘)’

   parameter-list → parameter | parameter ‘,’ parameter-list

   parameter → external-parameter-name _{opt} local-parameter-name
type-annotation default-argument-clause _{opt}

   parameter → external-parameter-name _{opt} local-parameter-name
type-annotation

   parameter → external-parameter-name _{opt} local-parameter-name
type-annotation ‘...’

   external-parameter-name → identifier

   local-parameter-name → identifier

   default-argument-clause → ‘=’ expression


File: swift-reference.info,  Node: Enumeration Declaration,  Next: Structure Declaration,  Prev: Function Declaration,  Up: Declarations

7.8 Enumeration Declaration
===========================

An _enumeration declaration_ introduces a named enumeration type into
your program.

   Enumeration declarations have two basic forms and are declared using
the ‘enum’ keyword.  The body of an enumeration declared using either
form contains zero or more values—called _enumeration cases_—and any
number of declarations, including computed properties, instance methods,
type methods, initializers, type aliases, and even other enumeration,
structure, and class declarations.  Enumeration declarations can’t
contain deinitializer or protocol declarations.

   Enumeration types can adopt any number of protocols, but can’t
inherit from classes, structures, or other enumerations.

   Unlike classes and structures, enumeration types do not have an
implicitly provided default initializer; all initializers must be
declared explicitly.  Initializers can delegate to other initializers in
the enumeration, but the initialization process is complete only after
an initializer assigns one of the enumeration cases to ‘self’.

   Like structures but unlike classes, enumerations are value types;
instances of an enumeration are copied when assigned to variables or
constants, or when passed as arguments to a function call.  For
information about value types, see *note Structures and Enumerations Are
Value Types: (swift)Structures and Enumerations Are Value Types.

   You can extend the behavior of an enumeration type with an extension
declaration, as discussed in *note Extension Declaration: Extension
Declaration.

* Menu:

* Enumerations with Cases of Any Type::
* Enumerations with Cases of a Raw-Value Type::
* Accessing Enumeration Cases::


File: swift-reference.info,  Node: Enumerations with Cases of Any Type,  Next: Enumerations with Cases of a Raw-Value Type,  Up: Enumeration Declaration

7.8.1 Enumerations with Cases of Any Type
-----------------------------------------

The following form declares an enumeration type that contains
enumeration cases of any type:

  1. enum enumeration name: adopted protocols {
  2. case enumeration case 1
  3. case enumeration case 2(associated value types)
  4. }

   Enumerations declared in this form are sometimes called
_discriminated unions_ in other programming languages.

   In this form, each case block consists of the ‘case’ keyword followed
by one or more enumeration cases, separated by commas.  The name of each
case must be unique.  Each case can also specify that it stores values
of a given type.  These types are specified in the _associated value
types_ tuple, immediately following the name of the case.

   Enumeration cases that store associated values can be used as
functions that create instances of the enumeration with the specified
associated values.  And just like functions, you can get a reference to
an enumeration case and apply it later in your code.

  1. enum Number {
  2. case integer(Int)
  3. case real(Double)
  4. }
  5. let f = Number.integer
  6. // f is a function of type (Int) -> Number
  7. 
  8. // Apply f to create an array of Number instances with integer
     values
  9. let evenInts: [Number] = [0, 2, 4, 6].map(f)

   For more information and to see examples of cases with associated
value types, see *note Associated Values: (swift)Associated Values.

  1. Enumerations with Indirection

     Enumerations can have a recursive structure, that is, they can have
     cases with associated values that are instances of the enumeration
     type itself.  However, instances of enumeration types have value
     semantics, which means they have a fixed layout in memory.  To
     support recursion, the compiler must insert a layer of indirection.

     To enable indirection for a particular enumeration case, mark it
     with the ‘indirect’ declaration modifier.  An indirect case must
     have an associated value.

       1. enum Tree<T> {
       2. case empty
       3. indirect case node(value: T, left: Tree, right: Tree)
       4. }

     To enable indirection for all the cases of an enumeration that have
     an associated value, mark the entire enumeration with the
     ‘indirect’ modifier—this is convenient when the enumeration
     contains many cases that would each need to be marked with the
     ‘indirect’ modifier.

     An enumeration that is marked with the ‘indirect’ modifier can
     contain a mixture of cases that have associated values and cases
     those that don’t.  That said, it can’t contain any cases that are
     also marked with the ‘indirect’ modifier.


File: swift-reference.info,  Node: Enumerations with Cases of a Raw-Value Type,  Next: Accessing Enumeration Cases,  Prev: Enumerations with Cases of Any Type,  Up: Enumeration Declaration

7.8.2 Enumerations with Cases of a Raw-Value Type
-------------------------------------------------

The following form declares an enumeration type that contains
enumeration cases of the same basic type:

  1. enum enumeration name: raw-value type, adopted protocols {
  2. case enumeration case 1 = raw value 1
  3. case enumeration case 2 = raw value 2
  4. }

   In this form, each case block consists of the ‘case’ keyword,
followed by one or more enumeration cases, separated by commas.  Unlike
the cases in the first form, each case has an underlying value, called a
_raw value_, of the same basic type.  The type of these values is
specified in the _raw-value type_ and must represent an integer,
floating-point number, string, or single character.  In particular, the
_raw-value type_ must conform to the ‘Equatable’ protocol and one of the
following protocols: ‘ExpressibleByIntegerLiteral’ for integer literals,
‘ExpressibleByFloatLiteral’ for floating-point literals,
‘ExpressibleByStringLiteral’ for string literals that contain any number
of characters, and ‘ExpressibleByUnicodeScalarLiteral’ or
‘ExpressibleByExtendedGraphemeClusterLiteral’ for string literals that
contain only a single character.  Each case must have a unique name and
be assigned a unique raw value.

   If the raw-value type is specified as ‘Int’ and you don’t assign a
value to the cases explicitly, they are implicitly assigned the values
‘0’, ‘1’, ‘2’, and so on.  Each unassigned case of type ‘Int’ is
implicitly assigned a raw value that is automatically incremented from
the raw value of the previous case.

  1. enum ExampleEnum: Int {
  2. case a, b, c = 5, d
  3. }

   In the above example, the raw value of ‘ExampleEnum.a’ is ‘0’ and the
value of ‘ExampleEnum.b’ is ‘1’.  And because the value of
‘ExampleEnum.c’ is explicitly set to ‘5’, the value of ‘ExampleEnum.d’
is automatically incremented from ‘5’ and is therefore ‘6’.

   If the raw-value type is specified as ‘String’ and you don’t assign
values to the cases explicitly, each unassigned case is implicitly
assigned a string with the same text as the name of that case.

  1. enum GamePlayMode: String {
  2. case cooperative, individual, competitive
  3. }

   In the above example, the raw value of ‘GamePlayMode.cooperative’ is
‘"cooperative"’, the raw value of ‘GamePlayMode.individual’ is
‘"individual"’, and the raw value of ‘GamePlayMode.competitive’ is
‘"competitive"’.

   Enumerations that have cases of a raw-value type implicitly conform
to the ‘RawRepresentable’ protocol, defined in the Swift standard
library.  As a result, they have a ‘rawValue’ property and a failable
initializer with the signature ‘init?(rawValue: RawValue)’.  You can use
the ‘rawValue’ property to access the raw value of an enumeration case,
as in ‘ExampleEnum.b.rawValue’.  You can also use a raw value to find a
corresponding case, if there is one, by calling the enumeration’s
failable initializer, as in ‘ExampleEnum(rawValue: 5)’, which returns an
optional case.  For more information and to see examples of cases with
raw-value types, see *note Raw Values: (swift)Raw Values.


File: swift-reference.info,  Node: Accessing Enumeration Cases,  Prev: Enumerations with Cases of a Raw-Value Type,  Up: Enumeration Declaration

7.8.3 Accessing Enumeration Cases
---------------------------------

To reference the case of an enumeration type, use dot (‘.’) syntax, as
in ‘EnumerationType.enumerationCase’.  When the enumeration type can be
inferred from context, you can omit it (the dot is still required), as
described in *note Enumeration Syntax: (swift)Enumeration Syntax. and
*note Implicit Member Expression::.

   To check the values of enumeration cases, use a ‘switch’ statement,
as shown in *note Matching Enumeration Values with a Switch Statement:
(swift)Matching Enumeration Values with a Switch Statement.  The
enumeration type is pattern-matched against the enumeration case
patterns in the case blocks of the ‘switch’ statement, as described in
*note Enumeration Case Pattern::.

   Grammar of an enumeration declaration

   enum-declaration → attributes _{opt} access-level-modifier _{opt}
union-style-enum

   enum-declaration → attributes _{opt} access-level-modifier _{opt}
raw-value-style-enum

   union-style-enum → ‘indirect=_{opt} =enum’ enum-name
generic-parameter-clause _{opt} type-inheritance-clause _{opt}
generic-where-clause _{opt} ‘{’ union-style-enum-members _{opt} ‘}’

   union-style-enum-members → union-style-enum-member
union-style-enum-members _{opt}

   union-style-enum-member → declaration
   union-style-enum-case-clause
   compiler-control-statement

   union-style-enum-case-clause → attributes _{opt} ‘indirect=_{opt}
=case’ union-style-enum-case-list

   union-style-enum-case-list → union-style-enum-case
   union-style-enum-case ‘,’ union-style-enum-case-list

   union-style-enum-case → enum-case-name tuple-type _{opt}

   enum-name → identifier

   enum-case-name → identifier

   raw-value-style-enum → ‘enum’ enum-name generic-parameter-clause
_{opt} type-inheritance-clause generic-where-clause _{opt} ‘{’
raw-value-style-enum-members ‘}’

   raw-value-style-enum-members → raw-value-style-enum-member
raw-value-style-enum-members _{opt}

   raw-value-style-enum-member → declaration
   raw-value-style-enum-case-clause
   compiler-control-statement

   raw-value-style-enum-case-clause → attributes _{opt} ‘case’
raw-value-style-enum-case-list

   raw-value-style-enum-case-list → raw-value-style-enum-case
   raw-value-style-enum-case ‘,’ raw-value-style-enum-case-list

   raw-value-style-enum-case → enum-case-name raw-value-assignment
_{opt}

   raw-value-assignment → ‘=’ raw-value-literal

   raw-value-literal → numeric-literal
   static-string-literal
   boolean-literal


File: swift-reference.info,  Node: Structure Declaration,  Next: Class Declaration,  Prev: Enumeration Declaration,  Up: Declarations

7.9 Structure Declaration
=========================

A _structure declaration_ introduces a named structure type into your
program.  Structure declarations are declared using the ‘struct’ keyword
and have the following form:

  1. struct structure name: adopted protocols {
  2. declarations
  3. }

   The body of a structure contains zero or more _declarations_.  These
_declarations_ can include both stored and computed properties, type
properties, instance methods, type methods, initializers, subscripts,
type aliases, and even other structure, class, and enumeration
declarations.  Structure declarations can’t contain deinitializer or
protocol declarations.  For a discussion and several examples of
structures that include various kinds of declarations, see *note
Structures and Classes: (swift)Structures and Classes.

   Structure types can adopt any number of protocols, but can’t inherit
from classes, enumerations, or other structures.

   There are three ways to create an instance of a previously declared
structure:

   • Call one of the initializers declared within the structure, as
     described in *note Initializers: (swift)Initializers.

   • If no initializers are declared, call the structure’s memberwise
     initializer, as described in *note Memberwise Initializers for
     Structure Types: (swift)Memberwise Initializers for Structure
     Types.

   • If no initializers are declared, and all properties of the
     structure declaration were given initial values, call the
     structure’s default initializer, as described in *note Default
     Initializers: (swift)Default Initializers.

   The process of initializing a structure’s declared properties is
described in *note Initialization: (swift)Initialization.

   Properties of a structure instance can be accessed using dot (‘.’)
syntax, as described in *note Accessing Properties: (swift)Accessing
Properties.

   Structures are value types; instances of a structure are copied when
assigned to variables or constants, or when passed as arguments to a
function call.  For information about value types, see *note Structures
and Enumerations Are Value Types: (swift)Structures and Enumerations Are
Value Types.

   You can extend the behavior of a structure type with an extension
declaration, as discussed in *note Extension Declaration: Extension
Declaration.

   Grammar of a structure declaration

   struct-declaration → attributes _{opt} access-level-modifier _{opt}
‘struct’ struct-name generic-parameter-clause _{opt}
type-inheritance-clause _{opt} generic-where-clause _{opt} struct-body

   struct-name → identifier

   struct-body → ‘{’ struct-members _{opt} ‘}’

   struct-members → struct-member struct-members _{opt}

   struct-member → declaration
   compiler-control-statement


File: swift-reference.info,  Node: Class Declaration,  Next: Protocol Declaration,  Prev: Structure Declaration,  Up: Declarations

7.10 Class Declaration
======================

A _class declaration_ introduces a named class type into your program.
Class declarations are declared using the ‘class’ keyword and have the
following form:

  1. class class name: superclass, adopted protocols {
  2. declarations
  3. }

   The body of a class contains zero or more _declarations_.  These
_declarations_ can include both stored and computed properties, instance
methods, type methods, initializers, a single deinitializer, subscripts,
type aliases, and even other class, structure, and enumeration
declarations.  Class declarations can’t contain protocol declarations.
For a discussion and several examples of classes that include various
kinds of declarations, see *note Structures and Classes:
(swift)Structures and Classes.

   A class type can inherit from only one parent class, its
_superclass_, but can adopt any number of protocols.  The _superclass_
appears first after the _class name_ and colon, followed by any _adopted
protocols_.  Generic classes can inherit from other generic and
nongeneric classes, but a nongeneric class can inherit only from other
nongeneric classes.  When you write the name of a generic superclass
class after the colon, you must include the full name of that generic
class, including its generic parameter clause.

   As discussed in *note Initializer Declaration::, classes can have
designated and convenience initializers.  The designated initializer of
a class must initialize all of the class’s declared properties and it
must do so before calling any of its superclass’s designated
initializers.

   A class can override properties, methods, subscripts, and
initializers of its superclass.  Overridden properties, methods,
subscripts, and designated initializers must be marked with the
‘override’ declaration modifier.

   To require that subclasses implement a superclass’s initializer, mark
the superclass’s initializer with the ‘required’ declaration modifier.
The subclass’s implementation of that initializer must also be marked
with the ‘required’ declaration modifier.

   Although properties and methods declared in the _superclass_ are
inherited by the current class, designated initializers declared in the
_superclass_ are only inherited when the subclass meets the conditions
described in *note Automatic Initializer Inheritance: (swift)Automatic
Initializer Inheritance.  Swift classes do not inherit from a universal
base class.

   There are two ways to create an instance of a previously declared
class:

   • Call one of the initializers declared within the class, as
     described in *note Initializers: (swift)Initializers.

   • If no initializers are declared, and all properties of the class
     declaration were given initial values, call the class’s default
     initializer, as described in *note Default Initializers:
     (swift)Default Initializers.

   Access properties of a class instance with dot (‘.’) syntax, as
described in *note Accessing Properties: (swift)Accessing Properties.

   Classes are reference types; instances of a class are referred to,
rather than copied, when assigned to variables or constants, or when
passed as arguments to a function call.  For information about reference
types, see *note Structures and Enumerations Are Value Types:
(swift)Structures and Enumerations Are Value Types.

   You can extend the behavior of a class type with an extension
declaration, as discussed in *note Extension Declaration: Extension
Declaration.

   Grammar of a class declaration

   class-declaration → attributes _{opt} access-level-modifier _{opt}
‘final=_{opt} =class’ class-name generic-parameter-clause _{opt}
type-inheritance-clause _{opt} generic-where-clause _{opt} class-body

   class-declaration → attributes _{opt} ‘final’ access-level-modifier
_{opt} ‘class’ class-name generic-parameter-clause _{opt}
type-inheritance-clause _{opt} generic-where-clause _{opt} class-body

   class-name → identifier

   class-body → ‘{’ class-members _{opt} ‘}’

   class-members → class-member class-members _{opt}

   class-member → declaration
   compiler-control-statement


File: swift-reference.info,  Node: Protocol Declaration,  Next: Initializer Declaration,  Prev: Class Declaration,  Up: Declarations

7.11 Protocol Declaration
=========================

A _protocol declaration_ introduces a named protocol type into your
program.  Protocol declarations are declared at global scope using the
‘protocol’ keyword and have the following form:

  1. protocol protocol name: inherited protocols {
  2. protocol member declarations
  3. }

   The body of a protocol contains zero or more _protocol member
declarations_, which describe the conformance requirements that any type
adopting the protocol must fulfill.  In particular, a protocol can
declare that conforming types must implement certain properties,
methods, initializers, and subscripts.  Protocols can also declare
special kinds of type aliases, called _associated types_, that can
specify relationships among the various declarations of the protocol.
Protocol declarations can’t contain class, structure, enumeration, or
other protocol declarations.  The _protocol member declarations_ are
discussed in detail below.

   Protocol types can inherit from any number of other protocols.  When
a protocol type inherits from other protocols, the set of requirements
from those other protocols are aggregated, and any type that inherits
from the current protocol must conform to all those requirements.  For
an example of how to use protocol inheritance, see *note Protocol
Inheritance: (swift)Protocol Inheritance.

   Note

   You can also aggregate the conformance requirements of multiple
protocols using protocol composition types, as described in *note
Protocol Composition Type:: and *note Protocol Composition:
(swift)Protocol Composition.

   You can add protocol conformance to a previously declared type by
adopting the protocol in an extension declaration of that type.  In the
extension, you must implement all of the adopted protocol’s
requirements.  If the type already implements all of the requirements,
you can leave the body of the extension declaration empty.

   By default, types that conform to a protocol must implement all
properties, methods, and subscripts declared in the protocol.  That
said, you can mark these protocol member declarations with the
‘optional’ declaration modifier to specify that their implementation by
a conforming type is optional.  The ‘optional’ modifier can be applied
only to members that are marked with the ‘objc’ attribute, and only to
members of protocols that are marked with the ‘objc’ attribute.  As a
result, only class types can adopt and conform to a protocol that
contains optional member requirements.  For more information about how
to use the ‘optional’ declaration modifier and for guidance about how to
access optional protocol members—for example, when you’re not sure
whether a conforming type implements them—see *note Optional Protocol
Requirements: (swift)Optional Protocol Requirements.

   To restrict the adoption of a protocol to class types only, include
the ‘AnyObject’ protocol in the _inherited protocols_ list after the
colon.  For example, the following protocol can be adopted only by class
types:

  1. protocol SomeProtocol: AnyObject {
  2. _* Protocol members go here *_
  3. }

   Any protocol that inherits from a protocol that’s marked with the
‘AnyObject’ requirement can likewise be adopted only by class types.

   Note

   If a protocol is marked with the ‘objc’ attribute, the ‘AnyObject’
requirement is implicitly applied to that protocol; there’s no need to
mark the protocol with the ‘AnyObject’ requirement explicitly.

   Protocols are named types, and thus they can appear in all the same
places in your code as other named types, as discussed in *note
Protocols as Types: (swift)Protocols as Types.  However, you can’t
construct an instance of a protocol, because protocols do not actually
provide the implementations for the requirements they specify.

   You can use protocols to declare which methods a delegate of a class
or structure should implement, as described in *note Delegation:
(swift)Delegation.

   Grammar of a protocol declaration

   protocol-declaration → attributes _{opt} access-level-modifier _{opt}
‘protocol’ protocol-name type-inheritance-clause _{opt}
generic-where-clause _{opt} protocol-body

   protocol-name → identifier

   protocol-body → ‘{’ protocol-members _{opt} ‘}’

   protocol-members → protocol-member protocol-members _{opt}

   protocol-member → protocol-member-declaration
   compiler-control-statement

   protocol-member-declaration → protocol-property-declaration

   protocol-member-declaration → protocol-method-declaration

   protocol-member-declaration → protocol-initializer-declaration

   protocol-member-declaration → protocol-subscript-declaration

   protocol-member-declaration → protocol-associated-type-declaration

   protocol-member-declaration → typealias-declaration

* Menu:

* Protocol Property Declaration::
* Protocol Method Declaration::
* Protocol Initializer Declaration::
* Protocol Subscript Declaration::
* Protocol Associated Type Declaration::


File: swift-reference.info,  Node: Protocol Property Declaration,  Next: Protocol Method Declaration,  Up: Protocol Declaration

7.11.1 Protocol Property Declaration
------------------------------------

Protocols declare that conforming types must implement a property by
including a _protocol property declaration_ in the body of the protocol
declaration.  Protocol property declarations have a special form of a
variable declaration:

  1. var property name: type { get set }

   As with other protocol member declarations, these property
declarations declare only the getter and setter requirements for types
that conform to the protocol.  As a result, you don’t implement the
getter or setter directly in the protocol in which it is declared.

   The getter and setter requirements can be satisfied by a conforming
type in a variety of ways.  If a property declaration includes both the
‘get’ and ‘set’ keywords, a conforming type can implement it with a
stored variable property or a computed property that is both readable
and writeable (that is, one that implements both a getter and a setter).
However, that property declaration can’t be implemented as a constant
property or a read-only computed property.  If a property declaration
includes only the ‘get’ keyword, it can be implemented as any kind of
property.  For examples of conforming types that implement the property
requirements of a protocol, see *note Property Requirements:
(swift)Property Requirements.

   See also *note Variable Declaration::.

   Grammar of a protocol property declaration

   protocol-property-declaration → variable-declaration-head
variable-name type-annotation getter-setter-keyword-block


File: swift-reference.info,  Node: Protocol Method Declaration,  Next: Protocol Initializer Declaration,  Prev: Protocol Property Declaration,  Up: Protocol Declaration

7.11.2 Protocol Method Declaration
----------------------------------

Protocols declare that conforming types must implement a method by
including a protocol method declaration in the body of the protocol
declaration.  Protocol method declarations have the same form as
function declarations, with two exceptions: They don’t include a
function body, and you can’t provide any default parameter values as
part of the function declaration.  For examples of conforming types that
implement the method requirements of a protocol, see *note Method
Requirements: (swift)Method Requirements.

   To declare a class or static method requirement in a protocol
declaration, mark the method declaration with the ‘static’ declaration
modifier.  Structures and enumerations that conform to the protocol
declare the method with the ‘static’ keyword, and classes that conform
to the protocol declare the method with either the ‘static’ or ‘class’
keyword.  Extensions that add protocol conformance to a structure,
enumeration, or class use the same keyword as the type they extend uses.
Extensions that provide a default implementation for a type method
requirement use the ‘static’ keyword.

   See also *note Function Declaration::.

   Grammar of a protocol method declaration

   protocol-method-declaration → function-head function-name
generic-parameter-clause _{opt} function-signature generic-where-clause
_{opt}


File: swift-reference.info,  Node: Protocol Initializer Declaration,  Next: Protocol Subscript Declaration,  Prev: Protocol Method Declaration,  Up: Protocol Declaration

7.11.3 Protocol Initializer Declaration
---------------------------------------

Protocols declare that conforming types must implement an initializer by
including a protocol initializer declaration in the body of the protocol
declaration.  Protocol initializer declarations have the same form as
initializer declarations, except they don’t include the initializer’s
body.

   A conforming type can satisfy a nonfailable protocol initializer
requirement by implementing a nonfailable initializer or an ‘init!’
failable initializer.  A conforming type can satisfy a failable protocol
initializer requirement by implementing any kind of initializer.

   When a class implements an initializer to satisfy a protocol’s
initializer requirement, the initializer must be marked with the
‘required’ declaration modifier if the class is not already marked with
the ‘final’ declaration modifier.

   See also *note Initializer Declaration::.

   Grammar of a protocol initializer declaration

   protocol-initializer-declaration → initializer-head
generic-parameter-clause _{opt} parameter-clause =throws=_opt
generic-where-clause _{opt}

   protocol-initializer-declaration → initializer-head
generic-parameter-clause _{opt} parameter-clause ‘rethrows’
generic-where-clause _{opt}


File: swift-reference.info,  Node: Protocol Subscript Declaration,  Next: Protocol Associated Type Declaration,  Prev: Protocol Initializer Declaration,  Up: Protocol Declaration

7.11.4 Protocol Subscript Declaration
-------------------------------------

Protocols declare that conforming types must implement a subscript by
including a protocol subscript declaration in the body of the protocol
declaration.  Protocol subscript declarations have a special form of a
subscript declaration:

  1. subscript (parameters) -> return type { get set }

   Subscript declarations only declare the minimum getter and setter
implementation requirements for types that conform to the protocol.  If
the subscript declaration includes both the ‘get’ and ‘set’ keywords, a
conforming type must implement both a getter and a setter clause.  If
the subscript declaration includes only the ‘get’ keyword, a conforming
type must implement _at least_ a getter clause and optionally can
implement a setter clause.

   See also *note Subscript Declaration::.

   Grammar of a protocol subscript declaration

   protocol-subscript-declaration → subscript-head subscript-result
generic-where-clause _{opt} getter-setter-keyword-block


File: swift-reference.info,  Node: Protocol Associated Type Declaration,  Prev: Protocol Subscript Declaration,  Up: Protocol Declaration

7.11.5 Protocol Associated Type Declaration
-------------------------------------------

Protocols declare associated types using the ‘associatedtype’ keyword.
An associated type provides an alias for a type that is used as part of
a protocol’s declaration.  Associated types are similar to type
parameters in generic parameter clauses, but they’re associated with
‘Self’ in the protocol in which they’re declared.  In that context,
‘Self’ refers to the eventual type that conforms to the protocol.  For
more information and examples, see *note Associated Types:
(swift)Associated Types.

   You use a generic ‘where’ clause in a protocol declaration to add
constraints to an associated types inherited from another protocol,
without redeclaring the associated types.  For example, the declarations
of ‘SubProtocol’ below are equivalent:

  1. protocol SomeProtocol {
  2. associatedtype SomeType
  3. }
  4. 
  5. protocol SubProtocolA: SomeProtocol {
  6. // This syntax produces a warning.
  7. associatedtype SomeType: Equatable
  8. }
  9. 
  10. // This syntax is preferred.
  11. protocol SubProtocolB: SomeProtocol where SomeType: Equatable { }

   See also *note Type Alias Declaration::.

   Grammar of a protocol associated type declaration

   protocol-associated-type-declaration → attributes _{opt}
access-level-modifier _{opt} ‘associatedtype’ typealias-name
type-inheritance-clause _{opt} typealias-assignment _{opt}
generic-where-clause _{opt}


File: swift-reference.info,  Node: Initializer Declaration,  Next: Deinitializer Declaration,  Prev: Protocol Declaration,  Up: Declarations

7.12 Initializer Declaration
============================

An _initializer declaration_ introduces an initializer for a class,
structure, or enumeration into your program.  Initializer declarations
are declared using the ‘init’ keyword and have two basic forms.

   Structure, enumeration, and class types can have any number of
initializers, but the rules and associated behavior for class
initializers are different.  Unlike structures and enumerations, classes
have two kinds of initializers: designated initializers and convenience
initializers, as described in *note Initialization:
(swift)Initialization.

   The following form declares initializers for structures,
enumerations, and designated initializers of classes:

  1. init(parameters) {
  2. statements
  3. }

   A designated initializer of a class initializes all of the class’s
properties directly.  It can’t call any other initializers of the same
class, and if the class has a superclass, it must call one of the
superclass’s designated initializers.  If the class inherits any
properties from its superclass, one of the superclass’s designated
initializers must be called before any of these properties can be set or
modified in the current class.

   Designated initializers can be declared in the context of a class
declaration only and therefore can’t be added to a class using an
extension declaration.

   Initializers in structures and enumerations can call other declared
initializers to delegate part or all of the initialization process.

   To declare convenience initializers for a class, mark the initializer
declaration with the ‘convenience’ declaration modifier.

  1. convenience init(parameters) {
  2. statements
  3. }

   Convenience initializers can delegate the initialization process to
another convenience initializer or to one of the class’s designated
initializers.  That said, the initialization processes must end with a
call to a designated initializer that ultimately initializes the class’s
properties.  Convenience initializers can’t call a superclass’s
initializers.

   You can mark designated and convenience initializers with the
‘required’ declaration modifier to require that every subclass implement
the initializer.  A subclass’s implementation of that initializer must
also be marked with the ‘required’ declaration modifier.

   By default, initializers declared in a superclass are not inherited
by subclasses.  That said, if a subclass initializes all of its stored
properties with default values and doesn’t define any initializers of
its own, it inherits all of the superclass’s initializers.  If the
subclass overrides all of the superclass’s designated initializers, it
inherits the superclass’s convenience initializers.

   As with methods, properties, and subscripts, you need to mark
overridden designated initializers with the ‘override’ declaration
modifier.

   Note

   If you mark an initializer with the ‘required’ declaration modifier,
you don’t also mark the initializer with the ‘override’ modifier when
you override the required initializer in a subclass.

   Just like functions and methods, initializers can throw or rethrow
errors.  And just like functions and methods, you use the ‘throws’ or
‘rethrows’ keyword after an initializer’s parameters to indicate the
appropriate behavior.

   To see examples of initializers in various type declarations, see
*note Initialization: (swift)Initialization.

* Menu:

* Failable Initializers::


File: swift-reference.info,  Node: Failable Initializers,  Up: Initializer Declaration

7.12.1 Failable Initializers
----------------------------

A _failable initializer_ is a type of initializer that produces an
optional instance or an implicitly unwrapped optional instance of the
type the initializer is declared on.  As a result, a failable
initializer can return ‘nil’ to indicate that initialization failed.

   To declare a failable initializer that produces an optional instance,
append a question mark to the ‘init’ keyword in the initializer
declaration (‘init?’).  To declare a failable initializer that produces
an implicitly unwrapped optional instance, append an exclamation mark
instead (‘init!’).  The example below shows an ‘init?’ failable
initializer that produces an optional instance of a structure.

  1. struct SomeStruct {
  2. let property: String
  3. // produces an optional instance of ’SomeStruct’
  4. init?(input: String) {
  5. if input.isEmpty {
  6. // discard ’self’ and return ’nil’
  7. return nil
  8. }
  9. property = input
  10. }
  11. }

   You call an ‘init?’ failable initializer in the same way that you
call a nonfailable initializer, except that you must deal with the
optionality of the result.

  1. if let actualInstance = SomeStruct(input: "Hello") {
  2. // do something with the instance of ’SomeStruct’
  3. } else {
  4. // initialization of ’SomeStruct’ failed and the initializer
     returned ’nil’
  5. }

   A failable initializer can return ‘nil’ at any point in the
implementation of the initializer’s body.

   A failable initializer can delegate to any kind of initializer.  A
nonfailable initializer can delegate to another nonfailable initializer
or to an ‘init!’ failable initializer.  A nonfailable initializer can
delegate to an ‘init?’ failable initializer by force-unwrapping the
result of the superclass’s initializer—for example, by writing
‘super.init()!’.

   Initialization failure propagates through initializer delegation.
Specifically, if a failable initializer delegates to an initializer that
fails and returns ‘nil’, then the initializer that delegated also fails
and implicitly returns ‘nil’.  If a nonfailable initializer delegates to
an ‘init!’ failable initializer that fails and returns ‘nil’, then a
runtime error is raised (as if you used the ‘!’ operator to unwrap an
optional that has a ‘nil’ value).

   A failable designated initializer can be overridden in a subclass by
any kind of designated initializer.  A nonfailable designated
initializer can be overridden in a subclass by a nonfailable designated
initializer only.

   For more information and to see examples of failable initializers,
see *note Failable Initializers::.

   Grammar of an initializer declaration

   initializer-declaration → initializer-head generic-parameter-clause
_{opt} parameter-clause =throws=_opt generic-where-clause _{opt}
initializer-body

   initializer-declaration → initializer-head generic-parameter-clause
_{opt} parameter-clause ‘rethrows’ generic-where-clause _{opt}
initializer-body

   initializer-head → attributes _{opt} declaration-modifiers _{opt}
‘init’

   initializer-head → attributes _{opt} declaration-modifiers _{opt}
‘init’ ‘?’

   initializer-head → attributes _{opt} declaration-modifiers _{opt}
‘init’ ‘!’

   initializer-body → code-block


File: swift-reference.info,  Node: Deinitializer Declaration,  Next: Extension Declaration,  Prev: Initializer Declaration,  Up: Declarations

7.13 Deinitializer Declaration
==============================

A _deinitializer declaration_ declares a deinitializer for a class type.
Deinitializers take no parameters and have the following form:

  1. deinit {
  2. statements
  3. }

   A deinitializer is called automatically when there are no longer any
references to a class object, just before the class object is
deallocated.  A deinitializer can be declared only in the body of a
class declaration—but not in an extension of a class—and each class can
have at most one.

   A subclass inherits its superclass’s deinitializer, which is
implicitly called just before the subclass object is deallocated.  The
subclass object is not deallocated until all deinitializers in its
inheritance chain have finished executing.

   Deinitializers are not called directly.

   For an example of how to use a deinitializer in a class declaration,
see *note Deinitialization: (swift)Deinitialization.

   Grammar of a deinitializer declaration

   deinitializer-declaration → attributes _{opt} ‘deinit’ code-block


File: swift-reference.info,  Node: Extension Declaration,  Next: Subscript Declaration,  Prev: Deinitializer Declaration,  Up: Declarations

7.14 Extension Declaration
==========================

An _extension declaration_ allows you to extend the behavior of existing
types.  Extension declarations are declared using the ‘extension’
keyword and have the following form:

  1. extension type name where requirements {
  2. declarations
  3. }

   The body of an extension declaration contains zero or more
_declarations_.  These _declarations_ can include computed properties,
computed type properties, instance methods, type methods, initializers,
subscript declarations, and even class, structure, and enumeration
declarations.  Extension declarations can’t contain deinitializer or
protocol declarations, stored properties, property observers, or other
extension declarations.  Declarations in a protocol extension can’t be
marked ‘final’.  For a discussion and several examples of extensions
that include various kinds of declarations, see *note Extensions:
(swift)Extensions.

   If the _type name_ is a class, structure, or enumeration type, the
extension extends that type.  If the _type name_ is a protocol type, the
extension extends all types that conform to that protocol.

   Extension declarations that extend a generic type or a protocol with
associated types can include _requirements_.  If an instance of the
extended type or of a type that conforms to the extended protocol
satisfies the _requirements_, the instance gains the behavior specified
in the declaration.

   Extension declarations can contain initializer declarations.  That
said, if the type you’re extending is defined in another module, an
initializer declaration must delegate to an initializer already defined
in that module to ensure members of that type are properly initialized.

   Properties, methods, and initializers of an existing type can’t be
overridden in an extension of that type.

   Extension declarations can add protocol conformance to an existing
class, structure, or enumeration type by specifying _adopted protocols_:

  1. extension type name: adopted protocols where requirements {
  2. declarations
  3. }

   Extension declarations can’t add class inheritance to an existing
class, and therefore you can specify only a list of protocols after the
_type name_ and colon.

* Menu:

* Conditional Conformance::
* Protocol Conformance Must Not Be Redundant::


File: swift-reference.info,  Node: Conditional Conformance,  Next: Protocol Conformance Must Not Be Redundant,  Up: Extension Declaration

7.14.1 Conditional Conformance
------------------------------

You can extend a generic type to conditionally conform to a protocol, so
that instances of the type conform to the protocol only when certain
requirements are met.  You add conditional conformance to a protocol by
including _requirements_ in an extension declaration.

  1. Overridden Requirements Aren’t Used in Some Generic Contexts

     In some generic contexts, types that get behavior from conditional
     conformance to a protocol don’t always use the specialized
     implementations of that protocol’s requirements.  To illustrate
     this behavior, the following example defines two protocols and a
     generic type that conditionally conforms to both protocols.

       1. protocol Loggable {
       2. func log()
       3. }
       4. extension Loggable {
       5. func log() {
       6. print(self)
       7. }
       8. }
       9. 
       10. protocol TitledLoggable: Loggable {
       11. static var logTitle: String { get }
       12. }
       13. extension TitledLoggable {
       14. func log() {
       15. print("\(Self.logTitle): \(self)")
       16. }
       17. }
       18. 
       19. struct Pair<T>: CustomStringConvertible {
       20. let first: T
       21. let second: T
       22. var description: String {
       23. return "(\(first), \(second))"
       24. }
       25. }
       26. 
       27. extension Pair: Loggable where T: Loggable { }
       28. extension Pair: TitledLoggable where T: TitledLoggable {
       29. static var logTitle: String {
       30. return "Pair of ’\(T.logTitle)’"
       31. }
       32. }
       33. 
       34. extension String: TitledLoggable {
       35. static var logTitle: String {
       36. return "String"
       37. }
       38. }

     The ‘Pair’ structure conforms to ‘Loggable’ and ‘TitledLoggable’
     whenever its generic type conforms to ‘Loggable’ or
     ‘TitledLoggable’, respectively.  In the example below, ‘oneAndTwo’
     is an instance of ‘Pair<String>’, which conforms to
     ‘TitledLoggable’ because ‘String’ conforms to ‘TitledLoggable’.
     When the ‘log()’ method is called on ‘oneAndTwo’ directly, the
     specialized version containing the title string is used.

       1. let oneAndTwo = Pair(first: "one", second: "two")
       2. oneAndTwo.log()
       3. // Prints "Pair of ’String’: (one, two)"

     However, when ‘oneAndTwo’ is used in a generic context or as an
     instance of the ‘Loggable’ protocol, the specialized version isn’t
     used.  Swift picks which implementation of ‘log()’ to call by
     consulting only the minimum requirements that ‘Pair’ needs to
     conform to ‘Loggable’.  For this reason, the default implementation
     provided by the ‘Loggable’ protocol is used instead.

       1. func doSomething<T: Loggable>(with x: T) {
       2. x.log()
       3. }
       4. doSomething(with: oneAndTwo)
       5. // Prints "(one, two)"

     When ‘log()’ is called on the instance that’s passed to
     ‘doSomething(_:)’, the customized title is omitted from the logged
     string.


File: swift-reference.info,  Node: Protocol Conformance Must Not Be Redundant,  Prev: Conditional Conformance,  Up: Extension Declaration

7.14.2 Protocol Conformance Must Not Be Redundant
-------------------------------------------------

A concrete type can conform to a particular protocol only once.  Swift
marks redundant protocol conformances as an error.  You’re likely to
encounter this kind of error in two kinds of situations.  The first
situation is when you explicitly conform to the same protocol multiple
times, but with different requirements.  The second situation is when
you implicitly inherit from the same protocol multiple times.  These
situations are discussed in the sections below.

  1. Resolving Explicit Redundancy

     Multiple extensions on a concrete type can’t add conformance to the
     same protocol, even if the extensions’ requirements are mutually
     exclusive.  This restriction is demonstrated in the example below.
     Two extension declarations attempt to add conditional conformance
     to the ‘Serializable’ protocol, one for for arrays with ‘Int’
     elements, and one for arrays with ‘String’ elements.

       1. protocol Serializable {
       2. func serialize() -> Any
       3. }
       4. 
       5. extension Array: Serializable where Element == Int {
       6. func serialize() -> Any {
       7. // implementation
       8. }
       9. }
       10. extension Array: Serializable where Element == String {
       11. func serialize() -> Any {
       12. // implementation
       13. }
       14. }
       15. // Error: redundant conformance of ’Array<Element>’ to
          protocol ’Serializable’

     If you need to add conditional conformance based on multiple
     concrete types, create a new protocol that each type can conform to
     and use that protocol as the requirement when declaring conditional
     conformance.

       1. protocol SerializableInArray { }
       2. extension Int: SerializableInArray { }
       3. extension String: SerializableInArray { }
       4. 
       5. extension Array: Serializable where Element:
          SerializableInArray {
       6. func serialize() -> Any {
       7. // implementation
       8. }
       9. }

  2. Resolving Implicit Redundancy

     When a concrete type conditionally conforms to a protocol, that
     type implicitly conforms to any parent protocols with the same
     requirements.

     If you need a type to conditionally conform to two protocols that
     inherit from a single parent, explicitly declare conformance to the
     parent protocol.  This avoids implicitly conforming to the parent
     protocol twice with different requirements.

     The following example explicitly declares the conditional
     conformance of ‘Array’ to ‘Loggable’ to avoid a conflict when
     declaring its conditional conformance to both ‘TitledLoggable’ and
     the new ‘MarkedLoggable’ protocol.

       1. protocol MarkedLoggable: Loggable {
       2. func markAndLog()
       3. }
       4. 
       5. extension MarkedLoggable {
       6. func markAndLog() {
       7. print("———-")
       8. log()
       9. }
       10. }
       11. 
       12. extension Array: Loggable where Element: Loggable { }
       13. extension Array: TitledLoggable where Element: TitledLoggable
          {
       14. static var logTitle: String {
       15. return "Array of ’\(Element.logTitle)’"
       16. }
       17. }
       18. extension Array: MarkedLoggable where Element: MarkedLoggable
          { }

     Without the extension to explicitly declare conditional conformance
     to ‘Loggable’, the other ‘Array’ extensions would implicitly create
     these declarations, resulting in an error:

       1. extension Array: Loggable where Element: TitledLoggable { }
       2. extension Array: Loggable where Element: MarkedLoggable { }
       3. // Error: redundant conformance of ’Array<Element>’ to
          protocol ’Loggable’

     Grammar of an extension declaration

     extension-declaration → attributes _{opt} access-level-modifier
     _{opt} ‘extension’ type-identifier type-inheritance-clause _{opt}
     generic-where-clause _{opt} extension-body

     extension-body → ‘{’ extension-members _{opt} ‘}’

     extension-members → extension-member extension-members _{opt}

     extension-member → declaration
     compiler-control-statement


File: swift-reference.info,  Node: Subscript Declaration,  Next: Operator Declaration,  Prev: Extension Declaration,  Up: Declarations

7.15 Subscript Declaration
==========================

A _subscript_ declaration allows you to add subscripting support for
objects of a particular type and are typically used to provide a
convenient syntax for accessing the elements in a collection, list, or
sequence.  Subscript declarations are declared using the ‘subscript’
keyword and have the following form:

  1. subscript (parameters) -> return type {
  2. get {
  3. statements
  4. }
  5. set(setter name) {
  6. statements
  7. }
  8. }

   Subscript declarations can appear only in the context of a class,
structure, enumeration, extension, or protocol declaration.

   The _parameters_ specify one or more indexes used to access elements
of the corresponding type in a subscript expression (for example, the
‘i’ in the expression ‘object[i]’).  Although the indexes used to access
the elements can be of any type, each parameter must include a type
annotation to specify the type of each index.  The _return type_
specifies the type of the element being accessed.

   As with computed properties, subscript declarations support reading
and writing the value of the accessed elements.  The getter is used to
read the value, and the setter is used to write the value.  The setter
clause is optional, and when only a getter is needed, you can omit both
clauses and simply return the requested value directly.  That said, if
you provide a setter clause, you must also provide a getter clause.

   The _setter name_ and enclosing parentheses are optional.  If you
provide a setter name, it is used as the name of the parameter to the
setter.  If you do not provide a setter name, the default parameter name
to the setter is ‘value’.  The type of the parameter to the setter is
the same as the _return type_.

   You can overload a subscript declaration in the type in which it is
declared, as long as the _parameters_ or the _return type_ differ from
the one you’re overloading.  You can also override a subscript
declaration inherited from a superclass.  When you do so, you must mark
the overridden subscript declaration with the ‘override’ declaration
modifier.

   Subscript parameters follow the same rules as function parameters,
with two exceptions.  By default, the parameters used in subscripting
don’t have argument labels, unlike functions, methods, and initializers.
However, you can provide explicit argument labels using the same syntax
that functions, methods, and initializers use.  In addition, subscripts
can’t have in-out parameters.  A subscript parameter can have a default
value, using the syntax described in *note Special Kinds of
Parameters::.

   You can also declare subscripts in the context of a protocol
declaration, as described in *note Protocol Subscript Declaration:
Protocol Subscript Declaration.

   For more information about subscripting and to see examples of
subscript declarations, see *note Subscripts: (swift)Subscripts.

   Grammar of a subscript declaration

   subscript-declaration → subscript-head subscript-result
generic-where-clause _{opt} code-block

   subscript-declaration → subscript-head subscript-result
generic-where-clause _{opt} getter-setter-block

   subscript-declaration → subscript-head subscript-result
generic-where-clause _{opt} getter-setter-keyword-block

   subscript-head → attributes _{opt} declaration-modifiers _{opt}
‘subscript’ generic-parameter-clause _{opt} parameter-clause

   subscript-result → ‘->’ attributes _{opt} type


File: swift-reference.info,  Node: Operator Declaration,  Next: Precedence Group Declaration,  Prev: Subscript Declaration,  Up: Declarations

7.16 Operator Declaration
=========================

An _operator declaration_ introduces a new infix, prefix, or postfix
operator into your program and is declared using the ‘operator’ keyword.

   You can declare operators of three different fixities: infix, prefix,
and postfix.  The _fixity_ of an operator specifies the relative
position of an operator to its operands.

   There are three basic forms of an operator declaration, one for each
fixity.  The fixity of the operator is specified by marking the operator
declaration with the ‘infix’, ‘prefix’, or ‘postfix’ declaration
modifier before the ‘operator’ keyword.  In each form, the name of the
operator can contain only the operator characters defined in *note
Operators::.

   The following form declares a new infix operator:

  1. infix operator operator name: precedence group

   An _infix operator_ is a binary operator that is written between its
two operands, such as the familiar addition operator (‘+’) in the
expression ‘1 + 2’.

   Infix operators can optionally specify a precedence group.  If you
omit the precedence group for an operator, Swift uses the default
precedence group, ‘DefaultPrecedence’, which specifies a precedence just
higher than ‘TernaryPrecedence’.  For more information, see *note
Precedence Group Declaration::.

   The following form declares a new prefix operator:

  1. prefix operator operator name

   A _prefix operator_ is a unary operator that is written immediately
before its operand, such as the prefix logical NOT operator (‘!’) in the
expression ‘!a’.

   Prefix operators declarations don’t specify a precedence level.
Prefix operators are nonassociative.

   The following form declares a new postfix operator:

  1. postfix operator operator name

   A _postfix operator_ is a unary operator that is written immediately
after its operand, such as the postfix forced-unwrap operator (‘!’) in
the expression ‘a!’.

   As with prefix operators, postfix operator declarations don’t specify
a precedence level.  Postfix operators are nonassociative.

   After declaring a new operator, you implement it by declaring a
static method that has the same name as the operator.  The static method
is a member of one of the types whose values the operator takes as an
argument—for example, an operator that multiplies a ‘Double’ by an ‘Int’
is implemented as a static method on either the ‘Double’ or ‘Int’
structure.  If you’re implementing a prefix or postfix operator, you
must also mark that method declaration with the corresponding ‘prefix’
or ‘postfix’ declaration modifier.  To see an example of how to create
and implement a new operator, see *note Custom Operators: (swift)Custom
Operators.

   Grammar of an operator declaration

   operator-declaration → prefix-operator-declaration
   postfix-operator-declaration
   infix-operator-declaration

   prefix-operator-declaration → ‘prefix’ ‘operator’ operator

   postfix-operator-declaration → ‘postfix’ ‘operator’ operator

   infix-operator-declaration → ‘infix’ ‘operator’ operator
infix-operator-group _{opt}

   infix-operator-group → ‘:’ precedence-group-name


File: swift-reference.info,  Node: Precedence Group Declaration,  Next: Declaration Modifiers,  Prev: Operator Declaration,  Up: Declarations

7.17 Precedence Group Declaration
=================================

A _precedence group declaration_ introduces a new grouping for infix
operator precedence into your program.  The precedence of an operator
specifies how tightly the operator binds to its operands, in the absence
of grouping parentheses.

   A precedence group declaration has the following form:

  1. precedencegroup precedence group name {
  2. higherThan: lower group names
  3. lowerThan: higher group names
  4. associativity: associativity
  5. assignment: assignment
  6. }

   The _lower group names_ and _higher group names_ lists specify the
new precedence group’s relation to existing precedence groups.  The
‘lowerThan’ precedence group attribute may only be used to refer to
precedence groups declared outside of the current module.  When two
operators compete with each other for their operands, such as in the
expression ‘2 + 3 * 5’, the operator with the higher relative precedence
binds more tightly to its operands.

   Note

   Precedence groups related to each other using _lower group names_ and
_higher group names_ must fit into a single relational hierarchy, but
they _don’t_ have to form a linear hierarchy.  This means it is possible
to have precedence groups with undefined relative precedence.  Operators
from those precedence groups can’t be used next to each other without
grouping parentheses.

   Swift defines numerous precedence groups to go along with the
operators provided by the standard library.  For example, the addition
(‘+’) and subtraction (‘-’) operators belong to the ‘AdditionPrecedence’
group, and the multiplication (‘*’) and division (‘/’) operators belong
to the ‘MultiplicationPrecedence’ group.  For a complete list of
precedence groups provided by the Swift standard library, see Operator
Declarations
(https://developer.apple.com/documentation/swift/operator_declarations)
[<https://developer.apple.com/documentation/swift/operator_declarations>].

   The _associativity_ of an operator specifies how a sequence of
operators with the same precedence level are grouped together in the
absence of grouping parentheses.  You specify the associativity of an
operator by writing one of the context-sensitive keywords ‘left’,
‘right’, or ‘none’—if your omit the associativity, the default is
‘none’.  Operators that are left-associative group left-to-right.  For
example, the subtraction operator (‘-’) is left-associative, so the
expression ‘4 - 5 - 6’ is grouped as ‘(4 - 5) - 6’ and evaluates to
‘-7’.  Operators that are right-associative group right-to-left, and
operators that are specified with an associativity of ‘none’ don’t
associate at all.  Nonassociative operators of the same precedence level
can’t appear adjacent to each to other.  For example, the ‘<’ operator
has an associativity of ‘none’, which means ‘1 < 2 < 3’ is not a valid
expression.

   The _assignment_ of a precedence group specifies the precedence of an
operator when used in an operation that includes optional chaining.
When set to ‘true’, an operator in the corresponding precedence group
uses the same grouping rules during optional chaining as the assignment
operators from the standard library.  Otherwise, when set to ‘false’ or
omitted, operators in the precedence group follows the same optional
chaining rules as operators that don’t perform assignment.

   Grammar of a precedence group declaration

   precedence-group-declaration → ‘precedencegroup’
precedence-group-name ‘{’ precedence-group-attributes _{opt} ‘}’

   precedence-group-attributes → precedence-group-attribute
precedence-group-attributes _{opt}

   precedence-group-attribute → precedence-group-relation

   precedence-group-attribute → precedence-group-assignment

   precedence-group-attribute → precedence-group-associativity

   precedence-group-relation → ‘higherThan’ ‘:’ precedence-group-names

   precedence-group-relation → ‘lowerThan’ ‘:’ precedence-group-names

   precedence-group-assignment → ‘assignment’ ‘:’ boolean-literal

   precedence-group-associativity → ‘associativity’ ‘:’ ‘left’

   precedence-group-associativity → ‘associativity’ ‘:’ ‘right’

   precedence-group-associativity → ‘associativity’ ‘:’ ‘none’

   precedence-group-names → precedence-group-name
   precedence-group-name ‘,’ precedence-group-names

   precedence-group-name → identifier


File: swift-reference.info,  Node: Declaration Modifiers,  Prev: Precedence Group Declaration,  Up: Declarations

7.18 Declaration Modifiers
==========================

_Declaration modifiers_ are keywords or context-sensitive keywords that
modify the behavior or meaning of a declaration.  You specify a
declaration modifier by writing the appropriate keyword or
context-sensitive keyword between a declaration’s attributes (if any)
and the keyword that introduces the declaration.

‘class’
     Apply this modifier to a member of a class to indicate that the
     member is a member of the class itself, rather than a member of
     instances of the class.  Members of a superclass that have this
     modifier and don’t have the ‘final’ modifier can be overridden by
     subclasses.

‘dynamic’
     Apply this modifier to any member of a class that can be
     represented by Objective-C. When you mark a member declaration with
     the ‘dynamic’ modifier, access to that member is always dynamically
     dispatched using the Objective-C runtime.  Access to that member is
     never inlined or devirtualized by the compiler.

     Because declarations marked with the ‘dynamic’ modifier are
     dispatched using the Objective-C runtime, they must be marked with
     the ‘objc’ attribute.

‘final’
     Apply this modifier to a class or to a property, method, or
     subscript member of a class.  It’s applied to a class to indicate
     that the class can’t be subclassed.  It’s applied to a property,
     method, or subscript of a class to indicate that a class member
     can’t be overridden in any subclass.  For an example of how to use
     the ‘final’ attribute, see *note Preventing Overrides:
     (swift)Preventing Overrides.

‘lazy’
     Apply this modifier to a stored variable property of a class or
     structure to indicate that the property’s initial value is
     calculated and stored at most once, when the property is first
     accessed.  For an example of how to use the ‘lazy’ modifier, see
     *note Lazy Stored Properties: (swift)Lazy Stored Properties.

‘optional’
     Apply this modifier to a protocol’s property, method, or subscript
     members to indicate that a conforming type isn’t required to
     implement those members.

     You can apply the ‘optional’ modifier only to protocols that are
     marked with the ‘objc’ attribute.  As a result, only class types
     can adopt and conform to a protocol that contains optional member
     requirements.  For more information about how to use the ‘optional’
     modifier and for guidance about how to access optional protocol
     members—for example, when you’re not sure whether a conforming type
     implements them—see *note Optional Protocol Requirements:
     (swift)Optional Protocol Requirements.

‘required’
     Apply this modifier to a designated or convenience initializer of a
     class to indicate that every subclass must implement that
     initializer.  The subclass’s implementation of that initializer
     must also be marked with the ‘required’ modifier.

‘static’
     Apply this modifier to a member of a structure, class, enumeration,
     or protocol to indicate that the member is a member of the type,
     rather than a member of instances of that type.  In the scope of a
     class declaration, writing the ‘static’ modifier on a member
     declaration has the same effect as writing the ‘class’ and ‘final’
     modifiers on that member declaration.  However, constant type
     properties of a class are an exception: ‘static’ has its normal,
     nonclass meaning there because you can’t write ‘class’ or ‘final’
     on those declarations.

‘unowned’
     Apply this modifier to a stored variable, constant, or stored
     property to indicate that the variable or property has an unowned
     reference to the object stored as its value.  If you try to access
     the variable or property after the object has been deallocated, a
     runtime error is raised.  Like a weak reference, the type of the
     property or value must be a class type; unlike a weak reference,
     the type is non-optional.  For an example and more information
     about the ‘unowned’ modifier, see *note Unowned References:
     (swift)Unowned References.

‘unowned(safe)’
     An explicit spelling of ‘unowned’.

‘unowned(unsafe)’
     Apply this modifier to a stored variable, constant, or stored
     property to indicate that the variable or property has an unowned
     reference to the object stored as its value.  If you try to access
     the variable or property after the object has been deallocated,
     you’ll access the memory at the location where the object used to
     be, which is a memory-unsafe operation.  Like a weak reference, the
     type of the property or value must be a class type; unlike a weak
     reference, the type is non-optional.  For an example and more
     information about the ‘unowned’ modifier, see *note Unowned
     References: (swift)Unowned References.

‘weak’
     Apply this modifier to a stored variable or stored variable
     property to indicate that the variable or property has a weak
     reference to the object stored as its value.  The type of the
     variable or property must be an optional class type.  If you access
     the variable or property after the object has been deallocated, its
     value is ‘nil’.  For an example and more information about the
     ‘weak’ modifier, see *note Weak References: (swift)Weak References.

* Menu:

* Access Control Levels::


File: swift-reference.info,  Node: Access Control Levels,  Up: Declaration Modifiers

7.18.1 Access Control Levels
----------------------------

Swift provides five levels of access control: open, public, internal,
file private, and private.  You can mark a declaration with one of the
access-level modifiers below to specify the declaration’s access level.
Access control is discussed in detail in *note Access Control:
(swift)Access Control.

‘open’
     Apply this modifier to a declaration to indicate the declaration
     can be accessed and subclassed by code in the same module as the
     declaration.  Declarations marked with the ‘open’ access-level
     modifier can also be accessed and subclassed by code in a module
     that imports the module that contains that declaration.

‘public’
     Apply this modifier to a declaration to indicate the declaration
     can be accessed and subclassed by code in the same module as the
     declaration.  Declarations marked with the ‘public’ access-level
     modifier can also be accessed (but not subclassed) by code in a
     module that imports the module that contains that declaration.

‘internal’
     Apply this modifier to a declaration to indicate the declaration
     can be accessed only by code in the same module as the declaration.
     By default, most declarations are implicitly marked with the
     ‘internal’ access-level modifier.

‘fileprivate’
     Apply this modifier to a declaration to indicate the declaration
     can be accessed only by code in the same source file as the
     declaration.

‘private’
     Apply this modifier to a declaration to indicate the declaration
     can be accessed only by code within the declaration’s immediate
     enclosing scope.

   For the purpose of access control, extensions to the same type that
are in the same file share an access-control scope.  If the type they
extend is also in the same file, they share the type’s access-control
scope.  Private members declared in the type’s declaration can be
accessed from extensions, and private members declared in one extension
can be accessed from other extensions and from the type’s declaration.

   Each access-level modifier above optionally accepts a single
argument, which consists of the ‘set’ keyword enclosed in parentheses
(for example, ‘private(set)’).  Use this form of an access-level
modifier when you want to specify an access level for the setter of a
variable or subscript that’s less than or equal to the access level of
the variable or subscript itself, as discussed in *note Getters and
Setters: (swift)Getters and Setters.

   Grammar of a declaration modifier

   declaration-modifier → ‘class’ | ‘convenience’ | ‘dynamic’ | ‘final’
| ‘infix’ | ‘lazy’ | ‘optional’ | ‘override’ | ‘postfix’ | ‘prefix’ |
‘required’ | ‘static’ | ‘unowned’ | ‘unowned’ ‘(’ ‘safe’ ‘)’ | ‘unowned’
‘(’ ‘unsafe’ ‘)’ | ‘weak’

   declaration-modifier → access-level-modifier

   declaration-modifier → mutation-modifier

   declaration-modifiers → declaration-modifier declaration-modifiers
_{opt}

   access-level-modifier → ‘private’ | ‘private’ ‘(’ ‘set’ ‘)’

   access-level-modifier → ‘fileprivate’ | ‘fileprivate’ ‘(’ ‘set’ ‘)’

   access-level-modifier → ‘internal’ | ‘internal’ ‘(’ ‘set’ ‘)’

   access-level-modifier → ‘public’ | ‘public’ ‘(’ ‘set’ ‘)’

   access-level-modifier → ‘open’ | ‘open’ ‘(’ ‘set’ ‘)’

   mutation-modifier → ‘mutating’ | ‘nonmutating’


File: swift-reference.info,  Node: Attributes,  Next: Patterns,  Prev: Declarations,  Up: Top

8 Attributes
************

There are two kinds of attributes in Swift—those that apply to
declarations and those that apply to types.  An attribute provides
additional information about the declaration or type.  For example, the
‘discardableResult’ attribute on a function declaration indicates that,
although the function returns a value, the compiler shouldn’t generate a
warning if the return value is unused.

   You specify an attribute by writing the ‘@’ symbol followed by the
attribute’s name and any arguments that the attribute accepts:

  1. @attribute name
  2. @attribute name(attribute arguments)

   Some declaration attributes accept arguments that specify more
information about the attribute and how it applies to a particular
declaration.  These _attribute arguments_ are enclosed in parentheses,
and their format is defined by the attribute they belong to.

* Menu:

* Declaration Attributes::
* Type Attributes::
* Switch Case Attributes::


File: swift-reference.info,  Node: Declaration Attributes,  Next: Type Attributes,  Up: Attributes

8.1 Declaration Attributes
==========================

You can apply a declaration attribute to declarations only.

* Menu:

* available::
* discardableResult::
* dynamicCallable::
* dynamicMemberLookup::
* frozen::
* GKInspectable::
* inlinable::
* nonobjc::
* NSApplicationMain::
* NSCopying::
* NSManaged::
* objc::
* objcMembers::
* propertyWrapper::
* requires_stored_property_inits::
* testable::
* UIApplicationMain::
* usableFromInline::
* warn_unqualified_access::
* Declaration Attributes Used by Interface Builder::


File: swift-reference.info,  Node: available,  Next: discardableResult,  Up: Declaration Attributes

8.1.1 available
---------------

Apply this attribute to indicate a declaration’s life cycle relative to
certain Swift language versions or certain platforms and operating
system versions.

   The ‘available’ attribute always appears with a list of two or more
comma-separated attribute arguments.  These arguments begin with one of
the following platform or language names:

   • ‘iOS’

   • ‘iOSApplicationExtension’

   • ‘macOS’

   • ‘macOSApplicationExtension’

   • ‘watchOS’

   • ‘watchOSApplicationExtension’

   • ‘tvOS’

   • ‘tvOSApplicationExtension’

   • ‘swift’

   You can also use an asterisk (‘*’) to indicate the availability of
the declaration on all of the platform names listed above.  An
‘available’ attribute that specifies availability using a Swift version
number can’t use the asterisk.

   The remaining arguments can appear in any order and specify
additional information about the declaration’s life cycle, including
important milestones.

   • The ‘unavailable’ argument indicates that the declaration isn’t
     available on the specified platform.  This argument can’t be used
     when specifying Swift version availability.

   • The ‘introduced’ argument indicates the first version of the
     specified platform or language in which the declaration was
     introduced.  It has the following form:

       1. introduced: version number

     The _version number_ consists of one to three positive integers,
     separated by periods.

   • The ‘deprecated’ argument indicates the first version of the
     specified platform or language in which the declaration was
     deprecated.  It has the following form:

       1. deprecated: version number

     The optional _version number_ consists of one to three positive
     integers, separated by periods.  Omitting the version number
     indicates that the declaration is currently deprecated, without
     giving any information about when the deprecation occurred.  If you
     omit the version number, omit the colon (‘:’) as well.

   • The ‘obsoleted’ argument indicates the first version of the
     specified platform or language in which the declaration was
     obsoleted.  When a declaration is obsoleted, it’s removed from the
     specified platform or language and can no longer be used.  It has
     the following form:

       1. obsoleted: version number

     The _version number_ consists of one to three positive integers,
     separated by periods.

   • The ‘message’ argument provides a textual message that the compiler
     displays when emitting a warning or error about the use of a
     deprecated or obsoleted declaration.  It has the following form:

       1. message: message

     The _message_ consists of a string literal.

   • The ‘renamed’ argument provides a textual message that indicates
     the new name for a declaration that’s been renamed.  The compiler
     displays the new name when emitting an error about the use of a
     renamed declaration.  It has the following form:

       1. renamed: new name

     The _new name_ consists of a string literal.

     You can apply the ‘available’ attribute with the ‘renamed’ and
     ‘unavailable’ arguments to a type alias declaration, as shown
     below, to indicate that the name of a declaration changed between
     releases of a framework or library.  This combination results in a
     compile-time error that the declaration has been renamed.

       1. // First release
       2. protocol MyProtocol {
       3. // protocol definition
       4. }

       5. // Subsequent release renames MyProtocol
       6. protocol MyRenamedProtocol {
       7. // protocol definition
       8. }
       9. 
       10. @available(*, unavailable, renamed: "MyRenamedProtocol")
       11. typealias MyProtocol = MyRenamedProtocol

   You can apply multiple ‘available’ attributes on a single declaration
to specify the declaration’s availability on different platforms and
different versions of Swift.  The declaration that the ‘available’
attribute applies to is ignored if the attribute specifies a platform or
language version that doesn’t match the current target.  If you use
multiple ‘available’ attributes, the effective availability is the
combination of the platform and Swift availabilities.

   If an ‘available’ attribute only specifies an ‘introduced’ argument
in addition to a platform or language name argument, you can use the
following shorthand syntax instead:

  1. @available(platform name version number, *)
  2. @available(swift version number)

   The shorthand syntax for ‘available’ attributes concisely expresses
availability for multiple platforms.  Although the two forms are
functionally equivalent, the shorthand form is preferred whenever
possible.

  1. @available(iOS 10.0, macOS 10.12, *)
  2. class MyClass {
  3. // class definition
  4. }

   An ‘available’ attribute that specifies availability using a Swift
version number can’t additionally specify a declaration’s platform
availability.  Instead, use separate ‘available’ attributes to specify a
Swift version availability and one or more platform availabilities.

  1. @available(swift 3.0.2)
  2. @available(macOS 10.12, *)
  3. struct MyStruct {
  4. // struct definition
  5. }


File: swift-reference.info,  Node: discardableResult,  Next: dynamicCallable,  Prev: available,  Up: Declaration Attributes

8.1.2 discardableResult
-----------------------

Apply this attribute to a function or method declaration to suppress the
compiler warning when the function or method that returns a value is
called without using its result.


File: swift-reference.info,  Node: dynamicCallable,  Next: dynamicMemberLookup,  Prev: discardableResult,  Up: Declaration Attributes

8.1.3 dynamicCallable
---------------------

Apply this attribute to a class, structure, enumeration, or protocol to
treat instances of the type as callable functions.  The type must
implement either a ‘dynamicallyCall(withArguments:)’ method, a
‘dynamicallyCall(withKeywordArguments:)’ method, or both.

   You can call an instance of a dynamically callable type as if it’s a
function that takes any number of arguments.

  1. @dynamicCallable
  2. struct TelephoneExchange {
  3. func dynamicallyCall(withArguments phoneNumber: [Int]) {
  4. if phoneNumber == [4, 1, 1] {
  5. print("Get Swift help on forums.swift.org")
  6. } else {
  7. print("Unrecognized number")
  8. }
  9. }
  10. }
  11. 
  12. let dial = TelephoneExchange()
  13. 
  14. // Use a dynamic method call.
  15. dial(4, 1, 1)
  16. // Prints "Get Swift help on forums.swift.org"
  17. 
  18. dial(8, 6, 7, 5, 3, 0, 9)
  19. // Prints "Unrecognized number"
  20. 
  21. // Call the underlying method directly.
  22. dial.dynamicallyCall(withArguments: [4, 1, 1])

   The declaration of the ‘dynamicallyCall(withArguments:)’ method must
have a single parameter that conforms to the ‘ExpressibleByArrayLiteral’
(https://developer.apple.com/documentation/swift/expressiblebyarrayliteral)
[<https://developer.apple.com/documentation/swift/expressiblebyarrayliteral>]
protocol—like ‘[Int]’ in the example above.  The return type can be any
type.

   You can include labels in a dynamic method call if you implement the
‘dynamicallyCall(withKeywordArguments:)’ method.

  1. @dynamicCallable
  2. struct Repeater {
  3. func dynamicallyCall(withKeywordArguments pairs:
     KeyValuePairs<String, Int>) -> String {
  4. return pairs
  5. .map { label, count in
  6. repeatElement(label, count: count).joined(separator: " ")
  7. }
  8. .joined(separator: "")
  9. }
  10. }
  11. 
  12. let repeatLabels = Repeater()
  13. print(repeatLabels(a: 1, b: 2, c: 3, b: 2, a: 1))
  14. // a
  15. // b b
  16. // c c c
  17. // b b
  18. // a

   The declaration of the ‘dynamicallyCall(withKeywordArguments:)’
method must have a single parameter that conforms to the
‘ExpressibleByDictionaryLiteral’
(https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral)
[<https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral>]
protocol, and the return type can be any type.  The parameter’s ‘Key’
(https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key)
[<https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key>]
must be ‘ExpressibleByStringLiteral’
(https://developer.apple.com/documentation/swift/expressiblebystringliteral)
[<https://developer.apple.com/documentation/swift/expressiblebystringliteral>].
The previous example uses ‘KeyValuePairs’
(https://developer.apple.com/documentation/swift/keyvaluepairs)
[<https://developer.apple.com/documentation/swift/keyvaluepairs>] as the
parameter type so that callers can include duplicate parameter
labels—‘a’ and ‘b’ appear multiple times in the call to ‘repeat’.

   If you implement both ‘dynamicallyCall’ methods,
‘dynamicallyCall(withKeywordArguments:)’ is called when the method call
includes keyword arguments.  In all other cases,
‘dynamicallyCall(withArguments:)’ is called.

   You can only call a dynamically callable instance with arguments and
a return value that match the types you specify in one of your
‘dynamicallyCall’ method implementations.  The call in the following
example doesn’t compile because there isn’t an implementation of
‘dynamicallyCall(withArguments:)’ that takes ‘KeyValuePairs<String,
String>’.

  1. repeatLabels(a: "four") // Error


File: swift-reference.info,  Node: dynamicMemberLookup,  Next: frozen,  Prev: dynamicCallable,  Up: Declaration Attributes

8.1.4 dynamicMemberLookup
-------------------------

Apply this attribute to a class, structure, enumeration, or protocol to
enable members to be looked up by name at runtime.  The type must
implement a ‘subscript(dynamicMemberLookup:)’ subscript.

   In an explicit member expression, if there isn’t a corresponding
declaration for the named member, the expression is understood as a call
to the type’s ‘subscript(dynamicMemberLookup:)’ subscript, passing
information about the member as the argument.  The subscript can accept
a parameter that’s either a key path or a member name; if you implement
both subscripts, the subscript that takes key path argument is used.

   An implementation of ‘subscript(dynamicMemberLookup:)’ can accept key
paths using an argument of type ‘KeyPath’
(https://developer.apple.com/documentation/swift/keypath)
[<https://developer.apple.com/documentation/swift/keypath>],
‘WritableKeyPath’
(https://developer.apple.com/documentation/swift/writablekeypath)
[<https://developer.apple.com/documentation/swift/writablekeypath>], or
‘ReferenceWritableKeyPath’
(https://developer.apple.com/documentation/swift/referencewritablekeypath)
[<https://developer.apple.com/documentation/swift/referencewritablekeypath>].
It can accept member names using an argument of a type that conforms to
the ‘ExpressibleByStringLiteral’
(https://developer.apple.com/documentation/swift/expressiblebystringliteral)
[<https://developer.apple.com/documentation/swift/expressiblebystringliteral>]
protocol—in most cases, ‘String’.  The subscript’s return type can be
any type.

   Dynamic member lookup by member name can be used to create a wrapper
type around data that can’t be type checked at compile time, such as
when bridging data from other languages into Swift.  For example:

  1. @dynamicMemberLookup
  2. struct DynamicStruct {
  3. let dictionary = ["someDynamicMember": 325,
  4. "someOtherMember": 787]
  5. subscript(dynamicMember member: String) -> Int {
  6. return dictionary[member] ??  1054
  7. }
  8. }
  9. let s = DynamicStruct()
  10. 
  11. // Use dynamic member lookup.
  12. let dynamic = s.someDynamicMember
  13. print(dynamic)
  14. // Prints "325"
  15. 
  16. // Call the underlying subscript directly.
  17. let equivalent = s[dynamicMember: "someDynamicMember"]
  18. print(dynamic == equivalent)
  19. // Prints "true"


File: swift-reference.info,  Node: frozen,  Next: GKInspectable,  Prev: dynamicMemberLookup,  Up: Declaration Attributes

8.1.5 frozen
------------

Apply this attribute to a structure or enumeration declaration to
restrict the kinds of changes you can make to the type.  This attribute
is allowed only when compiling in library evolution mode.  Future
versions of the library can’t change the declaration by adding,
removing, or reordering an enumeration’s cases or a structure’s stored
instance properties.  These changes are allowed on nonfrozen types, but
they break ABI compatibility for frozen types.

   Note

   When the compiler isn’t in library evolution mode, all structures and
enumerations are implicitly frozen, and this attribute is ignored.

   In library evolution mode, code that interacts with members of
nonfrozen structures and enumerations is compiled in a way that allows
it to continue working without recompiling even if a future version of
the library adds, removes, or reorders some of that type’s members.  The
compiler makes this possible using techniques like looking up
information at runtime and adding a layer of indirection.  Marking a
structure or enumeration as frozen gives up this flexibility to gain
performance: Future versions of the library can make only limited
changes to the type, but the compiler can make additional optimizations
in code that interacts with the type’s members.

   Frozen types, the types of the stored properties of frozen
structures, and the associated values of frozen enumeration cases must
be public or marked with the ‘usableFromInline’ attribute.  The
properties of a frozen structure can’t have property observers, and
expressions that provide the initial value for stored instance
properties must follow the same restrictions as inlinable functions, as
discussed in *note inlinable::.

   To enable library evolution mode on the command line, pass the
‘-enable-library-evolution’ option to the Swift compiler.  To enable it
in Xcode, set the “Build Libraries for Distribution” build setting
(‘BUILD_LIBRARY_FOR_DISTRIBUTION’) to Yes, as described in Xcode Help
(https://help.apple.com/xcode/mac/current/#/dev04b3a04ba)
[<https://help.apple.com/xcode/mac/current/#/dev04b3a04ba>].

   A switch statement over a frozen enumeration doesn’t require a
‘default’ case, as discussed in Switching Over Future Enumeration Cases.
Including a ‘default’ or ‘@unknown default’ case when switching over a
frozen enumeration produces a warning because that code is never
executed.


File: swift-reference.info,  Node: GKInspectable,  Next: inlinable,  Prev: frozen,  Up: Declaration Attributes

8.1.6 GKInspectable
-------------------

Apply this attribute to expose a custom GameplayKit component property
to the SpriteKit editor UI. Applying this attribute also implies the
‘objc’ attribute.


File: swift-reference.info,  Node: inlinable,  Next: nonobjc,  Prev: GKInspectable,  Up: Declaration Attributes

8.1.7 inlinable
---------------

Apply this attribute to a function, method, computed property,
subscript, convenience initializer, or deinitializer declaration to
expose that declaration’s implementation as part of the module’s public
interface.  The compiler is allowed to replace calls to an inlinable
symbol with a copy of the symbol’s implementation at the call site.

   Inlinable code can interact with ‘public’ symbols declared in any
module, and it can interact with ‘internal’ symbols declared in the same
module that are marked with the ‘usableFromInline’ attribute.  Inlinable
code can’t interact with ‘private’ or ‘fileprivate’ symbols.

   This attribute can’t be applied to declarations that are nested
inside functions or to ‘fileprivate’ or ‘private’ declarations.
Functions and closures that are defined inside an inlinable function are
implicitly inlinable, even though they can’t be marked with this
attribute.


File: swift-reference.info,  Node: nonobjc,  Next: NSApplicationMain,  Prev: inlinable,  Up: Declaration Attributes

8.1.8 nonobjc
-------------

Apply this attribute to a method, property, subscript, or initializer
declaration to suppress an implicit ‘objc’ attribute.  The ‘nonobjc’
attribute tells the compiler to make the declaration unavailable in
Objective-C code, even though it’s possible to represent it in
Objective-C.

   Applying this attribute to an extension has the same effect as
applying it to every member of that extension that isn’t explicitly
marked with the ‘objc’ attribute.

   You use the ‘nonobjc’ attribute to resolve circularity for bridging
methods in a class marked with the ‘objc’ attribute, and to allow
overloading of methods and initializers in a class marked with the
‘objc’ attribute.

   A method marked with the ‘nonobjc’ attribute can’t override a method
marked with the ‘objc’ attribute.  However, a method marked with the
‘objc’ attribute can override a method marked with the ‘nonobjc’
attribute.  Similarly, a method marked with the ‘nonobjc’ attribute
can’t satisfy a protocol requirement for a method marked with the ‘objc’
attribute.


File: swift-reference.info,  Node: NSApplicationMain,  Next: NSCopying,  Prev: nonobjc,  Up: Declaration Attributes

8.1.9 NSApplicationMain
-----------------------

Apply this attribute to a class to indicate that it’s the application
delegate.  Using this attribute is equivalent to calling the
‘NSApplicationMain(_:_:)’ function.

   If you don’t use this attribute, supply a ‘main.swift’ file with code
at the top level that calls the ‘NSApplicationMain(_:_:)’ function as
follows:

  1. import AppKit
  2. NSApplicationMain(CommandLine.argc, CommandLine.unsafeArgv)


File: swift-reference.info,  Node: NSCopying,  Next: NSManaged,  Prev: NSApplicationMain,  Up: Declaration Attributes

8.1.10 NSCopying
----------------

Apply this attribute to a stored variable property of a class.  This
attribute causes the property’s setter to be synthesized with a _copy_
of the property’s value—returned by the ‘copyWithZone(_:)’
method—instead of the value of the property itself.  The type of the
property must conform to the ‘NSCopying’ protocol.

   The ‘NSCopying’ attribute behaves in a way similar to the Objective-C
‘copy’ property attribute.


File: swift-reference.info,  Node: NSManaged,  Next: objc,  Prev: NSCopying,  Up: Declaration Attributes

8.1.11 NSManaged
----------------

Apply this attribute to an instance method or stored variable property
of a class that inherits from ‘NSManagedObject’ to indicate that Core
Data dynamically provides its implementation at runtime, based on the
associated entity description.  For a property marked with the
‘NSManaged’ attribute, Core Data also provides the storage at runtime.
Applying this attribute also implies the ‘objc’ attribute.


File: swift-reference.info,  Node: objc,  Next: objcMembers,  Prev: NSManaged,  Up: Declaration Attributes

8.1.12 objc
-----------

Apply this attribute to any declaration that can be represented in
Objective-C—for example, nonnested classes, protocols, nongeneric
enumerations (constrained to integer raw-value types), properties and
methods (including getters and setters) of classes, protocols and
optional members of a protocol, initializers, and subscripts.  The
‘objc’ attribute tells the compiler that a declaration is available to
use in Objective-C code.

   Applying this attribute to an extension has the same effect as
applying it to every member of that extension that isn’t explicitly
marked with the ‘nonobjc’ attribute.

   The compiler implicitly adds the ‘objc’ attribute to subclasses of
any class defined in Objective-C. However, the subclass must not be
generic, and must not inherit from any generic classes.  You can
explicitly add the ‘objc’ attribute to a subclass that meets these
criteria, to specify its Objective-C name as discussed below.  Protocols
that are marked with the ‘objc’ attribute can’t inherit from protocols
that aren’t marked with this attribute.

   The ‘objc’ attribute is also implicitly added in the following cases:

   • The declaration is an override in a subclass, and the superclass’s
     declaration has the ‘objc’ attribute.

   • The declaration satisfies a requirement from a protocol that has
     the ‘objc’ attribute.

   • The declaration has the ‘IBAction’, ‘IBSegueAction’, ‘IBOutlet’,
     ‘IBDesignable’, ‘IBInspectable’, ‘NSManaged’, or ‘GKInspectable’
     attribute.

   If you apply the ‘objc’ attribute to an enumeration, each enumeration
case is exposed to Objective-C code as the concatenation of the
enumeration name and the case name.  The first letter of the case name
is capitalized.  For example, a case named ‘venus’ in a Swift ‘Planet’
enumeration is exposed to Objective-C code as a case named
‘PlanetVenus’.

   The ‘objc’ attribute optionally accepts a single attribute argument,
which consists of an identifier.  The identifier specifies the name to
be exposed to Objective-C for the entity that the ‘objc’ attribute
applies to.  You can use this argument to name classes, enumerations,
enumeration cases, protocols, methods, getters, setters, and
initializers.  If you specify the Objective-C name for a class,
protocol, or enumeration, include a three-letter prefix on the name, as
described in Conventions
(https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1)
[<https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1>]
in Programming with Objective-C
(https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210)
[<https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210>].
The example below exposes the getter for the ‘enabled’ property of the
‘ExampleClass’ to Objective-C code as ‘isEnabled’ rather than just as
the name of the property itself.

  1. class ExampleClass: NSObject {
  2. @objc var enabled: Bool {
  3. @objc(isEnabled) get {
  4. // Return the appropriate value
  5. }
  6. }
  7. }

   For more information, see Importing Swift into Objective-C
(https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c)
[<https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c>].

   Note

   The argument to the ‘objc’ attribute can also change the runtime name
for that declaration.  You use the runtime name when calling functions
that interact with the Objective-C runtime, like ‘NSClassFromString’
(https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring)
[<https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring>],
and when specifying class names in an app’s Info.plist file.  If you
specify a name by passing an argument, that name is used as the name in
Objective-C code and as the runtime name.  If you omit the argument, the
name used in Objective-C code matches the name in Swift code, and the
runtime name follows the normal Swift compiler convention of name
mangling.


File: swift-reference.info,  Node: objcMembers,  Next: propertyWrapper,  Prev: objc,  Up: Declaration Attributes

8.1.13 objcMembers
------------------

Apply this attribute to a class declaration, to implicitly apply the
‘objc’ attribute to all Objective-C compatible members of the class, its
extensions, its subclasses, and all of the extensions of its subclasses.

   Most code should use the ‘objc’ attribute instead, to expose only the
declarations that are needed.  If you need to expose many declarations,
you can group them in an extension that has the ‘objc’ attribute.  The
‘objcMembers’ attribute is a convenience for libraries that make heavy
use of the introspection facilities of the Objective-C runtime.
Applying the ‘objc’ attribute when it isn’t needed can increase your
binary size and adversely affect performance.


File: swift-reference.info,  Node: propertyWrapper,  Next: requires_stored_property_inits,  Prev: objcMembers,  Up: Declaration Attributes

8.1.14 propertyWrapper
----------------------

Apply this attribute to a class, structure, or enumeration declaration
to use that type as a property wrapper.  When you apply this attribute
to a type, you create a custom attribute with the same name as the type.
Apply that new attribute to a property of a class, structure, or
enumeration to wrap access to the property through an instance of the
wrapper type.  Local and global variables can’t use property wrappers.

   The wrapper must define a ‘wrappedValue’ instance property.  The
_wrapped value_ of the property is the value that the getter and setter
for this property expose.  In most cases, ‘wrappedValue’ is a computed
value, but it can be a stored value instead.  The wrapper is responsible
for defining and managing any underlying storage needed by its wrapped
value.  The compiler synthesizes storage for the instance of the wrapper
type by prefixing the name of the wrapped property with an underscore
(‘_’)—for example, the wrapper for ‘someProperty’ is stored as
‘_someProperty’.  The synthesized storage for the wrapper has an access
control level of ‘private’.

   A property that has a property wrapper can include ‘willSet’ and
‘didSet’ blocks, but it can’t override the compiler-synthesized ‘get’ or
‘set’ blocks.

   Swift provides two forms of syntactic sugar for initialization of a
property wrapper.  You can use assignment syntax in the definition of a
wrapped value to pass the expression on the right-hand side of the
assignment as the argument to the ‘wrappedValue’ parameter of the
property wrapper’s initializer.  You can also provide arguments to the
attribute when you apply it to a property, and those arguments are
passed to the property wrapper’s initializer.  For example, in the code
below, ‘SomeStruct’ calls each of the initializers that ‘SomeWrapper’
defines.

  1. @propertyWrapper
  2. struct SomeWrapper {
  3. var wrappedValue: Int
  4. var someValue: Double
  5. init() {
  6. self.wrappedValue = 100
  7. self.someValue = 12.3
  8. }
  9. init(wrappedValue: Int) {
  10. self.wrappedValue = wrappedValue
  11. self.someValue = 45.6
  12. }
  13. init(wrappedValue value: Int, custom: Double) {
  14. self.wrappedValue = value
  15. self.someValue = custom
  16. }
  17. }
  18. 
  19. struct SomeStruct {
  20. // Uses init()
  21. @SomeWrapper var a: Int
  22. 
  23. // Uses init(wrappedValue:)
  24. @SomeWrapper var b = 10
  25. 
  26. // Both use init(wrappedValue:custom:)
  27. @SomeWrapper(custom: 98.7) var c = 30
  28. @SomeWrapper(wrappedValue: 30, custom: 98.7) var d
  29. }

   The _projected value_ for a wrapped property is a second value that a
property wrapper can use to expose additional functionality.  The author
of a property wrapper type is responsible for determining the meaning of
its projected value and defining the interface that the projected value
exposes.  To project a value from a property wrapper, define a
‘projectedValue’ instance property on the wrapper type.  The compiler
synthesizes an identifier for the projected value by prefixing the name
of the wrapped property with a dollar sign (‘$’)—for example, the
projected value for ‘someProperty’ is ‘$someProperty’.  The projected
value has the same access control level as the original wrapped
property.

  1. @propertyWrapper
  2. struct WrapperWithProjection {
  3. var wrappedValue: Int
  4. var projectedValue: SomeProjection {
  5. return SomeProjection(wrapper: self)
  6. }
  7. }
  8. struct SomeProjection {
  9. var wrapper: WrapperWithProjection
  10. }
  11. 
  12. struct SomeStruct {
  13. @WrapperWithProjection var x = 123
  14. }
  15. let s = SomeStruct()
  16. s.x // Int value
  17. s.$x // SomeProjection value
  18. s.$x.wrapper // WrapperWithProjection value


File: swift-reference.info,  Node: requires_stored_property_inits,  Next: testable,  Prev: propertyWrapper,  Up: Declaration Attributes

8.1.15 requires_stored_property_inits
-------------------------------------

Apply this attribute to a class declaration to require all stored
properties within the class to provide default values as part of their
definitions.  This attribute is inferred for any class that inherits
from ‘NSManagedObject’.


File: swift-reference.info,  Node: testable,  Next: UIApplicationMain,  Prev: requires_stored_property_inits,  Up: Declaration Attributes

8.1.16 testable
---------------

Apply this attribute to an ‘import’ declaration to import that module
with changes to its access control that simplify testing the module’s
code.  Entities in the imported module that are marked with the
‘internal’ access-level modifier are imported as if they were declared
with the ‘public’ access-level modifier.  Classes and class members that
are marked with the ‘internal’ or ‘public’ access-level modifier are
imported as if they were declared with the ‘open’ access-level modifier.
The imported module must be compiled with testing enabled.


File: swift-reference.info,  Node: UIApplicationMain,  Next: usableFromInline,  Prev: testable,  Up: Declaration Attributes

8.1.17 UIApplicationMain
------------------------

Apply this attribute to a class to indicate that it’s the application
delegate.  Using this attribute is equivalent to calling the
‘UIApplicationMain’ function and passing this class’s name as the name
of the delegate class.

   If you don’t use this attribute, supply a ‘main.swift’ file with code
at the top level that calls the ‘UIApplicationMain(_:_:_:_:)’
(https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain)
[<https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain>]
function.  For example, if your app uses a custom subclass of
‘UIApplication’ as its principal class, call the
‘UIApplicationMain(_:_:_:_:)’ function instead of using this attribute.


File: swift-reference.info,  Node: usableFromInline,  Next: warn_unqualified_access,  Prev: UIApplicationMain,  Up: Declaration Attributes

8.1.18 usableFromInline
-----------------------

Apply this attribute to a function, method, computed property,
subscript, initializer, or deinitializer declaration to allow that
symbol to be used in inlinable code that’s defined in the same module as
the declaration.  The declaration must have the ‘internal’ access level
modifier.  A structure or class marked ‘usableFromInline’ can use only
types that are public or ‘usableFromInline’ for its properties.  An
enumeration marked ‘usableFromInline’ can use only types that are public
or ‘usableFromInline’ for the raw values and associated values of its
cases.

   Like the ‘public’ access level modifier, this attribute exposes the
declaration as part of the module’s public interface.  Unlike ‘public’,
the compiler doesn’t allow declarations marked with ‘usableFromInline’
to be referenced by name in code outside the module, even though the
declaration’s symbol is exported.  However, code outside the module
might still be able to interact with the declaration’s symbol by using
runtime behavior.

   Declarations marked with the ‘inlinable’ attribute are implicitly
usable from inlinable code.  Although either ‘inlinable’ or
‘usableFromInline’ can be applied to ‘internal’ declarations, applying
both attributes is an error.


File: swift-reference.info,  Node: warn_unqualified_access,  Next: Declaration Attributes Used by Interface Builder,  Prev: usableFromInline,  Up: Declaration Attributes

8.1.19 warn_unqualified_access
------------------------------

Apply this attribute to a top-level function, instance method, or class
or static method to trigger warnings when that function or method is
used without a preceding qualifier, such as a module name, type name, or
instance variable or constant.  Use this attribute to help discourage
ambiguity between functions with the same name that are accessible from
the same scope.

   For example, the Swift standard library includes both a top-level
‘min(_:_:)’
(https://developer.apple.com/documentation/swift/1538339-min/)
[<https://developer.apple.com/documentation/swift/1538339-min/>]
function and a ‘min()’
(https://developer.apple.com/documentation/swift/sequence/1641174-min)
[<https://developer.apple.com/documentation/swift/sequence/1641174-min>]
method for sequences with comparable elements.  The sequence method is
declared with the ‘warn_unqualified_access’ attribute to help reduce
confusion when attempting to use one or the other from within a
‘Sequence’ extension.


File: swift-reference.info,  Node: Declaration Attributes Used by Interface Builder,  Prev: warn_unqualified_access,  Up: Declaration Attributes

8.1.20 Declaration Attributes Used by Interface Builder
-------------------------------------------------------

Interface Builder attributes are declaration attributes used by
Interface Builder to synchronize with Xcode.  Swift provides the
following Interface Builder attributes: ‘IBAction’, ‘IBSegueAction’,
‘IBOutlet’, ‘IBDesignable’, and ‘IBInspectable’.  These attributes are
conceptually the same as their Objective-C counterparts.

   You apply the ‘IBOutlet’ and ‘IBInspectable’ attributes to property
declarations of a class.  You apply the ‘IBAction’ and ‘IBSegueAction’
attribute to method declarations of a class and the ‘IBDesignable’
attribute to class declarations.

   Applying the ‘IBAction’, ‘IBSegueAction’, ‘IBOutlet’, ‘IBDesignable’,
or ‘IBInspectable’ attribute also implies the ‘objc’ attribute.


File: swift-reference.info,  Node: Type Attributes,  Next: Switch Case Attributes,  Prev: Declaration Attributes,  Up: Attributes

8.2 Type Attributes
===================

You can apply type attributes to types only.

* Menu:

* autoclosure::
* convention::
* escaping::


File: swift-reference.info,  Node: autoclosure,  Next: convention,  Up: Type Attributes

8.2.1 autoclosure
-----------------

Apply this attribute to delay the evaluation of an expression by
automatically wrapping that expression in a closure with no arguments.
You apply it to a parameter’s type in a method or function declaration,
for a parameter whose type is a function type that takes no arguments
and that returns a value of the type of the expression.  For an example
of how to use the ‘autoclosure’ attribute, see *note Autoclosures:
(swift)Autoclosures. and *note Function Type::.


File: swift-reference.info,  Node: convention,  Next: escaping,  Prev: autoclosure,  Up: Type Attributes

8.2.2 convention
----------------

Apply this attribute to the type of a function to indicate its calling
conventions.

   The ‘convention’ attribute always appears with one of the following
arguments:

   • The ‘swift’ argument indicates a Swift function reference.  This is
     the standard calling convention for function values in Swift.

   • The ‘block’ argument indicates an Objective-C compatible block
     reference.  The function value is represented as a reference to the
     block object, which is an ‘id’-compatible Objective-C object that
     embeds its invocation function within the object.  The invocation
     function uses the C calling convention.

   • The ‘c’ argument indicates a C function reference.  The function
     value carries no context and uses the C calling convention.

   With a few exceptions, a function of any calling convention can be
used when a function any other calling convention is needed.  A
nongeneric global function, a local function that doesn’t capture any
local variables or a closure that doesn’t capture any local variables
can be converted to the C calling convention.  Other Swift functions
can’t be converted to the C calling convention.  A function with the
Objective-C block calling convention can’t be converted to the C calling
convention.


File: swift-reference.info,  Node: escaping,  Prev: convention,  Up: Type Attributes

8.2.3 escaping
--------------

Apply this attribute to a parameter’s type in a method or function
declaration to indicate that the parameter’s value can be stored for
later execution.  This means that the value is allowed to outlive the
lifetime of the call.  Function type parameters with the ‘escaping’ type
attribute require explicit use of ‘self.’ for properties or methods.
For an example of how to use the ‘escaping’ attribute, see *note
Escaping Closures: (swift)Escaping Closures.


File: swift-reference.info,  Node: Switch Case Attributes,  Prev: Type Attributes,  Up: Attributes

8.3 Switch Case Attributes
==========================

You can apply switch case attributes to switch cases only.

* Menu:

* unknown::


File: swift-reference.info,  Node: unknown,  Up: Switch Case Attributes

8.3.1 unknown
-------------

Apply this attribute to a switch case to indicate that it isn’t expected
to be matched by any case of the enumeration that’s known at the time
the code is compiled.  For an example of how to use the ‘unknown’
attribute, see Switching Over Future Enumeration Cases.

   Grammar of an attribute

   attribute → ‘@’ attribute-name attribute-argument-clause _{opt}

   attribute-name → identifier

   attribute-argument-clause → ‘(’ balanced-tokens _{opt} ‘)’

   attributes → attribute attributes _{opt}

   balanced-tokens → balanced-token balanced-tokens _{opt}

   balanced-token → ‘(’ balanced-tokens _{opt} ‘)’

   balanced-token → ‘[’ balanced-tokens _{opt} ‘]’

   balanced-token → ‘{’ balanced-tokens _{opt} ‘}’

   balanced-token → Any identifier, keyword, literal, or operator

   balanced-token → Any punctuation except ‘(’, ‘)’, ‘[’, ‘]’, ‘{’, or
‘}’


File: swift-reference.info,  Node: Patterns,  Next: Generic Parameters and Arguments,  Prev: Attributes,  Up: Top

9 Patterns
**********

A _pattern_ represents the structure of a single value or a composite
value.  For example, the structure of a tuple ‘(1, 2)’ is a
comma-separated list of two elements.  Because patterns represent the
structure of a value rather than any one particular value, you can match
them with a variety of values.  For instance, the pattern ‘(x, y)’
matches the tuple ‘(1, 2)’ and any other two-element tuple.  In addition
to matching a pattern with a value, you can extract part or all of a
composite value and bind each part to a constant or variable name.

   In Swift, there are two basic kinds of patterns: those that
successfully match any kind of value, and those that may fail to match a
specified value at runtime.

   The first kind of pattern is used for destructuring values in simple
variable, constant, and optional bindings.  These include wildcard
patterns, identifier patterns, and any value binding or tuple patterns
containing them.  You can specify a type annotation for these patterns
to constrain them to match only values of a certain type.

   The second kind of pattern is used for full pattern matching, where
the values you’re trying to match against may not be there at runtime.
These include enumeration case patterns, optional patterns, expression
patterns, and type-casting patterns.  You use these patterns in a case
label of a ‘switch’ statement, a ‘catch’ clause of a ‘do’ statement, or
in the case condition of an ‘if’, ‘while’, ‘guard’, or ‘for’-‘in’
statement.

   Grammar of a pattern

   pattern → wildcard-pattern type-annotation _{opt}

   pattern → identifier-pattern type-annotation _{opt}

   pattern → value-binding-pattern

   pattern → tuple-pattern type-annotation _{opt}

   pattern → enum-case-pattern

   pattern → optional-pattern

   pattern → type-casting-pattern

   pattern → expression-pattern

* Menu:

* Wildcard Pattern::
* Identifier Pattern::
* Value-Binding Pattern::
* Tuple Pattern::
* Enumeration Case Pattern::
* Optional Pattern::
* Type-Casting Patterns::
* Expression Pattern::


File: swift-reference.info,  Node: Wildcard Pattern,  Next: Identifier Pattern,  Up: Patterns

9.1 Wildcard Pattern
====================

A _wildcard pattern_ matches and ignores any value and consists of an
underscore (‘_’).  Use a wildcard pattern when you don’t care about the
values being matched against.  For example, the following code iterates
through the closed range ‘1...3’, ignoring the current value of the
range on each iteration of the loop:

  1. for _ in 1...3 {
  2. // Do something three times.
  3. }

   Grammar of a wildcard pattern

   wildcard-pattern → ‘_’


File: swift-reference.info,  Node: Identifier Pattern,  Next: Value-Binding Pattern,  Prev: Wildcard Pattern,  Up: Patterns

9.2 Identifier Pattern
======================

An _identifier pattern_ matches any value and binds the matched value to
a variable or constant name.  For example, in the following constant
declaration, ‘someValue’ is an identifier pattern that matches the value
‘42’ of type ‘Int’:

  1. let someValue = 42

   When the match succeeds, the value ‘42’ is bound (assigned) to the
constant name ‘someValue’.

   When the pattern on the left-hand side of a variable or constant
declaration is an identifier pattern, the identifier pattern is
implicitly a subpattern of a value-binding pattern.

   Grammar of an identifier pattern

   identifier-pattern → identifier


File: swift-reference.info,  Node: Value-Binding Pattern,  Next: Tuple Pattern,  Prev: Identifier Pattern,  Up: Patterns

9.3 Value-Binding Pattern
=========================

A _value-binding pattern_ binds matched values to variable or constant
names.  Value-binding patterns that bind a matched value to the name of
a constant begin with the ‘let’ keyword; those that bind to the name of
variable begin with the ‘var’ keyword.

   Identifiers patterns within a value-binding pattern bind new named
variables or constants to their matching values.  For example, you can
decompose the elements of a tuple and bind the value of each element to
a corresponding identifier pattern.

  1. let point = (3, 2)
  2. switch point {
  3. // Bind x and y to the elements of point.
  4. case let (x, y):
  5. print("The point is at (\(x), \(y)).")
  6. }
  7. // Prints "The point is at (3, 2)."

   In the example above, ‘let’ distributes to each identifier pattern in
the tuple pattern ‘(x, y)’.  Because of this behavior, the ‘switch’
cases ‘case let (x, y):’ and ‘case (let x, let y):’ match the same
values.

   Grammar of a value-binding pattern

   value-binding-pattern → ‘var’ pattern | ‘let’ pattern


File: swift-reference.info,  Node: Tuple Pattern,  Next: Enumeration Case Pattern,  Prev: Value-Binding Pattern,  Up: Patterns

9.4 Tuple Pattern
=================

A _tuple pattern_ is a comma-separated list of zero or more patterns,
enclosed in parentheses.  Tuple patterns match values of corresponding
tuple types.

   You can constrain a tuple pattern to match certain kinds of tuple
types by using type annotations.  For example, the tuple pattern ‘(x,
y): (Int, Int)’ in the constant declaration ‘let (x, y): (Int, Int) =
(1, 2)’ matches only tuple types in which both elements are of type
‘Int’.

   When a tuple pattern is used as the pattern in a ‘for’-‘in’ statement
or in a variable or constant declaration, it can contain only wildcard
patterns, identifier patterns, optional patterns, or other tuple
patterns that contain those.  For example, the following code isn’t
valid because the element ‘0’ in the tuple pattern ‘(x, 0)’ is an
expression pattern:

  1. let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]
  2. // This code isn’t valid.
  3. for (x, 0) in points {
  4. _* ... *_
  5. }

   The parentheses around a tuple pattern that contains a single element
have no effect.  The pattern matches values of that single element’s
type.  For example, the following are equivalent:

  1. let a = 2 // a: Int = 2
  2. let (a) = 2 // a: Int = 2
  3. let (a): Int = 2 // a: Int = 2

   Grammar of a tuple pattern

   tuple-pattern → ‘(’ tuple-pattern-element-list _{opt} ‘)’

   tuple-pattern-element-list → tuple-pattern-element
   tuple-pattern-element ‘,’ tuple-pattern-element-list

   tuple-pattern-element → pattern | identifier ‘:’ pattern


File: swift-reference.info,  Node: Enumeration Case Pattern,  Next: Optional Pattern,  Prev: Tuple Pattern,  Up: Patterns

9.5 Enumeration Case Pattern
============================

An _enumeration case pattern_ matches a case of an existing enumeration
type.  Enumeration case patterns appear in ‘switch’ statement case
labels and in the case conditions of ‘if’, ‘while’, ‘guard’, and
‘for’-‘in’ statements.

   If the enumeration case you’re trying to match has any associated
values, the corresponding enumeration case pattern must specify a tuple
pattern that contains one element for each associated value.  For an
example that uses a ‘switch’ statement to match enumeration cases
containing associated values, see *note Associated Values:
(swift)Associated Values.

   An enumeration case pattern also matches values of that case wrapped
in an optional.  This simplified syntax lets you omit an optional
pattern.  Note that, because ‘Optional’ is implemented as an
enumeration, ‘.none’ and ‘.some’ can appear in the same switch as the
cases of the enumeration type.

  1. enum SomeEnum { case left, right }
  2. let x: SomeEnum?  = .left
  3. switch x {
  4. case .left:
  5. print("Turn left")
  6. case .right:
  7. print("Turn right")
  8. case nil:
  9. print("Keep going straight")
  10. }
  11. // Prints "Turn left"

   Grammar of an enumeration case pattern

   enum-case-pattern → type-identifier _{opt} ‘.’ enum-case-name
tuple-pattern _{opt}


File: swift-reference.info,  Node: Optional Pattern,  Next: Type-Casting Patterns,  Prev: Enumeration Case Pattern,  Up: Patterns

9.6 Optional Pattern
====================

An _optional pattern_ matches values wrapped in a ‘some(Wrapped)’ case
of an ‘Optional<Wrapped>’ enumeration.  Optional patterns consist of an
identifier pattern followed immediately by a question mark and appear in
the same places as enumeration case patterns.

   Because optional patterns are syntactic sugar for ‘Optional’
enumeration case patterns, the following are equivalent:

  1. let someOptional: Int?  = 42
  2. // Match using an enumeration case pattern.
  3. if case .some(let x) = someOptional {
  4. print(x)
  5. }
  6. 
  7. // Match using an optional pattern.
  8. if case let x?  = someOptional {
  9. print(x)
  10. }

   The optional pattern provides a convenient way to iterate over an
array of optional values in a ‘for’-‘in’ statement, executing the body
of the loop only for non-‘nil’ elements.

  1. let arrayOfOptionalInts: [Int?]  = [nil, 2, 3, nil, 5]
  2. // Match only non-nil values.
  3. for case let number?  in arrayOfOptionalInts {
  4. print("Found a \(number)")
  5. }
  6. // Found a 2
  7. // Found a 3
  8. // Found a 5

   Grammar of an optional pattern

   optional-pattern → identifier-pattern ‘?’


File: swift-reference.info,  Node: Type-Casting Patterns,  Next: Expression Pattern,  Prev: Optional Pattern,  Up: Patterns

9.7 Type-Casting Patterns
=========================

There are two type-casting patterns, the ‘is’ pattern and the ‘as’
pattern.  The ‘is’ pattern appears only in ‘switch’ statement case
labels.  The ‘is’ and ‘as’ patterns have the following form:

  1. is type
  2. pattern as type

   The ‘is’ pattern matches a value if the type of that value at runtime
is the same as the type specified in the right-hand side of the ‘is’
pattern—or a subclass of that type.  The ‘is’ pattern behaves like the
‘is’ operator in that they both perform a type cast but discard the
returned type.

   The ‘as’ pattern matches a value if the type of that value at runtime
is the same as the type specified in the right-hand side of the ‘as’
pattern—or a subclass of that type.  If the match succeeds, the type of
the matched value is cast to the _pattern_ specified in the right-hand
side of the ‘as’ pattern.

   For an example that uses a ‘switch’ statement to match values with
‘is’ and ‘as’ patterns, see *note Type Casting for Any and AnyObject:
(swift)Type Casting for Any and AnyObject.

   Grammar of a type casting pattern

   type-casting-pattern → is-pattern | as-pattern

   is-pattern → ‘is’ type

   as-pattern → pattern ‘as’ type


File: swift-reference.info,  Node: Expression Pattern,  Prev: Type-Casting Patterns,  Up: Patterns

9.8 Expression Pattern
======================

An _expression pattern_ represents the value of an expression.
Expression patterns appear only in ‘switch’ statement case labels.

   The expression represented by the expression pattern is compared with
the value of an input expression using the Swift standard library ‘~=’
operator.  The matches succeeds if the ‘~=’ operator returns ‘true’.  By
default, the ‘~=’ operator compares two values of the same type using
the ‘==’ operator.  It can also match a value with a range of values, by
checking whether the value is contained within the range, as the
following example shows.

  1. let point = (1, 2)
  2. switch point {
  3. case (0, 0):
  4. print("(0, 0) is at the origin.")
  5. case (-2...2, -2...2):
  6. print("(\(point.0), \(point.1)) is near the origin.")
  7. default:
  8. print("The point is at (\(point.0), \(point.1)).")
  9. }
  10. // Prints "(1, 2) is near the origin."

   You can overload the ‘~=’ operator to provide custom expression
matching behavior.  For example, you can rewrite the above example to
compare the ‘point’ expression with a string representations of points.

  1. // Overload the ~= operator to match a string with an integer.
  2. func ~= (pattern: String, value: Int) -> Bool {
  3. return pattern == "\(value)"
  4. }
  5. switch point {
  6. case ("0", "0"):
  7. print("(0, 0) is at the origin.")
  8. default:
  9. print("The point is at (\(point.0), \(point.1)).")
  10. }
  11. // Prints "The point is at (1, 2)."

   Grammar of an expression pattern

   expression-pattern → expression


File: swift-reference.info,  Node: Generic Parameters and Arguments,  Next: Summary of the Grammar,  Prev: Patterns,  Up: Top

10 Generic Parameters and Arguments
***********************************

This chapter describes parameters and arguments for generic types,
functions, and initializers.  When you declare a generic type, function,
subscript, or initializer, you specify the type parameters that the
generic type, function, or initializer can work with.  These type
parameters act as placeholders that are replaced by actual concrete type
arguments when an instance of a generic type is created or a generic
function or initializer is called.

   For an overview of generics in Swift, see *note Generics:
(swift)Generics.

* Menu:

* Generic Parameter Clause::
* Generic Argument Clause::


File: swift-reference.info,  Node: Generic Parameter Clause,  Next: Generic Argument Clause,  Up: Generic Parameters and Arguments

10.1 Generic Parameter Clause
=============================

A _generic parameter clause_ specifies the type parameters of a generic
type or function, along with any associated constraints and requirements
on those parameters.  A generic parameter clause is enclosed in angle
brackets (<>) and has the following form:

  1. <generic parameter list>

   The _generic parameter list_ is a comma-separated list of generic
parameters, each of which has the following form:

  1. type parameter: constraint

   A generic parameter consists of a _type parameter_ followed by an
optional _constraint_.  A _type parameter_ is simply the name of a
placeholder type (for example, ‘T’, ‘U’, ‘V’, ‘Key’, ‘Value’, and so
on).  You have access to the type parameters (and any of their
associated types) in the rest of the type, function, or initializer
declaration, including in the signature of the function or initializer.

   The _constraint_ specifies that a type parameter inherits from a
specific class or conforms to a protocol or protocol composition.  For
example, in the generic function below, the generic parameter ‘T:
Comparable’ indicates that any type argument substituted for the type
parameter ‘T’ must conform to the ‘Comparable’ protocol.

  1. func simpleMax<T: Comparable>(_ x: T, _ y: T) -> T {
  2. if x < y {
  3. return y
  4. }
  5. return x
  6. }

   Because ‘Int’ and ‘Double’, for example, both conform to the
‘Comparable’ protocol, this function accepts arguments of either type.
In contrast with generic types, you don’t specify a generic argument
clause when you use a generic function or initializer.  The type
arguments are instead inferred from the type of the arguments passed to
the function or initializer.

  1. simpleMax(17, 42) // T is inferred to be Int
  2. simpleMax(3.14159, 2.71828) // T is inferred to be Double

* Menu:

* Generic Where Clauses::


File: swift-reference.info,  Node: Generic Where Clauses,  Up: Generic Parameter Clause

10.1.1 Generic Where Clauses
----------------------------

You can specify additional requirements on type parameters and their
associated types by including a generic ‘where’ clause right before the
opening curly brace of a type or function’s body.  A generic ‘where’
clause consists of the ‘where’ keyword, followed by a comma-separated
list of one or more _requirements_.

  1. where requirements

   The _requirements_ in a generic ‘where’ clause specify that a type
parameter inherits from a class or conforms to a protocol or protocol
composition.  Although the generic ‘where’ clause provides syntactic
sugar for expressing simple constraints on type parameters (for example,
‘<T: Comparable>’ is equivalent to ‘<T> where T: Comparable’ and so on),
you can use it to provide more complex constraints on type parameters
and their associated types.  For example, you can constrain the
associated types of type parameters to conform to protocols.  For
example, ‘<S: Sequence> where S.Iterator.Element: Equatable’ specifies
that ‘S’ conforms to the ‘Sequence’ protocol and that the associated
type ‘S.Iterator.Element’ conforms to the ‘Equatable’ protocol.  This
constraint ensures that each element of the sequence is equatable.

   You can also specify the requirement that two types be identical,
using the ‘==’ operator.  For example, ‘<S1: Sequence, S2: Sequence>
where S1.Iterator.Element =’ S2.Iterator.Element= expresses the
constraints that ‘S1’ and ‘S2’ conform to the ‘Sequence’ protocol and
that the elements of both sequences must be of the same type.

   Any type argument substituted for a type parameter must meet all the
constraints and requirements placed on the type parameter.

   You can overload a generic function or initializer by providing
different constraints, requirements, or both on the type parameters.
When you call an overloaded generic function or initializer, the
compiler uses these constraints to resolve which overloaded function or
initializer to invoke.

   For more information about generic ‘where’ clauses and to see an
example of one in a generic function declaration, see *note Generic
Where Clauses::.

   Grammar of a generic parameter clause

   generic-parameter-clause → ‘<’ generic-parameter-list ‘>’

   generic-parameter-list → generic-parameter
   generic-parameter ‘,’ generic-parameter-list

   generic-parameter → type-name

   generic-parameter → type-name ‘:’ type-identifier

   generic-parameter → type-name ‘:’ protocol-composition-type

   generic-where-clause → ‘where’ requirement-list

   requirement-list → requirement
   requirement ‘,’ requirement-list

   requirement → conformance-requirement
   same-type-requirement

   conformance-requirement → type-identifier ‘:’ type-identifier

   conformance-requirement → type-identifier ‘:’
protocol-composition-type

   same-type-requirement → type-identifier ‘==’ type


File: swift-reference.info,  Node: Generic Argument Clause,  Prev: Generic Parameter Clause,  Up: Generic Parameters and Arguments

10.2 Generic Argument Clause
============================

A _generic argument clause_ specifies the type arguments of a generic
type.  A generic argument clause is enclosed in angle brackets (<>) and
has the following form:

  1. <generic argument list>

   The _generic argument list_ is a comma-separated list of type
arguments.  A _type argument_ is the name of an actual concrete type
that replaces a corresponding type parameter in the generic parameter
clause of a generic type.  The result is a specialized version of that
generic type.  The example below shows a simplified version of the Swift
standard library’s generic dictionary type.

  1. struct Dictionary<Key: Hashable, Value>: Collection,
     ExpressibleByDictionaryLiteral {
  2. _* ... *_
  3. }

   The specialized version of the generic ‘Dictionary’ type,
‘Dictionary<String, Int>’ is formed by replacing the generic parameters
‘Key: Hashable’ and ‘Value’ with the concrete type arguments ‘String’
and ‘Int’.  Each type argument must satisfy all the constraints of the
generic parameter it replaces, including any additional requirements
specified in a generic ‘where’ clause.  In the example above, the ‘Key’
type parameter is constrained to conform to the ‘Hashable’ protocol and
therefore ‘String’ must also conform to the ‘Hashable’ protocol.

   You can also replace a type parameter with a type argument that is
itself a specialized version of a generic type (provided it satisfies
the appropriate constraints and requirements).  For example, you can
replace the type parameter ‘Element’ in ‘Array<Element>’ with a
specialized version of an array, ‘Array<Int>’, to form an array whose
elements are themselves arrays of integers.

  1. let arrayOfArrays: Array<Array<Int>> = [[1, 2, 3], [4, 5, 6], [7,
     8, 9]]

   As mentioned in *note Generic Parameter Clause: Generic Parameter
Clause, you don’t use a generic argument clause to specify the type
arguments of a generic function or initializer.

   Grammar of a generic argument clause

   generic-argument-clause → ‘<’ generic-argument-list ‘>’

   generic-argument-list → generic-argument
   generic-argument ‘,’ generic-argument-list

   generic-argument → type


File: swift-reference.info,  Node: Summary of the Grammar,  Next: Index,  Prev: Generic Parameters and Arguments,  Up: Top

11 Summary of the Grammar
*************************

* Menu:

* Lexical Structure: Lexical Structure 1.
* Types: Types 1.
* Expressions: Expressions 1.
* Statements: Statements 1.
* Declarations: Declarations 1.
* Attributes: Attributes 1.
* Patterns: Patterns 1.
* Generic Parameters and Arguments: Generic Parameters and Arguments 1.


File: swift-reference.info,  Node: Lexical Structure 1,  Next: Types 1,  Up: Summary of the Grammar

11.1 Lexical Structure
======================

Grammar of whitespace

   whitespace → whitespace-item whitespace _{opt}

   whitespace-item → line-break

   whitespace-item → comment

   whitespace-item → multiline-comment

   whitespace-item → U+0000, U+0009, U+000B, U+000C, or U+0020

   line-break → U+000A

   line-break → U+000D

   line-break → U+000D followed by U+000A

   comment → ‘//’ comment-text line-break

   multiline-comment → ‘/*’ multiline-comment-text ‘*/’

   comment-text → comment-text-item comment-text _{opt}

   comment-text-item → Any Unicode scalar value except U+000A or U+000D

   multiline-comment-text → multiline-comment-text-item
multiline-comment-text _{opt}

   multiline-comment-text-item → multiline-comment

   multiline-comment-text-item → comment-text-item

   multiline-comment-text-item → Any Unicode scalar value except ‘/*’ or
‘*/’

   Grammar of an identifier

   identifier → identifier-head identifier-characters _{opt}

   identifier → ‘`’ identifier-head identifier-characters _{opt} ‘`’

   identifier → implicit-parameter-name

   identifier → property-wrapper-projection

   identifier-list → identifier
   identifier ‘,’ identifier-list

   identifier-head → Upper- or lowercase letter A through Z

   identifier-head → ‘_’

   identifier-head → U+00A8, U+00AA, U+00AD, U+00AF, U+00B2–U+00B5, or
U+00B7–U+00BA

   identifier-head → U+00BC–U+00BE, U+00C0–U+00D6, U+00D8–U+00F6, or
U+00F8–U+00FF

   identifier-head → U+0100–U+02FF, U+0370–U+167F, U+1681–U+180D, or
U+180F–U+1DBF

   identifier-head → U+1E00–U+1FFF

   identifier-head → U+200B–U+200D, U+202A–U+202E, U+203F–U+2040,
U+2054, or U+2060–U+206F

   identifier-head → U+2070–U+20CF, U+2100–U+218F, U+2460–U+24FF, or
U+2776–U+2793

   identifier-head → U+2C00–U+2DFF or U+2E80–U+2FFF

   identifier-head → U+3004–U+3007, U+3021–U+302F, U+3031–U+303F, or
U+3040–U+D7FF

   identifier-head → U+F900–U+FD3D, U+FD40–U+FDCF, U+FDF0–U+FE1F, or
U+FE30–U+FE44

   identifier-head → U+FE47–U+FFFD

   identifier-head → U+10000–U+1FFFD, U+20000–U+2FFFD, U+30000–U+3FFFD,
or U+40000–U+4FFFD

   identifier-head → U+50000–U+5FFFD, U+60000–U+6FFFD, U+70000–U+7FFFD,
or U+80000–U+8FFFD

   identifier-head → U+90000–U+9FFFD, U+A0000–U+AFFFD, U+B0000–U+BFFFD,
or U+C0000–U+CFFFD

   identifier-head → U+D0000–U+DFFFD or U+E0000–U+EFFFD

   identifier-character → Digit 0 through 9

   identifier-character → U+0300–U+036F, U+1DC0–U+1DFF, U+20D0–U+20FF,
or U+FE20–U+FE2F

   identifier-character → identifier-head

   identifier-characters → identifier-character identifier-characters
_{opt}

   implicit-parameter-name → ‘$’ decimal-digits

   Grammar of a literal

   literal → numeric-literal
   string-literal
   boolean-literal
   nil-literal

   numeric-literal → =-=_opt integer-literal
=-=_opt
   floating-point-literal

   boolean-literal → ‘true’ | ‘false’

   nil-literal → ‘nil’

   Grammar of an integer literal

   integer-literal → binary-literal

   integer-literal → octal-literal

   integer-literal → decimal-literal

   integer-literal → hexadecimal-literal

   binary-literal → ‘0b’ binary-digit binary-literal-characters _{opt}

   binary-digit → Digit 0 or 1

   binary-literal-character → binary-digit
‘_’

   binary-literal-characters → binary-literal-character
binary-literal-characters _{opt}

   octal-literal → ‘0o’ octal-digit octal-literal-characters _{opt}

   octal-digit → Digit 0 through 7

   octal-literal-character → octal-digit
‘_’

   octal-literal-characters → octal-literal-character
octal-literal-characters _{opt}

   decimal-literal → decimal-digit decimal-literal-characters _{opt}

   decimal-digit → Digit 0 through 9

   decimal-digits → decimal-digit decimal-digits _{opt}

   decimal-literal-character → decimal-digit
‘_’

   decimal-literal-characters → decimal-literal-character
decimal-literal-characters _{opt}

   hexadecimal-literal → ‘0x’ hexadecimal-digit
hexadecimal-literal-characters _{opt}

   hexadecimal-digit → Digit 0 through 9, a through f, or A through F

   hexadecimal-literal-character → hexadecimal-digit
‘_’

   hexadecimal-literal-characters → hexadecimal-literal-character
hexadecimal-literal-characters _{opt}

   Grammar of a floating-point literal

   floating-point-literal → decimal-literal decimal-fraction _{opt}
decimal-exponent _{opt}

   floating-point-literal → hexadecimal-literal hexadecimal-fraction
_{opt} hexadecimal-exponent

   decimal-fraction → ‘.’ decimal-literal

   decimal-exponent → floating-point-e sign _{opt} decimal-literal

   hexadecimal-fraction → ‘.’ hexadecimal-digit
hexadecimal-literal-characters _{opt}

   hexadecimal-exponent → floating-point-p sign _{opt} decimal-literal

   floating-point-e → ‘e’ | ‘E’

   floating-point-p → ‘p’ | ‘P’

   sign → ‘+’ | ‘-’

   Grammar of a string literal

   string-literal → static-string-literal
   interpolated-string-literal

   string-literal-opening-delimiter → extended-string-literal-delimiter
_{opt} ‘"’

   string-literal-closing-delimiter → ‘"’
extended-string-literal-delimiter _{opt}

   static-string-literal → string-literal-opening-delimiter quoted-text
_{opt} string-literal-closing-delimiter

   static-string-literal → multiline-string-literal-opening-delimiter
multiline-quoted-text _{opt} multiline-string-literal-closing-delimiter

   multiline-string-literal-opening-delimiter →
extended-string-literal-delimiter ‘"""’

   multiline-string-literal-closing-delimiter → ‘"""’
extended-string-literal-delimiter

   extended-string-literal-delimiter → ‘#’
extended-string-literal-delimiter _{opt}

   quoted-text → quoted-text-item quoted-text _{opt}

   quoted-text-item → escaped-character

   quoted-text-item → Any Unicode scalar value except ‘"’, ‘\’, U+000A,
or U+000D

   multiline-quoted-text → multiline-quoted-text-item
multiline-quoted-text _{opt}

   multiline-quoted-text-item → escaped-character

   multiline-quoted-text-item → Any Unicode scalar value except ‘\’

   multiline-quoted-text-item → escaped-newline

   interpolated-string-literal → string-literal-opening-delimiter
interpolated-text _{opt} string-literal-closing-delimiter

   interpolated-string-literal →
multiline-string-literal-opening-delimiter interpolated-text _{opt}
multiline-string-literal-closing-delimiter

   interpolated-text → interpolated-text-item interpolated-text _{opt}

   interpolated-text-item → ‘\(’ expression ‘)’ | quoted-text-item

   multiline-interpolated-text → multiline-interpolated-text-item
multiline-interpolated-text _{opt}

   multiline-interpolated-text-item → ‘\(’ expression ‘)’ |
multiline-quoted-text-item

   escape-sequence → ‘\’ extended-string-literal-delimiter

   escaped-character → escape-sequence ‘0’ | escape-sequence ‘\’ |
escape-sequence ‘t’ | escape-sequence ‘n’ | escape-sequence ‘r’ |
escape-sequence ‘"’ | escape-sequence ‘'’

   escaped-character → escape-sequence ‘u’ ‘{’ unicode-scalar-digits ‘}’

   unicode-scalar-digits → Between one and eight hexadecimal digits

   escaped-newline → escape-sequence whitespace _{opt} line-break

   Grammar of operators

   operator → operator-head operator-characters _{opt}

   operator → dot-operator-head dot-operator-characters

   operator-head → ‘/’ | ‘=’ | ‘-’ | ‘+’ | ‘!’ | ‘*’ | ‘%’ | ‘<’ | ‘>’ |
‘&’ | ‘|’ | ‘^’
‘~’   ‘?’

   operator-head → U+00A1–U+00A7

   operator-head → U+00A9 or U+00AB

   operator-head → U+00AC or U+00AE

   operator-head → U+00B0–U+00B1

   operator-head → U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7

   operator-head → U+2016–U+2017

   operator-head → U+2020–U+2027

   operator-head → U+2030–U+203E

   operator-head → U+2041–U+2053

   operator-head → U+2055–U+205E

   operator-head → U+2190–U+23FF

   operator-head → U+2500–U+2775

   operator-head → U+2794–U+2BFF

   operator-head → U+2E00–U+2E7F

   operator-head → U+3001–U+3003

   operator-head → U+3008–U+3020

   operator-head → U+3030

   operator-character → operator-head

   operator-character → U+0300–U+036F

   operator-character → U+1DC0–U+1DFF

   operator-character → U+20D0–U+20FF

   operator-character → U+FE00–U+FE0F

   operator-character → U+FE20–U+FE2F

   operator-character → U+E0100–U+E01EF

   operator-characters → operator-character operator-characters _{opt}

   dot-operator-head → ‘.’

   dot-operator-character → ‘.’ | operator-character

   dot-operator-characters → dot-operator-character
dot-operator-characters _{opt}

   binary-operator → operator

   prefix-operator → operator

   postfix-operator → operator


File: swift-reference.info,  Node: Types 1,  Next: Expressions 1,  Prev: Lexical Structure 1,  Up: Summary of the Grammar

11.2 Types
==========

Grammar of a type

   type → function-type

   type → array-type

   type → dictionary-type

   type → type-identifier

   type → tuple-type

   type → optional-type

   type → implicitly-unwrapped-optional-type

   type → protocol-composition-type

   type → opaque-type

   type → metatype-type

   type → self-type

   type → ‘Any’

   type → ‘(’ type ‘)’

   Grammar of a type annotation

   type-annotation → ‘:’ attributes _{opt} =inout=_opt type

   Grammar of a type identifier

   type-identifier → type-name generic-argument-clause _{opt} |
type-name generic-argument-clause _{opt} ‘.’ type-identifier

   type-name → identifier

   Grammar of a tuple type

   tuple-type → ‘(’ ‘)’ | ‘(’ tuple-type-element ‘,’
tuple-type-element-list ‘)’

   tuple-type-element-list → tuple-type-element
   tuple-type-element ‘,’ tuple-type-element-list

   tuple-type-element → element-name type-annotation
type

   element-name → identifier

   Grammar of a function type

   function-type → attributes _{opt} function-type-argument-clause
‘throws=_{opt} =->’ type

   function-type-argument-clause → ‘(’ ‘)’

   function-type-argument-clause → ‘(’ function-type-argument-list
‘...=_{opt} =)’

   function-type-argument-list → function-type-argument
   function-type-argument ‘,’ function-type-argument-list

   function-type-argument → attributes _{opt} =inout=_opt type |
argument-label type-annotation

   argument-label → identifier

   Grammar of an array type

   array-type → ‘[’ type ‘]’

   Grammar of a dictionary type

   dictionary-type → ‘[’ type ‘:’ type ‘]’

   Grammar of an optional type

   optional-type → type ‘?’

   Grammar of an implicitly unwrapped optional type

   implicitly-unwrapped-optional-type → type ‘!’

   Grammar of a protocol composition type

   protocol-composition-type → type-identifier ‘&’
protocol-composition-continuation

   protocol-composition-continuation → type-identifier
   protocol-composition-type

   Grammar of an opaque type

   opaque-type → ‘some’ type

   Grammar of a metatype type

   metatype-type → type ‘.’  ‘Type’ | type ‘.’  ‘Protocol’

   Grammar of a type inheritance clause

   type-inheritance-clause → ‘:’ type-inheritance-list

   type-inheritance-list → type-identifier
   type-identifier ‘,’ type-inheritance-list


File: swift-reference.info,  Node: Expressions 1,  Next: Statements 1,  Prev: Types 1,  Up: Summary of the Grammar

11.3 Expressions
================

Grammar of an expression

   expression → try-operator _{opt} prefix-expression binary-expressions
_{opt}

   expression-list → expression
   expression ‘,’ expression-list

   Grammar of a prefix expression

   prefix-expression → prefix-operator _{opt} postfix-expression

   prefix-expression → in-out-expression

   in-out-expression → ‘&’ identifier

   Grammar of a try expression

   try-operator → ‘try’ | ‘try’ ‘?’ | ‘try’ ‘!’

   Grammar of a binary expression

   binary-expression → binary-operator prefix-expression

   binary-expression → assignment-operator try-operator _{opt}
prefix-expression

   binary-expression → conditional-operator try-operator _{opt}
prefix-expression

   binary-expression → type-casting-operator

   binary-expressions → binary-expression binary-expressions _{opt}

   Grammar of an assignment operator

   assignment-operator → ‘=’

   Grammar of a conditional operator

   conditional-operator → ‘?’ expression ‘:’

   Grammar of a type-casting operator

   type-casting-operator → ‘is’ type

   type-casting-operator → ‘as’ type

   type-casting-operator → ‘as’ ‘?’ type

   type-casting-operator → ‘as’ ‘!’ type

   Grammar of a primary expression

   primary-expression → identifier generic-argument-clause _{opt}

   primary-expression → literal-expression

   primary-expression → self-expression

   primary-expression → superclass-expression

   primary-expression → closure-expression

   primary-expression → parenthesized-expression

   primary-expression → tuple-expression

   primary-expression → implicit-member-expression

   primary-expression → wildcard-expression

   primary-expression → key-path-expression

   primary-expression → selector-expression

   primary-expression → key-path-string-expression

   Grammar of a literal expression

   literal-expression → literal

   literal-expression → array-literal
   dictionary-literal
   playground-literal

   literal-expression → ‘#file’ | ‘#line’ | ‘#column’ | ‘#function’ |
‘#dsohandle’

   array-literal → ‘[’ array-literal-items _{opt} ‘]’

   array-literal-items → array-literal-item =,=_opt | array-literal-item
‘,’ array-literal-items

   array-literal-item → expression

   dictionary-literal → ‘[’ dictionary-literal-items ‘]’ | ‘[’ ‘:’ ‘]’

   dictionary-literal-items → dictionary-literal-item =,=_opt |
dictionary-literal-item ‘,’ dictionary-literal-items

   dictionary-literal-item → expression ‘:’ expression

   playground-literal → ‘#colorLiteral’ ‘(’ ‘red’ ‘:’ expression ‘,’
‘green’ ‘:’ expression ‘,’ ‘blue’ ‘:’ expression ‘,’ ‘alpha’ ‘:’
expression ‘)’

   playground-literal → ‘#fileLiteral’ ‘(’ ‘resourceName’ ‘:’ expression
‘)’

   playground-literal → ‘#imageLiteral’ ‘(’ ‘resourceName’ ‘:’
expression ‘)’

   Grammar of a self expression

   self-expression → ‘self’ | self-method-expression
   self-subscript-expression
   self-initializer-expression

   self-method-expression → ‘self’ ‘.’ identifier

   self-subscript-expression → ‘self’ ‘[’ function-call-argument-list
‘]’

   self-initializer-expression → ‘self’ ‘.’  ‘init’

   Grammar of a superclass expression

   superclass-expression → superclass-method-expression
   superclass-subscript-expression
   superclass-initializer-expression

   superclass-method-expression → ‘super’ ‘.’ identifier

   superclass-subscript-expression → ‘super’ ‘[’
function-call-argument-list ‘]’

   superclass-initializer-expression → ‘super’ ‘.’  ‘init’

   Grammar of a closure expression

   closure-expression → ‘{’ closure-signature _{opt} statements _{opt}
‘}’

   closure-signature → capture-list _{opt} closure-parameter-clause
=throws=_opt function-result _{opt} ‘in’

   closure-signature → capture-list ‘in’

   closure-parameter-clause → ‘(’ ‘)’ | ‘(’ closure-parameter-list ‘)’ |
identifier-list

   closure-parameter-list → closure-parameter
   closure-parameter ‘,’ closure-parameter-list

   closure-parameter → closure-parameter-name type-annotation _{opt}

   closure-parameter → closure-parameter-name type-annotation ‘...’

   closure-parameter-name → identifier

   capture-list → ‘[’ capture-list-items ‘]’

   capture-list-items → capture-list-item
   capture-list-item ‘,’ capture-list-items

   capture-list-item → capture-specifier _{opt} expression

   capture-specifier → ‘weak’ | ‘unowned’ | ‘unowned(safe)’ |
‘unowned(unsafe)’

   Grammar of a implicit member expression

   implicit-member-expression → ‘.’ identifier

   Grammar of a parenthesized expression

   parenthesized-expression → ‘(’ expression ‘)’

   Grammar of a tuple expression

   tuple-expression → ‘(’ ‘)’ | ‘(’ tuple-element ‘,’ tuple-element-list
‘)’

   tuple-element-list → tuple-element
   tuple-element ‘,’ tuple-element-list

   tuple-element → expression
   identifier ‘:’ expression

   Grammar of a wildcard expression

   wildcard-expression → ‘_’

   Grammar of a key-path expression

   key-path-expression → ‘\’ type _{opt} ‘.’ key-path-components

   key-path-components → key-path-component
   key-path-component ‘.’ key-path-components

   key-path-component → identifier key-path-postfixes _{opt} |
key-path-postfixes

   key-path-postfixes → key-path-postfix key-path-postfixes _{opt}

   key-path-postfix → ‘?’ | ‘!’ | ‘self’ | ‘[’
function-call-argument-list ‘]’

   Grammar of a selector expression

   selector-expression → ‘#selector’ ‘(’ expression ‘)’

   selector-expression → ‘#selector’ ‘(’ ‘getter:’ expression ‘)’

   selector-expression → ‘#selector’ ‘(’ ‘setter:’ expression ‘)’

   Grammar of a key-path string expression

   key-path-string-expression → ‘#keyPath’ ‘(’ expression ‘)’

   Grammar of a postfix expression

   postfix-expression → primary-expression

   postfix-expression → postfix-expression postfix-operator

   postfix-expression → function-call-expression

   postfix-expression → initializer-expression

   postfix-expression → explicit-member-expression

   postfix-expression → postfix-self-expression

   postfix-expression → subscript-expression

   postfix-expression → forced-value-expression

   postfix-expression → optional-chaining-expression

   Grammar of a function call expression

   function-call-expression → postfix-expression
function-call-argument-clause

   function-call-expression → postfix-expression
function-call-argument-clause _{opt} trailing-closure

   function-call-argument-clause → ‘(’ ‘)’ | ‘(’
function-call-argument-list ‘)’

   function-call-argument-list → function-call-argument
   function-call-argument ‘,’ function-call-argument-list

   function-call-argument → expression
   identifier ‘:’ expression

   function-call-argument → operator
   identifier ‘:’ operator

   trailing-closure → closure-expression

   Grammar of an initializer expression

   initializer-expression → postfix-expression ‘.’  ‘init’

   initializer-expression → postfix-expression ‘.’  ‘init’ ‘(’
argument-names ‘)’

   Grammar of an explicit member expression

   explicit-member-expression → postfix-expression ‘.’ decimal-digits

   explicit-member-expression → postfix-expression ‘.’ identifier
generic-argument-clause _{opt}

   explicit-member-expression → postfix-expression ‘.’ identifier ‘(’
argument-names ‘)’

   argument-names → argument-name argument-names _{opt}

   argument-name → identifier ‘:’

   Grammar of a postfix self expression

   postfix-self-expression → postfix-expression ‘.’  ‘self’

   Grammar of a subscript expression

   subscript-expression → postfix-expression ‘[’
function-call-argument-list ‘]’

   Grammar of a forced-value expression

   forced-value-expression → postfix-expression ‘!’

   Grammar of an optional-chaining expression

   optional-chaining-expression → postfix-expression ‘?’


File: swift-reference.info,  Node: Statements 1,  Next: Declarations 1,  Prev: Expressions 1,  Up: Summary of the Grammar

11.4 Statements
===============

Grammar of a statement

   statement → expression =;=_opt

   statement → declaration =;=_opt

   statement → loop-statement =;=_opt

   statement → branch-statement =;=_opt

   statement → labeled-statement =;=_opt

   statement → control-transfer-statement =;=_opt

   statement → defer-statement =;=_opt

   statement → do-statement =;=_opt

   statement → compiler-control-statement

   statements → statement statements _{opt}

   Grammar of a loop statement

   loop-statement → for-in-statement

   loop-statement → while-statement

   loop-statement → repeat-while-statement

   Grammar of a for-in statement

   for-in-statement → ‘for’ ‘case=_{opt} pattern =in’ expression
where-clause _{opt} code-block

   Grammar of a while statement

   while-statement → ‘while’ condition-list code-block

   condition-list → condition | condition ‘,’ condition-list

   condition → expression
   availability-condition
   case-condition
   optional-binding-condition

   case-condition → ‘case’ pattern initializer

   optional-binding-condition → ‘let’ pattern initializer
‘var’ pattern
   initializer

   Grammar of a repeat-while statement

   repeat-while-statement → ‘repeat’ code-block ‘while’ expression

   Grammar of a branch statement

   branch-statement → if-statement

   branch-statement → guard-statement

   branch-statement → switch-statement

   Grammar of an if statement

   if-statement → ‘if’ condition-list code-block else-clause _{opt}

   else-clause → ‘else’ code-block
‘else’
   if-statement

   Grammar of a guard statement

   guard-statement → ‘guard’ condition-list ‘else’ code-block

   Grammar of a switch statement

   switch-statement → ‘switch’ expression ‘{’ switch-cases _{opt} ‘}’

   switch-cases → switch-case switch-cases _{opt}

   switch-case → case-label statements

   switch-case → default-label statements

   switch-case → conditional-switch-case

   case-label → attributes _{opt} ‘case’ case-item-list ‘:’

   case-item-list → pattern where-clause _{opt} | pattern where-clause
_{opt} ‘,’ case-item-list

   default-label → attributes _{opt} ‘default’ ‘:’

   where-clause → ‘where’ where-expression

   where-expression → expression

   conditional-switch-case → switch-if-directive-clause
switch-elseif-directive-clauses _{opt} switch-else-directive-clause
_{opt} endif-directive

   switch-if-directive-clause → if-directive compilation-condition
switch-cases _{opt}

   switch-elseif-directive-clauses → elseif-directive-clause
switch-elseif-directive-clauses _{opt}

   switch-elseif-directive-clause → elseif-directive
compilation-condition switch-cases _{opt}

   switch-else-directive-clause → else-directive switch-cases _{opt}

   Grammar of a labeled statement

   labeled-statement → statement-label loop-statement

   labeled-statement → statement-label if-statement

   labeled-statement → statement-label switch-statement

   labeled-statement → statement-label do-statement

   statement-label → label-name ‘:’

   label-name → identifier

   Grammar of a control transfer statement

   control-transfer-statement → break-statement

   control-transfer-statement → continue-statement

   control-transfer-statement → fallthrough-statement

   control-transfer-statement → return-statement

   control-transfer-statement → throw-statement

   Grammar of a break statement

   break-statement → ‘break’ label-name _{opt}

   Grammar of a continue statement

   continue-statement → ‘continue’ label-name _{opt}

   Grammar of a fallthrough statement

   fallthrough-statement → ‘fallthrough’

   Grammar of a return statement

   return-statement → ‘return’ expression _{opt}

   Grammar of a throw statement

   throw-statement → ‘throw’ expression

   Grammar of a defer statement

   defer-statement → ‘defer’ code-block

   Grammar of a do statement

   do-statement → ‘do’ code-block catch-clauses _{opt}

   catch-clauses → catch-clause catch-clauses _{opt}

   catch-clause → ‘catch’ pattern _{opt} where-clause _{opt} code-block

   Grammar of a compiler control statement

   compiler-control-statement → conditional-compilation-block

   compiler-control-statement → line-control-statement

   compiler-control-statement → diagnostic-statement

   Grammar of a conditional compilation block

   conditional-compilation-block → if-directive-clause
elseif-directive-clauses _{opt} else-directive-clause _{opt}
endif-directive

   if-directive-clause → if-directive compilation-condition statements
_{opt}

   elseif-directive-clauses → elseif-directive-clause
elseif-directive-clauses _{opt}

   elseif-directive-clause → elseif-directive compilation-condition
statements _{opt}

   else-directive-clause → else-directive statements _{opt}

   if-directive → ‘#if’

   elseif-directive → ‘#elseif’

   else-directive → ‘#else’

   endif-directive → ‘#endif’

   compilation-condition → platform-condition

   compilation-condition → identifier

   compilation-condition → boolean-literal

   compilation-condition → ‘(’ compilation-condition ‘)’

   compilation-condition → ‘!’ compilation-condition

   compilation-condition → compilation-condition ‘&&’
compilation-condition

   compilation-condition → compilation-condition ‘||’
compilation-condition

   platform-condition → ‘os’ ‘(’ operating-system ‘)’

   platform-condition → ‘arch’ ‘(’ architecture ‘)’

   platform-condition → ‘swift’ ‘(’ ‘>=’ swift-version ‘)’ | ‘swift’ ‘(’
‘<’ swift-version ‘)’

   platform-condition → ‘compiler’ ‘(’ ‘>=’ swift-version ‘)’ |
‘compiler’ ‘(’ ‘<’ swift-version ‘)’

   platform-condition → ‘canImport’ ‘(’ module-name ‘)’

   platform-condition → ‘targetEnvironment’ ‘(’ environment ‘)’

   operating-system → ‘macOS’ | ‘iOS’ | ‘watchOS’ | ‘tvOS’

   architecture → ‘i386’ | ‘x86_64’ | ‘arm’ | ‘arm64’

   swift-version → decimal-digits swift-version-continuation _{opt}

   swift-version-continuation → ‘.’ decimal-digits
swift-version-continuation _{opt}

   module-name → identifier

   environment → ‘simulator’

   Grammar of a line control statement

   line-control-statement → ‘#sourceLocation’ ‘(’ ‘file:’ file-name ‘,’
‘line:’ line-number ‘)’

   line-control-statement → ‘#sourceLocation’ ‘(’ ‘)’

   line-number → A decimal integer greater than zero

   file-name → static-string-literal

   Grammar of a compile-time diagnostic statement

   diagnostic-statement → ‘#error’ ‘(’ diagnostic-message ‘)’

   diagnostic-statement → ‘#warning’ ‘(’ diagnostic-message ‘)’

   diagnostic-message → static-string-literal

   Grammar of an availability condition

   availability-condition → ‘#available’ ‘(’ availability-arguments ‘)’

   availability-arguments → availability-argument
   availability-argument ‘,’ availability-arguments

   availability-argument → platform-name platform-version

   availability-argument → ‘*’

   platform-name → ‘iOS’ | ‘iOSApplicationExtension’

   platform-name → ‘macOS’ | ‘macOSApplicationExtension’

   platform-name → ‘watchOS’

   platform-name → ‘tvOS’

   platform-version → decimal-digits

   platform-version → decimal-digits ‘.’ decimal-digits

   platform-version → decimal-digits ‘.’ decimal-digits ‘.’
decimal-digits


File: swift-reference.info,  Node: Declarations 1,  Next: Attributes 1,  Prev: Statements 1,  Up: Summary of the Grammar

11.5 Declarations
=================

Grammar of a declaration

   declaration → import-declaration

   declaration → constant-declaration

   declaration → variable-declaration

   declaration → typealias-declaration

   declaration → function-declaration

   declaration → enum-declaration

   declaration → struct-declaration

   declaration → class-declaration

   declaration → protocol-declaration

   declaration → initializer-declaration

   declaration → deinitializer-declaration

   declaration → extension-declaration

   declaration → subscript-declaration

   declaration → operator-declaration

   declaration → precedence-group-declaration

   declarations → declaration declarations _{opt}

   Grammar of a top-level declaration

   top-level-declaration → statements _{opt}

   Grammar of a code block

   code-block → ‘{’ statements _{opt} ‘}’

   Grammar of an import declaration

   import-declaration → attributes _{opt} ‘import’ import-kind _{opt}
import-path

   import-kind → ‘typealias’ | ‘struct’ | ‘class’ | ‘enum’ | ‘protocol’
| ‘let’ | ‘var’ | ‘func’

   import-path → import-path-identifier
   import-path-identifier ‘.’ import-path

   import-path-identifier → identifier
   operator

   Grammar of a constant declaration

   constant-declaration → attributes _{opt} declaration-modifiers _{opt}
‘let’ pattern-initializer-list

   pattern-initializer-list → pattern-initializer
   pattern-initializer ‘,’ pattern-initializer-list

   pattern-initializer → pattern initializer _{opt}

   initializer → ‘=’ expression

   Grammar of a variable declaration

   variable-declaration → variable-declaration-head
pattern-initializer-list

   variable-declaration → variable-declaration-head variable-name
type-annotation code-block

   variable-declaration → variable-declaration-head variable-name
type-annotation getter-setter-block

   variable-declaration → variable-declaration-head variable-name
type-annotation getter-setter-keyword-block

   variable-declaration → variable-declaration-head variable-name
initializer willSet-didSet-block

   variable-declaration → variable-declaration-head variable-name
type-annotation initializer _{opt} willSet-didSet-block

   variable-declaration-head → attributes _{opt} declaration-modifiers
_{opt} ‘var’

   variable-name → identifier

   getter-setter-block → code-block

   getter-setter-block → ‘{’ getter-clause setter-clause _{opt} ‘}’

   getter-setter-block → ‘{’ setter-clause getter-clause ‘}’

   getter-clause → attributes _{opt} mutation-modifier _{opt} ‘get’
code-block

   setter-clause → attributes _{opt} mutation-modifier _{opt} ‘set’
setter-name _{opt} code-block

   setter-name → ‘(’ identifier ‘)’

   getter-setter-keyword-block → ‘{’ getter-keyword-clause
setter-keyword-clause _{opt} ‘}’

   getter-setter-keyword-block → ‘{’ setter-keyword-clause
getter-keyword-clause ‘}’

   getter-keyword-clause → attributes _{opt} mutation-modifier _{opt}
‘get’

   setter-keyword-clause → attributes _{opt} mutation-modifier _{opt}
‘set’

   willSet-didSet-block → ‘{’ willSet-clause didSet-clause _{opt} ‘}’

   willSet-didSet-block → ‘{’ didSet-clause willSet-clause _{opt} ‘}’

   willSet-clause → attributes _{opt} ‘willSet’ setter-name _{opt}
code-block

   didSet-clause → attributes _{opt} ‘didSet’ setter-name _{opt}
code-block

   Grammar of a type alias declaration

   typealias-declaration → attributes _{opt} access-level-modifier
_{opt} ‘typealias’ typealias-name generic-parameter-clause _{opt}
typealias-assignment

   typealias-name → identifier

   typealias-assignment → ‘=’ type

   Grammar of a function declaration

   function-declaration → function-head function-name
generic-parameter-clause _{opt} function-signature generic-where-clause
_{opt} function-body _{opt}

   function-head → attributes _{opt} declaration-modifiers _{opt} ‘func’

   function-name → identifier
   operator

   function-signature → parameter-clause =throws=_opt function-result
_{opt}

   function-signature → parameter-clause ‘rethrows’ function-result
_{opt}

   function-result → ‘->’ attributes _{opt} type

   function-body → code-block

   parameter-clause → ‘(’ ‘)’ | ‘(’ parameter-list ‘)’

   parameter-list → parameter
parameter
   ‘,’ parameter-list

   parameter → external-parameter-name _{opt} local-parameter-name
type-annotation default-argument-clause _{opt}

   parameter → external-parameter-name _{opt} local-parameter-name
type-annotation

   parameter → external-parameter-name _{opt} local-parameter-name
type-annotation ‘...’

   external-parameter-name → identifier

   local-parameter-name → identifier

   default-argument-clause → ‘=’ expression

   Grammar of an enumeration declaration

   enum-declaration → attributes _{opt} access-level-modifier _{opt}
union-style-enum

   enum-declaration → attributes _{opt} access-level-modifier _{opt}
raw-value-style-enum

   union-style-enum → ‘indirect=_{opt} =enum’ enum-name
generic-parameter-clause _{opt} type-inheritance-clause _{opt}
generic-where-clause _{opt} ‘{’ union-style-enum-members _{opt} ‘}’

   union-style-enum-members → union-style-enum-member
union-style-enum-members _{opt}

   union-style-enum-member → declaration
   union-style-enum-case-clause
   compiler-control-statement

   union-style-enum-case-clause → attributes _{opt} ‘indirect=_{opt}
=case’ union-style-enum-case-list

   union-style-enum-case-list → union-style-enum-case
   union-style-enum-case ‘,’ union-style-enum-case-list

   union-style-enum-case → enum-case-name tuple-type _{opt}

   enum-name → identifier

   enum-case-name → identifier

   raw-value-style-enum → ‘enum’ enum-name generic-parameter-clause
_{opt} type-inheritance-clause generic-where-clause _{opt} ‘{’
raw-value-style-enum-members ‘}’

   raw-value-style-enum-members → raw-value-style-enum-member
raw-value-style-enum-members _{opt}

   raw-value-style-enum-member → declaration
   raw-value-style-enum-case-clause
   compiler-control-statement

   raw-value-style-enum-case-clause → attributes _{opt} ‘case’
raw-value-style-enum-case-list

   raw-value-style-enum-case-list → raw-value-style-enum-case
   raw-value-style-enum-case ‘,’ raw-value-style-enum-case-list

   raw-value-style-enum-case → enum-case-name raw-value-assignment
_{opt}

   raw-value-assignment → ‘=’ raw-value-literal

   raw-value-literal → numeric-literal
   static-string-literal
   boolean-literal

   Grammar of a structure declaration

   struct-declaration → attributes _{opt} access-level-modifier _{opt}
‘struct’ struct-name generic-parameter-clause _{opt}
type-inheritance-clause _{opt} generic-where-clause _{opt} struct-body

   struct-name → identifier

   struct-body → ‘{’ struct-members _{opt} ‘}’

   struct-members → struct-member struct-members _{opt}

   struct-member → declaration
   compiler-control-statement

   Grammar of a class declaration

   class-declaration → attributes _{opt} access-level-modifier _{opt}
‘final=_{opt} =class’ class-name generic-parameter-clause _{opt}
type-inheritance-clause _{opt} generic-where-clause _{opt} class-body

   class-declaration → attributes _{opt} ‘final’ access-level-modifier
_{opt} ‘class’ class-name generic-parameter-clause _{opt}
type-inheritance-clause _{opt} generic-where-clause _{opt} class-body

   class-name → identifier

   class-body → ‘{’ class-members _{opt} ‘}’

   class-members → class-member class-members _{opt}

   class-member → declaration
   compiler-control-statement

   Grammar of a protocol declaration

   protocol-declaration → attributes _{opt} access-level-modifier _{opt}
‘protocol’ protocol-name type-inheritance-clause _{opt}
generic-where-clause _{opt} protocol-body

   protocol-name → identifier

   protocol-body → ‘{’ protocol-members _{opt} ‘}’

   protocol-members → protocol-member protocol-members _{opt}

   protocol-member → protocol-member-declaration
   compiler-control-statement

   protocol-member-declaration → protocol-property-declaration

   protocol-member-declaration → protocol-method-declaration

   protocol-member-declaration → protocol-initializer-declaration

   protocol-member-declaration → protocol-subscript-declaration

   protocol-member-declaration → protocol-associated-type-declaration

   protocol-member-declaration → typealias-declaration

   Grammar of a protocol property declaration

   protocol-property-declaration → variable-declaration-head
variable-name type-annotation getter-setter-keyword-block

   Grammar of a protocol method declaration

   protocol-method-declaration → function-head function-name
generic-parameter-clause _{opt} function-signature generic-where-clause
_{opt}

   Grammar of a protocol initializer declaration

   protocol-initializer-declaration → initializer-head
generic-parameter-clause _{opt} parameter-clause =throws=_opt
generic-where-clause _{opt}

   protocol-initializer-declaration → initializer-head
generic-parameter-clause _{opt} parameter-clause ‘rethrows’
generic-where-clause _{opt}

   Grammar of a protocol subscript declaration

   protocol-subscript-declaration → subscript-head subscript-result
generic-where-clause _{opt} getter-setter-keyword-block

   Grammar of a protocol associated type declaration

   protocol-associated-type-declaration → attributes _{opt}
access-level-modifier _{opt} ‘associatedtype’ typealias-name
type-inheritance-clause _{opt} typealias-assignment _{opt}
generic-where-clause _{opt}

   Grammar of an initializer declaration

   initializer-declaration → initializer-head generic-parameter-clause
_{opt} parameter-clause =throws=_opt generic-where-clause _{opt}
initializer-body

   initializer-declaration → initializer-head generic-parameter-clause
_{opt} parameter-clause ‘rethrows’ generic-where-clause _{opt}
initializer-body

   initializer-head → attributes _{opt} declaration-modifiers _{opt}
‘init’

   initializer-head → attributes _{opt} declaration-modifiers _{opt}
‘init’ ‘?’

   initializer-head → attributes _{opt} declaration-modifiers _{opt}
‘init’ ‘!’

   initializer-body → code-block

   Grammar of a deinitializer declaration

   deinitializer-declaration → attributes _{opt} ‘deinit’ code-block

   Grammar of an extension declaration

   extension-declaration → attributes _{opt} access-level-modifier
_{opt} ‘extension’ type-identifier type-inheritance-clause _{opt}
generic-where-clause _{opt} extension-body

   extension-body → ‘{’ extension-members _{opt} ‘}’

   extension-members → extension-member extension-members _{opt}

   extension-member → declaration
   compiler-control-statement

   Grammar of a subscript declaration

   subscript-declaration → subscript-head subscript-result
generic-where-clause _{opt} code-block

   subscript-declaration → subscript-head subscript-result
generic-where-clause _{opt} getter-setter-block

   subscript-declaration → subscript-head subscript-result
generic-where-clause _{opt} getter-setter-keyword-block

   subscript-head → attributes _{opt} declaration-modifiers _{opt}
‘subscript’ generic-parameter-clause _{opt} parameter-clause

   subscript-result → ‘->’ attributes _{opt} type

   Grammar of an operator declaration

   operator-declaration → prefix-operator-declaration
   postfix-operator-declaration
   infix-operator-declaration

   prefix-operator-declaration → ‘prefix’ ‘operator’ operator

   postfix-operator-declaration → ‘postfix’ ‘operator’ operator

   infix-operator-declaration → ‘infix’ ‘operator’ operator
infix-operator-group _{opt}

   infix-operator-group → ‘:’ precedence-group-name

   Grammar of a precedence group declaration

   precedence-group-declaration → ‘precedencegroup’
precedence-group-name ‘{’ precedence-group-attributes _{opt} ‘}’

   precedence-group-attributes → precedence-group-attribute
precedence-group-attributes _{opt}

   precedence-group-attribute → precedence-group-relation

   precedence-group-attribute → precedence-group-assignment

   precedence-group-attribute → precedence-group-associativity

   precedence-group-relation → ‘higherThan’ ‘:’ precedence-group-names

   precedence-group-relation → ‘lowerThan’ ‘:’ precedence-group-names

   precedence-group-assignment → ‘assignment’ ‘:’ boolean-literal

   precedence-group-associativity → ‘associativity’ ‘:’ ‘left’

   precedence-group-associativity → ‘associativity’ ‘:’ ‘right’

   precedence-group-associativity → ‘associativity’ ‘:’ ‘none’

   precedence-group-names → precedence-group-name
   precedence-group-name ‘,’ precedence-group-names

   precedence-group-name → identifier

   Grammar of a declaration modifier

   declaration-modifier → ‘class’ | ‘convenience’ | ‘dynamic’ | ‘final’
| ‘infix’ | ‘lazy’ | ‘optional’ | ‘override’ | ‘postfix’ | ‘prefix’ |
‘required’ | ‘static’ | ‘unowned’ | ‘unowned’ ‘(’ ‘safe’ ‘)’ | ‘unowned’
‘(’ ‘unsafe’ ‘)’ | ‘weak’

   declaration-modifier → access-level-modifier

   declaration-modifier → mutation-modifier

   declaration-modifiers → declaration-modifier declaration-modifiers
_{opt}

   access-level-modifier → ‘private’ | ‘private’ ‘(’ ‘set’ ‘)’

   access-level-modifier → ‘fileprivate’ | ‘fileprivate’ ‘(’ ‘set’ ‘)’

   access-level-modifier → ‘internal’ | ‘internal’ ‘(’ ‘set’ ‘)’

   access-level-modifier → ‘public’ | ‘public’ ‘(’ ‘set’ ‘)’

   access-level-modifier → ‘open’ | ‘open’ ‘(’ ‘set’ ‘)’

   mutation-modifier → ‘mutating’ | ‘nonmutating’


File: swift-reference.info,  Node: Attributes 1,  Next: Patterns 1,  Prev: Declarations 1,  Up: Summary of the Grammar

11.6 Attributes
===============

Grammar of an attribute

   attribute → ‘@’ attribute-name attribute-argument-clause _{opt}

   attribute-name → identifier

   attribute-argument-clause → ‘(’ balanced-tokens _{opt} ‘)’

   attributes → attribute attributes _{opt}

   balanced-tokens → balanced-token balanced-tokens _{opt}

   balanced-token → ‘(’ balanced-tokens _{opt} ‘)’

   balanced-token → ‘[’ balanced-tokens _{opt} ‘]’

   balanced-token → ‘{’ balanced-tokens _{opt} ‘}’

   balanced-token → Any identifier, keyword, literal, or operator

   balanced-token → Any punctuation except ‘(’, ‘)’, ‘[’, ‘]’, ‘{’, or
‘}’


File: swift-reference.info,  Node: Patterns 1,  Next: Generic Parameters and Arguments 1,  Prev: Attributes 1,  Up: Summary of the Grammar

11.7 Patterns
=============

Grammar of a pattern

   pattern → wildcard-pattern type-annotation _{opt}

   pattern → identifier-pattern type-annotation _{opt}

   pattern → value-binding-pattern

   pattern → tuple-pattern type-annotation _{opt}

   pattern → enum-case-pattern

   pattern → optional-pattern

   pattern → type-casting-pattern

   pattern → expression-pattern

   Grammar of a wildcard pattern

   wildcard-pattern → ‘_’

   Grammar of an identifier pattern

   identifier-pattern → identifier

   Grammar of a value-binding pattern

   value-binding-pattern → ‘var’ pattern | ‘let’ pattern

   Grammar of a tuple pattern

   tuple-pattern → ‘(’ tuple-pattern-element-list _{opt} ‘)’

   tuple-pattern-element-list → tuple-pattern-element
   tuple-pattern-element ‘,’ tuple-pattern-element-list

   tuple-pattern-element → pattern | identifier ‘:’ pattern

   Grammar of an enumeration case pattern

   enum-case-pattern → type-identifier _{opt} ‘.’ enum-case-name
tuple-pattern _{opt}

   Grammar of an optional pattern

   optional-pattern → identifier-pattern ‘?’

   Grammar of a type casting pattern

   type-casting-pattern → is-pattern | as-pattern

   is-pattern → ‘is’ type

   as-pattern → pattern ‘as’ type

   Grammar of an expression pattern

   expression-pattern → expression


File: swift-reference.info,  Node: Generic Parameters and Arguments 1,  Prev: Patterns 1,  Up: Summary of the Grammar

11.8 Generic Parameters and Arguments
=====================================

Grammar of a generic parameter clause

   generic-parameter-clause → ‘<’ generic-parameter-list ‘>’

   generic-parameter-list → generic-parameter
   generic-parameter ‘,’ generic-parameter-list

   generic-parameter → type-name

   generic-parameter → type-name ‘:’ type-identifier

   generic-parameter → type-name ‘:’ protocol-composition-type

   generic-where-clause → ‘where’ requirement-list

   requirement-list → requirement
   requirement ‘,’ requirement-list

   requirement → conformance-requirement
   same-type-requirement

   conformance-requirement → type-identifier ‘:’ type-identifier

   conformance-requirement → type-identifier ‘:’
protocol-composition-type

   same-type-requirement → type-identifier ‘==’ type

   Grammar of a generic argument clause

   generic-argument-clause → ‘<’ generic-argument-list ‘>’

   generic-argument-list → generic-argument
   generic-argument ‘,’ generic-argument-list

   generic-argument → type


File: swift-reference.info,  Node: Index,  Prev: Summary of the Grammar,  Up: Top

Index
*****

 [index ]
* Menu:

* #colorLiteral:                         Literal Expression.  (line  67)
* #column:                               Literal Expression.  (line  10)
* #dsohandle:                            Literal Expression.  (line  10)
* #error:                                Compile-Time Diagnostic Statement.
                                                              (line  10)
* #file:                                 Literal Expression.  (line  10)
* #function:                             Literal Expression.  (line  10)
* #if:                                   Conditional Compilation Block.
                                                              (line   9)
* #imageLiteral:                         Literal Expression.  (line  67)
* #line:                                 Literal Expression.  (line  10)
* #selector:                             Selector Expression. (line  10)
* #sourceLocation:                       Line Control Statement.
                                                              (line  11)
* #warning:                              Compile-Time Diagnostic Statement.
                                                              (line  10)
* @discardableResult:                    discardableResult.   (line   6)
* @dynamicCallable:                      dynamicCallable.     (line   6)
* @dynamicCallable <1>:                  NSManaged.           (line   6)
* @dynamicMemberLookup:                  dynamicMemberLookup. (line   6)
* @frozen:                               frozen.              (line   6)
* @GKInspectable:                        GKInspectable.       (line   6)
* @inlinable:                            inlinable.           (line   6)
* @nonobjc:                              nonobjc.             (line   6)
* @NSApplicationMain:                    NSApplicationMain.   (line   6)
* @NSCopying:                            NSCopying.           (line   6)
* @objc:                                 objc.                (line   6)
* @objcMembers:                          objcMembers.         (line   6)
* @propertyWrapper:                      propertyWrapper.     (line   6)
* @requires_stored_property_inits:       requires_stored_property_inits.
                                                              (line   6)
* @testable:                             testable.            (line   6)
* @UIApplicationMain:                    UIApplicationMain.   (line   6)
* @unknown:                              Guard Statement.     (line 132)
* @usableFromInline:                     usableFromInline.    (line   6)
* @warn_unqualified_access:              warn_unqualified_access.
                                                              (line   6)
* arch:                                  Conditional Compilation Block.
                                                              (line  73)
* associatedtype:                        Protocol Associated Type Declaration.
                                                              (line   6)
* associativity:                         Precedence Group Declaration.
                                                              (line  47)
* canImport:                             Conditional Compilation Block.
                                                              (line  62)
* compiler:                              Conditional Compilation Block.
                                                              (line  35)
* deinit:                                Deinitializer Declaration.
                                                              (line   6)
* enum:                                  Enumeration Declaration.
                                                              (line   9)
* extension:                             Extension Declaration.
                                                              (line   6)
* fileprivate:                           Access Control Levels.
                                                              (line  32)
* inout:                                 In-Out Parameters.   (line   6)
* internal:                              Access Control Levels.
                                                              (line  26)
* mutating:                              Special Kinds of Methods.
                                                              (line   6)
* open:                                  Access Control Levels.
                                                              (line  12)
* private:                               Access Control Levels.
                                                              (line  37)
* public:                                Access Control Levels.
                                                              (line  19)
* rethrows:                              Rethrowing Functions and Methods.
                                                              (line   6)
* Self:                                  Protocol Associated Type Declaration.
                                                              (line   6)
* swift:                                 Conditional Compilation Block.
                                                              (line  35)
* targetEnvironment:                     Conditional Compilation Block.
                                                              (line  68)
* where:                                 Protocol Associated Type Declaration.
                                                              (line  15)



Tag Table:
Node: Top235
Node: Language Reference5379
Node: About the Language Reference5892
Node: How to Read the Grammar6746
Node: Lexical Structure8588
Node: Whitespace and Comments9473
Node: Identifiers11551
Node: Keywords and Punctuation14875
Node: Literals17894
Node: Integer Literals20428
Node: Floating-Point Literals23197
Node: String Literals26176
Node: Operators33726
Node: Types39731
Node: Type Annotation42222
Node: Type Identifier43062
Node: Tuple Type44542
Node: Function Type46055
Node: Restrictions for Nonescaping Closures50385
Node: Array Type52925
Node: Dictionary Type54648
Node: Optional Type55989
Node: Implicitly Unwrapped Optional Type57745
Node: Protocol Composition Type60119
Node: Opaque Type62203
Node: Metatype Type63740
Node: Self Type66355
Node: Type Inheritance Clause68589
Node: Type Inference70419
Node: Expressions72163
Node: Prefix Expressions73204
Node: Try Operator74418
Node: Binary Expressions76380
Node: Assignment Operator78012
Node: Type-Casting Operators79583
Node: Primary Expressions82459
Node: Literal Expression83784
Node: Self Expression88368
Node: Superclass Expression90024
Node: Closure Expression91204
Node: Implicit Member Expression98553
Node: Parenthesized Expression99191
Node: Tuple Expression99807
Node: Wildcard Expression101487
Node: Key-Path Expression101980
Node: Selector Expression108924
Node: Key-Path String Expression111549
Node: Postfix Expressions114288
Node: Function Call Expression115757
Node: Initializer Expression118079
Node: Explicit Member Expression119691
Node: Postfix Self Expression122448
Node: Subscript Expression123337
Node: Forced-Value Expression124200
Node: Optional-Chaining Expression125224
Node: Statements128023
Node: Loop Statements129992
Node: For-In Statement130866
Node: While Statement132286
Node: Repeat-While Statement133795
Node: Branch Statements135082
Node: If Statement135956
Node: Guard Statement137795
Node: Labeled Statement148241
Node: Control Transfer Statements149589
Node: Break Statement150575
Node: Continue Statement151951
Node: Fallthrough Statement153499
Node: Return Statement154698
Node: Throw Statement156238
Node: Defer Statement157337
Node: Do Statement158840
Node: Compiler Control Statements160794
Node: Conditional Compilation Block161566
Node: Line Control Statement168546
Node: Compile-Time Diagnostic Statement170042
Node: Availability Condition171157
Node: Declarations173323
Node: Top-Level Code175410
Node: Code Blocks176077
Node: Import Declaration176643
Node: Constant Declaration177804
Node: Variable Declaration180783
Node: Stored Variables and Stored Variable Properties182011
Node: Computed Variables and Computed Properties183406
Node: Stored Variable Observers and Property Observers185374
Node: Type Variable Properties188735
Node: Type Alias Declaration191369
Node: Function Declaration194115
Node: Parameter Names195901
Node: In-Out Parameters197431
Node: Special Kinds of Parameters200107
Node: Special Kinds of Methods201611
Node: Methods with Special Names202697
Node: Throwing Functions and Methods205394
Node: Rethrowing Functions and Methods206794
Node: Functions that Never Return208590
Node: Enumeration Declaration210756
Node: Enumerations with Cases of Any Type212614
Node: Enumerations with Cases of a Raw-Value Type215502
Node: Accessing Enumeration Cases218966
Node: Structure Declaration221718
Node: Class Declaration224686
Node: Protocol Declaration229024
Node: Protocol Property Declaration234231
Node: Protocol Method Declaration235938
Node: Protocol Initializer Declaration237544
Node: Protocol Subscript Declaration239016
Node: Protocol Associated Type Declaration240247
Node: Initializer Declaration241882
Node: Failable Initializers245566
Node: Deinitializer Declaration249045
Node: Extension Declaration250262
Node: Conditional Conformance252747
Node: Protocol Conformance Must Not Be Redundant256066
Node: Subscript Declaration260528
Node: Operator Declaration264178
Node: Precedence Group Declaration267576
Node: Declaration Modifiers272279
Node: Access Control Levels277990
Node: Attributes281701
Node: Declaration Attributes282774
Node: available283404
Node: discardableResult288931
Node: dynamicCallable289283
Node: dynamicMemberLookup293203
Node: frozen295735
Node: GKInspectable298321
Node: inlinable298639
Node: nonobjc299726
Node: NSApplicationMain300965
Node: NSCopying301555
Node: NSManaged302156
Node: objc302716
Node: objcMembers307418
Node: propertyWrapper308278
Node: requires_stored_property_inits312272
Node: testable312723
Node: UIApplicationMain313473
Node: usableFromInline314376
Node: warn_unqualified_access315861
Node: Declaration Attributes Used by Interface Builder317089
Node: Type Attributes318122
Node: autoclosure318396
Node: convention318996
Node: escaping320445
Node: Switch Case Attributes321039
Node: unknown321278
Node: Patterns322331
Node: Wildcard Pattern324572
Node: Identifier Pattern325173
Node: Value-Binding Pattern325986
Node: Tuple Pattern327226
Node: Enumeration Case Pattern328949
Node: Optional Pattern330459
Node: Type-Casting Patterns331809
Node: Expression Pattern333246
Node: Generic Parameters and Arguments334969
Node: Generic Parameter Clause335769
Node: Generic Where Clauses337832
Node: Generic Argument Clause340948
Node: Summary of the Grammar343359
Node: Lexical Structure 1343822
Node: Types 1353093
Node: Expressions 1355726
Node: Statements 1364369
Node: Declarations 1372321
Node: Attributes 1386728
Node: Patterns 1387555
Node: Generic Parameters and Arguments 1389091
Node: Index390323

End Tag Table


Local Variables:
coding: utf-8
End:
