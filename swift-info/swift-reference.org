#+TITLE: The Swift Programming Reference (Swift 5.4)

#+AUTHOR: Apple Inc.
#+TEXINFO_HEADER: @syncodeindex vr cp
#+TEXINFO_HEADER: @syncodeindex fn cp
#+TEXINFO_HEADER: @syncodeindex ky cp
#+TEXINFO_DIR_CATEGORY: Emacs
#+TEXINFO_DIR_TITLE: Swift Reference: (swift-reference)
#+TEXINFO_DIR_DESC: The Swift programming language reference

* Language Reference

- [[About the Language Reference][About the Language Reference]]
- [[Lexical Structure][Lexical Structure]]
- [[Types][Types]]
- [[Expressions][Expressions]]
- [[Statements][Statements]]
- [[Declarations][Declarations]]
- [[Attributes][Attributes]]
- [[Patterns][Patterns]]
- [[Generic Parameters and Arguments][Generic Parameters and
Arguments]]
- [[Summary of the Grammar][Summary of the Grammar]]

* About the Language Reference

This part of the book describes the formal grammar of the Swift
programming language. The grammar described here is intended to help you
understand the language in more detail, rather than to allow you to
directly implement a parser or compiler.

The Swift language is relatively small, because many common types,
functions, and operators that appear virtually everywhere in Swift code
are actually defined in the Swift standard library. Although these
types, functions, and operators are not part of the Swift language
itself, they're used extensively in the discussions and code examples
in this part of the book.

** How to Read the Grammar

The notation used to describe the formal grammar of the Swift
programming language follows a few conventions:

- An arrow (→) is used to mark grammar productions and can be read as
  “can consist of.”

- Syntactic categories are indicated by /italic/ text and appear on both
  sides of a grammar production rule.

- Literal words and punctuation are indicated by boldface
  =constant width= text and appear only on the right-hand side of a
  grammar production rule.

- Alternative grammar productions are separated by vertical bars (|).
  When alternative productions are too long to read easily, they're
  broken into multiple grammar production rules on new lines.

- In a few cases, regular font text is used to describe the right-hand
  side of a grammar production rule.

- Optional syntactic categories and literals are marked by a trailing
  subscript, /opt/.

As an example, the grammar of a getter-setter block is defined as
follows:

Grammar of a getter-setter block

→ ={=
getter-clause
setter-clause
_{opt} =}= | ={=
setter-clause
getter-clause
=}=

This definition indicates that a getter-setter block can consist of a
getter clause followed by an optional setter clause, enclosed in braces,
/or/ a setter clause followed by a getter clause, enclosed in braces.
The grammar production above is equivalent to the following two
productions, where the alternatives are spelled out explicitly:

Grammar of a getter-setter block

getter-setter-block
→ ={=
getter-clause
setter-clause
_{opt} =}=

getter-setter-block
→ ={=
setter-clause
getter-clause
=}=

* Lexical Structure

The /lexical structure/ of Swift describes what sequence of characters
form valid tokens of the language. These valid tokens form the
lowest-level building blocks of the language and are used to describe
the rest of the language in subsequent chapters. A token consists of an
identifier, keyword, punctuation, literal, or operator.

In most cases, tokens are generated from the characters of a Swift
source file by considering the longest possible substring from the input
text, within the constraints of the grammar that are specified below.
This behavior is referred to as /longest match/ or /maximal munch/.

** Whitespace and Comments

Whitespace has two uses: to separate tokens in the source file and to
distinguish between prefix, postfix, and binary operators (see
[[Operators][Operators]]), but is otherwise ignored.
The following characters are considered whitespace: space (U+0020), line
feed (U+000A), carriage return (U+000D), horizontal tab (U+0009),
vertical tab (U+000B), form feed (U+000C) and null (U+0000).

Comments are treated as whitespace by the compiler. Single line comments
begin with =//= and continue until a line feed (U+000A) or carriage
return (U+000D). Multiline comments begin with =/*= and end with =*/=.
Nesting multiline comments is allowed, but the comment markers must be
balanced.

Comments can contain additional formatting and markup, as described in
[[https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html][Markup
Formatting Reference]]
[https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/index.html].

Grammar of whitespace

whitespace →
whitespace-item
whitespace
_{opt}

whitespace-item →
line-break

whitespace-item →
inline-space

whitespace-item →
comment

whitespace-item →
multiline-comment

whitespace-item →
U+0000, U+000B, or U+0020

line-break → U+000A

line-break → U+000D

line-break → U+000D
followed by U+000A

inline-spaces →
inline-space
inline-spaces
_{opt}

inline-space → U+0009 or
U+0020

comment → =//=
comment-text
line-break

multiline-comment →
=/*=
multiline-comment-text
=*/=

comment-text →
comment-text-item
comment-text
_{opt}

comment-text-item →
Any Unicode scalar value except U+000A or U+000D

multiline-comment-text
→
multiline-comment-text-item
multiline-comment-text
_{opt}

multiline-comment-text-item
→
multiline-comment

multiline-comment-text-item
→
comment-text-item

multiline-comment-text-item
→ Any Unicode scalar value except =/*= or =*/=

** Identifiers

/Identifiers/ begin with an uppercase or lowercase letter A through Z,
an underscore (=_=), a noncombining alphanumeric Unicode character in
the Basic Multilingual Plane, or a character outside the Basic
Multilingual Plane that isn't in a Private Use Area. After the first
character, digits and combining Unicode characters are also allowed.

To use a reserved word as an identifier, put a backtick (=`=) before and
after it. For example, =class= isn't a valid identifier, but =`class`=
is valid. The backticks aren't considered part of the identifier; =`x`=
and =x= have the same meaning.

Inside a closure with no explicit parameter names, the parameters are
implicitly named =$0=, =$1=, =$2=, and so on. These names are valid
identifiers within the scope of the closure.

The compiler synthesizes identifiers that begin with a dollar sign (=$=)
for properties that have a property wrapper projection. Your code can
interact with these identifiers, but you can't declare identifiers with
that prefix. For more information, see the
[[propertyWrapper][propertyWrapper]] section of the
[[Attributes][Attributes]] chapter.

Grammar of an identifier

identifier →
identifier-head
identifier-characters
_{opt}

identifier → =`=
identifier-head
identifier-characters
_{opt} =`=

identifier →
implicit-parameter-name

identifier →
property-wrapper-projection

identifier-list →
identifier
|
identifier
=,=
identifier-list

identifier-head →
Upper- or lowercase letter A through Z

identifier-head →
=_=

identifier-head →
U+00A8, U+00AA, U+00AD, U+00AF, U+00B2--U+00B5, or U+00B7--U+00BA

identifier-head →
U+00BC--U+00BE, U+00C0--U+00D6, U+00D8--U+00F6, or U+00F8--U+00FF

identifier-head →
U+0100--U+02FF, U+0370--U+167F, U+1681--U+180D, or U+180F--U+1DBF

identifier-head →
U+1E00--U+1FFF

identifier-head →
U+200B--U+200D, U+202A--U+202E, U+203F--U+2040, U+2054, or
U+2060--U+206F

identifier-head →
U+2070--U+20CF, U+2100--U+218F, U+2460--U+24FF, or U+2776--U+2793

identifier-head →
U+2C00--U+2DFF or U+2E80--U+2FFF

identifier-head →
U+3004--U+3007, U+3021--U+302F, U+3031--U+303F, or U+3040--U+D7FF

identifier-head →
U+F900--U+FD3D, U+FD40--U+FDCF, U+FDF0--U+FE1F, or U+FE30--U+FE44

identifier-head →
U+FE47--U+FFFD

identifier-head →
U+10000--U+1FFFD, U+20000--U+2FFFD, U+30000--U+3FFFD, or
U+40000--U+4FFFD

identifier-head →
U+50000--U+5FFFD, U+60000--U+6FFFD, U+70000--U+7FFFD, or
U+80000--U+8FFFD

identifier-head →
U+90000--U+9FFFD, U+A0000--U+AFFFD, U+B0000--U+BFFFD, or
U+C0000--U+CFFFD

identifier-head →
U+D0000--U+DFFFD or U+E0000--U+EFFFD

identifier-character
→ Digit 0 through 9

identifier-character
→ U+0300--U+036F, U+1DC0--U+1DFF, U+20D0--U+20FF, or U+FE20--U+FE2F

identifier-character
→
identifier-head

identifier-characters
→
identifier-character
identifier-characters
_{opt}

implicit-parameter-name
→ =$=
decimal-digits

property-wrapper-projection
→ =$=
identifier-characters

** Keywords and Punctuation

The following keywords are reserved and can't be used as identifiers,
unless they're escaped with backticks, as described above in
[[Identifiers][Identifiers]]. Keywords other than
=inout=, =var=, and =let= can be used as parameter names in a function
declaration or function call without being escaped with backticks. When
a member has the same name as a keyword, references to that member don't
need to be escaped with backticks, except when there's ambiguity between
referring to the member and using the keyword---for example, =self=,
=Type=, and =Protocol= have special meaning in an explicit member
expression, so they must be escaped with backticks in that context.

- Keywords used in declarations: =associatedtype=, =class=, =deinit=,
  =enum=, =extension=, =fileprivate=, =func=, =import=, =init=, =inout=,
  =internal=, =let=, =open=, =operator=, =private=, =protocol=,
  =public=, =rethrows=, =static=, =struct=, =subscript=, =typealias=,
  and =var=.

- Keywords used in statements: =break=, =case=, =continue=, =default=,
  =defer=, =do=, =else=, =fallthrough=, =for=, =guard=, =if=, =in=,
  =repeat=, =return=, =switch=, =where=, and =while=.

- Keywords used in expressions and types: =as=, =Any=, =catch=, =false=,
  =is=, =nil=, =super=, =self=, =Self=, =throw=, =throws=, =true=, and
  =try=.

- Keywords used in patterns: =_=.

- Keywords that begin with a number sign (=#=): =#available=,
  =#colorLiteral=, =#column=, =#else=, =#elseif=, =#endif=, =#error=,
  =#file=, =#fileID=, =#fileLiteral=, =#filePath=, =#function=, =#if=,
  =#imageLiteral=, =#line=, =#selector=, =#sourceLocation=, and
  =#warning=.

- Keywords reserved in particular contexts: =associativity=,
  =convenience=, =dynamic=, =didSet=, =final=, =get=, =infix=,
  =indirect=, =lazy=, =left=, =mutating=, =none=, =nonmutating=,
  =optional=, =override=, =postfix=, =precedence=, =prefix=, =Protocol=,
  =required=, =right=, =set=, =Type=, =unowned=, =weak=, and =willSet=.
  Outside the context in which they appear in the grammar, they can be
  used as identifiers.

The following tokens are reserved as punctuation and can't be used as
custom operators: =(=, =)=, ={=, =}=, =[=, =]=, =.=, =,=, =:=, =;=, ===,
=@=, =#=, =&= (as a prefix operator), =->=, =`=, =?=, and =!= (as a
postfix operator).

** Literals

A /literal/ is the source code representation of a value of a type, such
as a number or string.

The following are examples of literals:

#+BEGIN_SRC swift
  42 // Integer literal
  3.14159 // Floating-point literal
  "Hello, world!" // String literal
  true // Boolean literal
#+END_SRC

A literal doesn't have a type on its own. Instead, a literal is parsed
as having infinite precision and Swift's type inference attempts to
infer a type for the literal. For example, in the declaration
=let x: Int8 = 42=, Swift uses the explicit type annotation (=: Int8=)
to infer that the type of the integer literal =42= is =Int8=. If there
isn't suitable type information available, Swift infers that the
literal's type is one of the default literal types defined in the Swift
standard library. The default types are =Int= for integer literals,
=Double= for floating-point literals, =String= for string literals, and
=Bool= for Boolean literals. For example, in the declaration
=let str = "Hello, world"=, the default inferred type of the string
literal ="Hello, world"= is =String=.

When specifying the type annotation for a literal value, the
annotation's type must be a type that can be instantiated from that
literal value. That is, the type must conform to one of the following
Swift standard library protocols: =ExpressibleByIntegerLiteral= for
integer literals, =ExpressibleByFloatLiteral= for floating-point
literals, =ExpressibleByStringLiteral= for string literals,
=ExpressibleByBooleanLiteral= for Boolean literals,
=ExpressibleByUnicodeScalarLiteral= for string literals that contain
only a single Unicode scalar, and
=ExpressibleByExtendedGraphemeClusterLiteral= for string literals that
contain only a single extended grapheme cluster. For example, =Int8=
conforms to the =ExpressibleByIntegerLiteral= protocol, and therefore it
can be used in the type annotation for the integer literal =42= in the
declaration =let x: Int8 = 42=.

Grammar of a literal

literal →
numeric-literal
|
string-literal
|
boolean-literal
|
nil-literal

numeric-literal →
=-=_{opt}
integer-literal
| =-=_{opt}
floating-point-literal

boolean-literal →
=true= | =false=

nil-literal → =nil=

*** Integer Literals

/Integer literals/ represent integer values of unspecified precision. By
default, integer literals are expressed in decimal; you can specify an
alternate base using a prefix. Binary literals begin with =0b=, octal
literals begin with =0o=, and hexadecimal literals begin with =0x=.

Decimal literals contain the digits =0= through =9=. Binary literals
contain =0= and =1=, octal literals contain =0= through =7=, and
hexadecimal literals contain =0= through =9= as well as =A= through =F=
in upper- or lowercase.

Negative integers literals are expressed by prepending a minus sign
(=-=) to an integer literal, as in =-42=.

Underscores (=_=) are allowed between digits for readability, but
they're ignored and therefore don't affect the value of the literal.
Integer literals can begin with leading zeros (=0=), but they're
likewise ignored and don't affect the base or value of the literal.

Unless otherwise specified, the default inferred type of an integer
literal is the Swift standard library type =Int=. The Swift standard
library also defines types for various sizes of signed and unsigned
integers, as described in
[[info:swift#Integers][Integers]].

Grammar of an integer literal

integer-literal →
binary-literal

integer-literal →
octal-literal

integer-literal →
decimal-literal

integer-literal →
hexadecimal-literal

binary-literal → =0b=
binary-digit
binary-literal-characters
_{opt}

binary-digit → Digit 0 or
1

binary-literal-character
→
binary-digit
| =_=

binary-literal-characters
→
binary-literal-character
binary-literal-characters
_{opt}

octal-literal → =0o=
octal-digit
octal-literal-characters
_{opt}

octal-digit → Digit 0
through 7

octal-literal-character
→
octal-digit
| =_=

octal-literal-characters
→
octal-literal-character
octal-literal-characters
_{opt}

decimal-literal →
decimal-digit
decimal-literal-characters
_{opt}

decimal-digit → Digit 0
through 9

decimal-digits →
decimal-digit
decimal-digits
_{opt}

decimal-literal-character
→
decimal-digit
| =_=

decimal-literal-characters
→
decimal-literal-character
decimal-literal-characters
_{opt}

hexadecimal-literal
→ =0x=
hexadecimal-digit
hexadecimal-literal-characters
_{opt}

hexadecimal-digit →
Digit 0 through 9, a through f, or A through F

hexadecimal-literal-character
→
hexadecimal-digit
| =_=

hexadecimal-literal-characters
→
hexadecimal-literal-character
hexadecimal-literal-characters
_{opt}


*** Floating-Point Literals

/Floating-point literals/ represent floating-point values of unspecified
precision.

By default, floating-point literals are expressed in decimal (with no
prefix), but they can also be expressed in hexadecimal (with a =0x=
prefix).

Decimal floating-point literals consist of a sequence of decimal digits
followed by either a decimal fraction, a decimal exponent, or both. The
decimal fraction consists of a decimal point (=.=) followed by a
sequence of decimal digits. The exponent consists of an upper- or
lowercase =e= prefix followed by a sequence of decimal digits that
indicates what power of 10 the value preceding the =e= is multiplied by.
For example, =1.25e2= represents 1.25 x 10^{2}, which evaluates to
=125.0=. Similarly, =1.25e-2= represents 1.25 x 10^{-2}, which evaluates
to =0.0125=.

Hexadecimal floating-point literals consist of a =0x= prefix, followed
by an optional hexadecimal fraction, followed by a hexadecimal exponent.
The hexadecimal fraction consists of a decimal point followed by a
sequence of hexadecimal digits. The exponent consists of an upper- or
lowercase =p= prefix followed by a sequence of decimal digits that
indicates what power of 2 the value preceding the =p= is multiplied by.
For example, =0xFp2= represents 15 x 2^{2}, which evaluates to =60=.
Similarly, =0xFp-2= represents 15 x 2^{-2}, which evaluates to =3.75=.

Negative floating-point literals are expressed by prepending a minus
sign (=-=) to a floating-point literal, as in =-42.5=.

Underscores (=_=) are allowed between digits for readability, but
they're ignored and therefore don't affect the value of the literal.
Floating-point literals can begin with leading zeros (=0=), but they're
likewise ignored and don't affect the base or value of the literal.

Unless otherwise specified, the default inferred type of a
floating-point literal is the Swift standard library type =Double=,
which represents a 64-bit floating-point number. The Swift standard
library also defines a =Float= type, which represents a 32-bit
floating-point number.

Grammar of a floating-point literal

floating-point-literal
→
decimal-literal
decimal-fraction
_{opt}
decimal-exponent
_{opt}

floating-point-literal
→
hexadecimal-literal
hexadecimal-fraction
_{opt}
hexadecimal-exponent

decimal-fraction →
=.=
decimal-literal

decimal-exponent →
floating-point-e
sign _{opt}
decimal-literal

hexadecimal-fraction
→ =.=
hexadecimal-digit
hexadecimal-literal-characters
_{opt}

hexadecimal-exponent
→
floating-point-p
sign _{opt}
decimal-literal

floating-point-e →
=e= | =E=

floating-point-p →
=p= | =P=

sign → =+= | =-=


*** String Literals

A string literal is a sequence of characters surrounded by quotation
marks. A single-line string literal is surrounded by double quotation
marks and has the following form:

#+BEGIN_SRC swift
  "characters"
#+END_SRC

String literals can't contain an unescaped double quotation mark (="=),
an unescaped backslash (=\=), a carriage return, or a line feed.

A multiline string literal is surrounded by three double quotation marks
and has the following form:

#+BEGIN_SRC swift
  """
  characters
  """
#+END_SRC

Unlike a single-line string literal, a multiline string literal can
contain unescaped double quotation marks (="=), carriage returns, and
line feeds. It can't contain three unescaped double quotation marks next
to each other.

The line break after the ="""= that begins the multiline string literal
isn't part of the string. The line break before the ="""= that ends the
literal is also not part of the string. To make a multiline string
literal that begins or ends with a line feed, write a blank line as its
first or last line.

A multiline string literal can be indented using any combination of
spaces and tabs; this indentation isn't included in the string. The
="""= that ends the literal determines the indentation: Every nonblank
line in the literal must begin with exactly the same indentation that
appears before the closing ="""=; there's no conversion between tabs and
spaces. You can include additional spaces and tabs after that
indentation; those spaces and tabs appear in the string.

Line breaks in a multiline string literal are normalized to use the line
feed character. Even if your source file has a mix of carriage returns
and line feeds, all of the line breaks in the string will be the same.

In a multiline string literal, writing a backslash (=\=) at the end of a
line omits that line break from the string. Any whitespace between the
backslash and the line break is also omitted. You can use this syntax to
hard wrap a multiline string literal in your source code, without
changing the value of the resulting string.

Special characters can be included in string literals of both the
single-line and multiline forms using the following escape sequences:

- Null character (=\0=)

- Backslash (=\\=)

- Horizontal tab (=\t=)

- Line feed (=\n=)

- Carriage return (=\r=)

- Double quotation mark (=\"=)

- Single quotation mark (=\'=)

- Unicode scalar (=\u{=/n/=}=), where /n/ is a hexadecimal number that
  has one to eight digits

The value of an expression can be inserted into a string literal by
placing the expression in parentheses after a backslash (=\=). The
interpolated expression can contain a string literal, but can't contain
an unescaped backslash, a carriage return, or a line feed.

For example, all of the following string literals have the same value:

#+BEGIN_SRC swift
  "1 2 3"
  "1 2 \("3")"
  "1 2 \(3)"
  "1 2 \(1 + 2)"
  let x = 3; "1 2 \(x)"
#+END_SRC

A string delimited by extended delimiters is a sequence of characters
surrounded by quotation marks and a balanced set of one or more number
signs (=#=). A string delimited by extended delimiters has the following
forms:

#+BEGIN_SRC swift
  #"characters"#
  #"""
  characters
  """#
#+END_SRC

Special characters in a string delimited by extended delimiters appear
in the resulting string as normal characters rather than as special
characters. You can use extended delimiters to create strings with
characters that would ordinarily have a special effect such as
generating a string interpolation, starting an escape sequence, or
terminating the string.

The following example shows a string literal and a string delimited by
extended delimiters that create equivalent string values:

#+BEGIN_SRC swift
  let string = #"\(x) \ " \u{2603}"#
  let escaped = "\\(x) \\ \" \\u{2603}"
  print(string)
  // Prints "\(x) \ " \u{2603}"
  print(string == escaped)
  // Prints "true"
#+END_SRC   

If you use more than one number sign to form a string delimited by
extended delimiters, don't place whitespace in between the number signs:

#+BEGIN_SRC swift
  print(###"Line 1\###nLine 2"###) // OK
  print(# # #"Line 1\# # #nLine 2"# # #) // Error
#+END_SRC

Multiline string literals that you create using extended delimiters have
the same indentation requirements as regular multiline string literals.

The default inferred type of a string literal is =String=. For more
information about the =String= type, see
[[info:swift#Strings and Characters][Strings and Characters]]
and [[https://developer.apple.com/documentation/swift/string][=String=]]
[https://developer.apple.com/documentation/swift/string].

String literals that are concatenated by the =+= operator are
concatenated at compile time. For example, the values of =textA= and
=textB= in the example below are identical---no runtime concatenation is
performed.

#+BEGIN_SRC swift
  let textA = "Hello " + "world"
  let textB = "Hello world"
#+END_SRC   

Grammar of a string literal

string-literal →
static-string-literal
|
interpolated-string-literal

string-literal-opening-delimiter
→
extended-string-literal-delimiter
_{opt} ="=

string-literal-closing-delimiter
→ ="=
extended-string-literal-delimiter
_{opt}

static-string-literal
→
string-literal-opening-delimiter
quoted-text
_{opt}
string-literal-closing-delimiter

static-string-literal
→
multiline-string-literal-opening-delimiter
multiline-quoted-text
_{opt}
multiline-string-literal-closing-delimiter

multiline-string-literal-opening-delimiter
→
extended-string-literal-delimiter
="""=

multiline-string-literal-closing-delimiter
→ ="""=
extended-string-literal-delimiter

extended-string-literal-delimiter
→ =#=
extended-string-literal-delimiter
_{opt}

quoted-text →
quoted-text-item
quoted-text
_{opt}

quoted-text-item →
escaped-character

quoted-text-item
→ Any Unicode scalar value except ="=, =\=, U+000A, or U+000D

multiline-quoted-text
→
multiline-quoted-text-item
multiline-quoted-text
_{opt}

multiline-quoted-text-item
→
escaped-character

multiline-quoted-text-item
→ Any Unicode scalar value except =\=

multiline-quoted-text-item
→
escaped-newline

interpolated-string-literal
→
string-literal-opening-delimiter
interpolated-text
_{opt}
string-literal-closing-delimiter

interpolated-string-literal
→
multiline-string-literal-opening-delimiter
multiline-interpolated-text
_{opt}
multiline-string-literal-closing-delimiter

interpolated-text →
interpolated-text-item
interpolated-text
_{opt}

interpolated-text-item
→ =\(=
expression
=)= |
quoted-text-item

multiline-interpolated-text
→
multiline-interpolated-text-item
multiline-interpolated-text
_{opt}

multiline-interpolated-text-item
→ =\(=
expression
=)= |
multiline-quoted-text-item

escape-sequence → =\=
extended-string-literal-delimiter

escaped-character →
escape-sequence
=0= |
escape-sequence
=\= |
escape-sequence
=t= |
escape-sequence
=n= |
escape-sequence
=r= |
escape-sequence
="= |
escape-sequence
='=

escaped-character
→
escape-sequence
=u= ={=
unicode-scalar-digits
=}=

unicode-scalar-digits
→ Between one and eight hexadecimal digits

escaped-newline →
escape-sequence
inline-spaces
_{opt}
line-break

** Operators

The Swift standard library defines a number of operators for your use,
many of which are discussed in
[[info:swift#Basic Operators][Basic Operators]] and
[[info:swift#Advanced Operators][Advanced Operators]]. The
present section describes which characters can be used to define custom
operators.

Custom operators can begin with one of the ASCII characters =/=, ===,
=-=, =+=, =!=, =*=, =%=, =<=, =>=, =&=, =|=, =^=, =?=, or =~=, or one of
the Unicode characters defined in the grammar below (which include
characters from the /Mathematical Operators/, /Miscellaneous Symbols/,
and /Dingbats/ Unicode blocks, among others). After the first character,
combining Unicode characters are also allowed.

You can also define custom operators that begin with a dot (=.=). These
operators can contain additional dots. For example, =.+.= is treated as
a single operator. If an operator doesn't begin with a dot, it can't
contain a dot elsewhere. For example, =+.+= is treated as the =+=
operator followed by the =.+= operator.

Although you can define custom operators that contain a question mark
(=?=), they can't consist of a single question mark character only.
Additionally, although operators can contain an exclamation point (=!=),
postfix operators can't begin with either a question mark or an
exclamation point.

Note

The tokens ===, =->=, =//=, =/*=, =*/=, =.=, the prefix operators =<=,
=&=, and =?=, the infix operator =?=, and the postfix operators =>=,
=!=, and =?= are reserved. These tokens can't be overloaded, nor can
they be used as custom operators.

The whitespace around an operator is used to determine whether an
operator is used as a prefix operator, a postfix operator, or a binary
operator. This behavior is summarized in the following rules:

- If an operator has whitespace around both sides or around neither
  side, it's treated as a binary operator. As an example, the =+++=
  operator in =a+++b= and =a +++ b= is treated as a binary operator.

- If an operator has whitespace on the left side only, it's treated as a
  prefix unary operator. As an example, the =+++= operator in =a +++b=
  is treated as a prefix unary operator.

- If an operator has whitespace on the right side only, it's treated as
  a postfix unary operator. As an example, the =+++= operator in
  =a+++ b= is treated as a postfix unary operator.

- If an operator has no whitespace on the left but is followed
  immediately by a dot (=.=), it's treated as a postfix unary operator.
  As an example, the =+++= operator in =a+++.b= is treated as a postfix
  unary operator (=a+++ .b= rather than =a +++ .b=).

For the purposes of these rules, the characters =(=, =[=, and ={= before
an operator, the characters =)=, =]=, and =}= after an operator, and the
characters =,=, =;=, and =:= are also considered whitespace.

There's one caveat to the rules above. If the =!= or =?= predefined
operator has no whitespace on the left, it's treated as a postfix
operator, regardless of whether it has whitespace on the right. To use
the =?= as the optional-chaining operator, it must not have whitespace
on the left. To use it in the ternary conditional (=?= =:=) operator, it
must have whitespace around both sides.

In certain constructs, operators with a leading =<= or =>= may be split
into two or more tokens. The remainder is treated the same way and may
be split again. As a result, you don't need to add whitespace to
disambiguate between the closing =>= characters in constructs like
=Dictionary<String, Array<Int>>=. In this example, the closing =>=
characters aren't treated as a single token that may then be
misinterpreted as a bit shift =>>= operator.

To learn how to define new, custom operators, see
[[info:swift#Custom Operators][Custom Operators]] and
[[Operator Declaration][Operator Declaration]]. To learn how to
overload existing operators, see
[[info:swift#Operator Methods][Operator Methods]].

Grammar of operators

operator →
operator-head
operator-characters
_{opt}

operator →
dot-operator-head
dot-operator-characters

operator-head → =/= |
=== | =-= | =+= | =!= | =*= | =%= | =<= | =>= | =&= | =|= | =^= | =~= |
=?=

operator-head →
U+00A1--U+00A7

operator-head →
U+00A9 or U+00AB

operator-head →
U+00AC or U+00AE

operator-head →
U+00B0--U+00B1

operator-head →
U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7

operator-head →
U+2016--U+2017

operator-head →
U+2020--U+2027

operator-head →
U+2030--U+203E

operator-head →
U+2041--U+2053

operator-head →
U+2055--U+205E

operator-head →
U+2190--U+23FF

operator-head →
U+2500--U+2775

operator-head →
U+2794--U+2BFF

operator-head →
U+2E00--U+2E7F

operator-head →
U+3001--U+3003

operator-head →
U+3008--U+3020

operator-head →
U+3030

operator-character
→
operator-head

operator-character
→ U+0300--U+036F

operator-character
→ U+1DC0--U+1DFF

operator-character
→ U+20D0--U+20FF

operator-character
→ U+FE00--U+FE0F

operator-character
→ U+FE20--U+FE2F

operator-character
→ U+E0100--U+E01EF

operator-characters
→
operator-character
operator-characters
_{opt}

dot-operator-head →
=.=

dot-operator-character
→ =.= |
operator-character

dot-operator-characters
→
dot-operator-character
dot-operator-characters
_{opt}

binary-operator →
operator

prefix-operator →
operator

postfix-operator →
operator

* Types

In Swift, there are two kinds of types: named types and compound types.
A /named type/ is a type that can be given a particular name when it's
defined. Named types include classes, structures, enumerations, and
protocols. For example, instances of a user-defined class named
=MyClass= have the type =MyClass=. In addition to user-defined named
types, the Swift standard library defines many commonly used named
types, including those that represent arrays, dictionaries, and optional
values.

Data types that are normally considered basic or primitive in other
languages---such as types that represent numbers, characters, and
strings---are actually named types, defined and implemented in the Swift
standard library using structures. Because they're named types, you can
extend their behavior to suit the needs of your program, using an
extension declaration, discussed in
[[info:swift#Extensions][Extensions]] and
[[Extension Declaration][Extension Declaration]].

A /compound type/ is a type without a name, defined in the Swift
language itself. There are two compound types: function types and tuple
types. A compound type may contain named types and other compound types.
For example, the tuple type =(Int, (Int, Int))= contains two elements:
The first is the named type =Int=, and the second is another compound
type =(Int, Int)=.

You can put parentheses around a named type or a compound type. However,
adding parentheses around a type doesn't have any effect. For example,
=(Int)= is equivalent to =Int=.

This chapter discusses the types defined in the Swift language itself
and describes the type inference behavior of Swift.

Grammar of a type

type →
function-type

type →
array-type

type →
dictionary-type

type →
type-identifier

type →
tuple-type

type →
optional-type

type →
implicitly-unwrapped-optional-type

type →
protocol-composition-type

type →
opaque-type

type →
metatype-type

type → =Any=

type → =Self=

type → =(=
type =)=


** Type Annotation

A /type annotation/ explicitly specifies the type of a variable or
expression. Type annotations begin with a colon (=:=) and end with a
type, as the following examples show:

#+BEGIN_SRC swift
  let someTuple: (Double, Double) = (3.14159, 2.71828)
  func someFunction(a: Int) { /* ... */ }
#+END_SRC   

In the first example, the expression =someTuple= is specified to have
the tuple type =(Double, Double)=. In the second example, the parameter
=a= to the function =someFunction= is specified to have the type =Int=.

Type annotations can contain an optional list of type attributes before
the type.

Grammar of a type annotation

type-annotation → =:=
attributes
_{opt} =inout=_{opt}
type


** Type Identifier

A /type identifier/ refers to either a named type or a type alias of a
named or compound type.

Most of the time, a type identifier directly refers to a named type with
the same name as the identifier. For example, =Int= is a type identifier
that directly refers to the named type =Int=, and the type identifier
=Dictionary<String, Int>= directly refers to the named type
=Dictionary<String, Int>=.

There are two cases in which a type identifier doesn't refer to a type
with the same name. In the first case, a type identifier refers to a
type alias of a named or compound type. For instance, in the example
below, the use of =Point= in the type annotation refers to the tuple
type =(Int, Int)=.

#+BEGIN_SRC swift
  typealias Point = (Int, Int)
  let origin: Point = (0, 0)
#+END_SRC   

In the second case, a type identifier uses dot (=.=) syntax to refer to
named types declared in other modules or nested within other types. For
example, the type identifier in the following code references the named
type =MyType= that's declared in the =ExampleModule= module.

#+BEGIN_SRC swift
  var someValue: ExampleModule.MyType
#+END_SRC   

Grammar of a type identifier

type-identifier →
type-name
generic-argument-clause
_{opt} | type-name
generic-argument-clause
_{opt} =.=
type-identifier

type-name →
identifier


** Tuple Type

A /tuple type/ is a comma-separated list of types, enclosed in
parentheses.

You can use a tuple type as the return type of a function to enable the
function to return a single tuple containing multiple values. You can
also name the elements of a tuple type and use those names to refer to
the values of the individual elements. An element name consists of an
identifier followed immediately by a colon (:). For an example that
demonstrates both of these features, see
[[info:swift#Functions with Multiple Return Values][Functions with Multiple Return
Values]].

When an element of a tuple type has a name, that name is part of the
type.

#+BEGIN_SRC swift
  var someTuple = (top: 10, bottom: 12) // someTuple is of type (top: Int, bottom: Int)
  someTuple = (top: 4, bottom: 42) // OK: names match
  someTuple = (9, 99) // OK: names are inferred
  someTuple = (left: 5, right: 5) // Error: names don't match
#+END_SRC
   
All tuple types contain two or more types, except for =Void= which is a
type alias for the empty tuple type, =()=.

Grammar of a tuple type

tuple-type → =(= =)= | =(=
tuple-type-element
=,=
tuple-type-element-list
=)=

tuple-type-element-list →
tuple-type-element
|
tuple-type-element
=,=
tuple-type-element-list

tuple-type-element →
element-name
type-annotation
| type

element-name →
identifier


** Function Type

A /function type/ represents the type of a function, method, or closure
and consists of a parameter and return type separated by an arrow
(=->=):

#+BEGIN_SRC swift
  (parameter type) -> return type
#+END_SRC   

The /parameter type/ is comma-separated list of types. Because the
/return type/ can be a tuple type, function types support functions and
methods that return multiple values.

A parameter of the function type =() -> T= (where =T= is any type) can
apply the =autoclosure= attribute to implicitly create a closure at its
call sites. This provides a syntactically convenient way to defer the
evaluation of an expression without needing to write an explicit closure
when you call the function. For an example of an autoclosure function
type parameter, see
[[info:swift#Autoclosures][Autoclosures]].

A function type can have variadic parameters in its /parameter type/.
Syntactically, a variadic parameter consists of a base type name
followed immediately by three dots (=...=), as in =Int...=. A variadic
parameter is treated as an array that contains elements of the base type
name. For instance, the variadic parameter =Int...= is treated as
=[Int]=. For an example that uses a variadic parameter, see
[[info:swift#Variadic Parameters][Variadic Parameters]].

To specify an in-out parameter, prefix the parameter type with the
=inout= keyword. You can't mark a variadic parameter or a return type
with the =inout= keyword. In-out parameters are discussed in
[[In-Out Parameters][In-Out Parameters]].

If a function type has only one parameter and that parameter's type is a
tuple type, then the tuple type must be parenthesized when writing the
function's type. For example, =((Int, Int)) -> Void= is the type of a
function that takes a single parameter of the tuple type =(Int, Int)=
and doesn't return any value. In contrast, without parentheses,
=(Int, Int) -> Void= is the type of a function that takes two =Int=
parameters and doesn't return any value. Likewise, because =Void= is a
type alias for =()=, the function type =(Void) -> Void= is the same as
=(()) -> ()=---a function that takes a single argument that's an empty
tuple. These types aren't the same as =() -> ()=---a function that
takes no arguments.

Argument names in functions and methods aren't part of the
corresponding function type. For example:

#+BEGIN_SRC swift
  func someFunction(left: Int, right: Int) {}
  func anotherFunction(left: Int, right: Int) {}
  func functionWithDifferentLabels(top: Int, bottom: Int) {}


  var f = someFunction // The type of f is (Int, Int) -> Void, not (left: Int, right: Int) -> Void.
  f = anotherFunction // OK
  f = functionWithDifferentLabels // OK

  func functionWithDifferentArgumentTypes(left: Int, right: String) {}
  f = functionWithDifferentArgumentTypes // Error

  func functionWithDifferentNumberOfArguments(left: Int, right: Int,
                                              top: Int) {}
  f = functionWithDifferentNumberOfArguments // Error
#+END_SRC    

Because argument labels aren't part of a function's type, you omit them
when writing a function type.

#+BEGIN_SRC swift
  var operation: (lhs: Int, rhs: Int) -> Int // Error
  var operation: (_ lhs: Int, _ rhs: Int) -> Int // OK
  var operation: (Int, Int) -> Int // OK
#+END_SRC   

If a function type includes more than a single arrow (=->=), the
function types are grouped from right to left. For example, the function
type =(Int) -> (Int) -> Int= is understood as
=(Int) -> ((Int) -> Int)=---that is, a function that takes an =Int= and
returns another function that takes and returns an =Int=.

Function types that can throw or rethrow an error must be marked with
the =throws= keyword. The =throws= keyword is part of a function's type,
and nonthrowing functions are subtypes of throwing functions. As a
result, you can use a nonthrowing function in the same places as a
throwing one. Throwing and rethrowing functions are described in [[Throwing Functions and Methods][
Throwing Functions and Methods]] and [[Rethrowing Functions and Methods][Rethrowing Functions and Methods]].


*** Restrictions for Nonescaping Closures

A parameter that's a nonescaping function can't be stored in a property,
variable, or constant of type =Any=, because that might allow the value
to escape.

A parameter that's a nonescaping function can't be passed as an argument
to another nonescaping function parameter. This restriction helps Swift
perform more of its checks for conflicting access to memory at compile
time instead of at runtime. For example:

#+BEGIN_SRC swift
  let external: (() -> Void) -> Void = { _ in () }
  func takesTwoFunctions(first: (() -> Void) -> Void, second: (() -> Void) -> Void) {
      first { first {} } // Error
      second { second {} } // Error

      first { second {} } // Error
      second { first {} } // Error

      first { external {} } // OK
      external { first {} } // OK
  }
#+END_SRC    

In the code above, both of the parameters to
=takesTwoFunctions(first:second:)= are functions. Neither parameter is
marked =@escaping=, so they're both nonescaping as a result.

The four function calls marked “Error” in the example above cause
compiler errors. Because the =first= and =second= parameters are
nonescaping functions, they can't be passed as arguments to another
nonescaping function parameter. In contrast, the two function calls
marked “OK” don't cause a compiler error. These function calls don't
violate the restriction because =external= isn't one of the parameters
of =takesTwoFunctions(first:second:)=.

If you need to avoid this restriction, mark one of the parameters as
escaping, or temporarily convert one of the nonescaping function
parameters to an escaping function by using the
=withoutActuallyEscaping(_:do:)= function. For information about
avoiding conflicting access to memory, see
[[info:swift#Memory Safety][Memory Safety]].

Grammar of a function type

function-type →
attributes
_{opt}
function-type-argument-clause
=throws=_{opt} =->=
type

function-type-argument-clause
→ =(= =)=

function-type-argument-clause
→ =(=
function-type-argument-list
=...=_{opt} =)=

function-type-argument-list
→
function-type-argument
|
function-type-argument
=,=
function-type-argument-list

function-type-argument →
attributes
_{opt} =inout=_{opt}
type |
argument-label
type-annotation

argument-label →
identifier


** Array Type

The Swift language provides the following syntactic sugar for the Swift
standard library =Array<Element>= type:

#+BEGIN_SRC swift
  [type]
#+END_SRC

In other words, the following two declarations are equivalent:

#+BEGIN_SRC swift
  let someArray: Array<String> = ["Alex", "Brian", "Dave"]
  let someArray: [String] = ["Alex", "Brian", "Dave"]
#+END_SRC

In both cases, the constant =someArray= is declared as an array of
strings. The elements of an array can be accessed through subscripting
by specifying a valid index value in square brackets: =someArray[0]=
refers to the element at index 0, ="Alex"=.

You can create multidimensional arrays by nesting pairs of square
brackets, where the name of the base type of the elements is contained
in the innermost pair of square brackets. For example, you can create a
three-dimensional array of integers using three sets of square brackets:

#+BEGIN_SRC swift
  var array3D: [[[Int]]] = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
#+END_SRC

When accessing the elements in a multidimensional array, the left-most
subscript index refers to the element at that index in the outermost
array. The next subscript index to the right refers to the element at
that index in the array that's nested one level in. And so on. This
means that in the example above, =array3D[0]= refers to
=[[1, 2], [3, 4]]=, =array3D[0][1]= refers to =[3, 4]=, and
=array3D[0][1][1]= refers to the value 4.

For a detailed discussion of the Swift standard library =Array= type,
see [[info:swift#Arrays][Arrays]].

Grammar of an array type

array-type → =[=
type =]=


** Dictionary Type

The Swift language provides the following syntactic sugar for the Swift
standard library =Dictionary<Key, Value>= type:

#+BEGIN_SRC swift
  [key type: value type]
#+END_SRC   

In other words, the following two declarations are equivalent:

#+BEGIN_SRC swift
  let someDictionary: [String: Int] = ["Alex": 31, "Paul": 39]
  let someDictionary: Dictionary<String, Int> = ["Alex": 31, "Paul": 39]
#+END_SRC
   
In both cases, the constant =someDictionary= is declared as a dictionary
with strings as keys and integers as values.

The values of a dictionary can be accessed through subscripting by
specifying the corresponding key in square brackets:
=someDictionary["Alex"]= refers to the value associated with the key
="Alex"=. The subscript returns an optional value of the dictionary's
value type. If the specified key isn't contained in the dictionary, the
subscript returns =nil=.

The key type of a dictionary must conform to the Swift standard library
=Hashable= protocol.

For a detailed discussion of the Swift standard library =Dictionary=
type, see
[[info:swift#Dictionaries][Dictionaries]].

Grammar of a dictionary type

dictionary-type → =[=
type =:=
type =]=


** Optional Type

The Swift language defines the postfix =?= as syntactic sugar for the
named type =Optional<Wrapped>=, which is defined in the Swift standard
library. In other words, the following two declarations are equivalent:

#+BEGIN_SRC swift
  var optionalInteger: Int?
  var optionalInteger: Optional<Int>
#+END_SRC   

In both cases, the variable =optionalInteger= is declared to have the
type of an optional integer. Note that no whitespace may appear between
the type and the =?=.

The type =Optional<Wrapped>= is an enumeration with two cases, =none=
and =some(Wrapped)=, which are used to represent values that may or may
not be present. Any type can be explicitly declared to be (or implicitly
converted to) an optional type. If you don't provide an initial value
when you declare an optional variable or property, its value
automatically defaults to =nil=.

If an instance of an optional type contains a value, you can access that
value using the postfix operator =!=, as shown below:

#+BEGIN_SRC swift
  optionalInteger = 42
  optionalInteger! // 42
#+END_SRC   

Using the =!= operator to unwrap an optional that has a value of =nil=
results in a runtime error.

You can also use optional chaining and optional binding to conditionally
perform an operation on an optional expression. If the value is =nil=,
no operation is performed and therefore no runtime error is produced.

For more information and to see examples that show how to use optional
types, see [[info:swift#Optionals][Optionals]].

Grammar of an optional type

optional-type →
type =?=


** Implicitly Unwrapped Optional Type

The Swift language defines the postfix =!= as syntactic sugar for the
named type =Optional<Wrapped>=, which is defined in the Swift standard
library, with the additional behavior that it's automatically unwrapped
when it's accessed. If you try to use an implicitly unwrapped optional
that has a value of =nil=, you'll get a runtime error. With the
exception of the implicit unwrapping behavior, the following two
declarations are equivalent:

#+BEGIN_SRC swift
  var implicitlyUnwrappedString: String!
  var explicitlyUnwrappedString: Optional<String>
#+END_SRC   

Note that no whitespace may appear between the type and the =!=.

Because implicit unwrapping changes the meaning of the declaration that
contains that type, optional types that are nested inside a tuple type
or a generic type---such as the element types of a dictionary or
array---can't be marked as implicitly unwrapped. For example:

#+BEGIN_SRC swift
  let tupleOfImplicitlyUnwrappedElements: (Int!, Int!) // Error
  let implicitlyUnwrappedTuple: (Int, Int)! // OK

  let arrayOfImplicitlyUnwrappedElements: [Int!] // Error
  let implicitlyUnwrappedArray: [Int]! // OK
#+END_SRC   

Because implicitly unwrapped optionals have the same =Optional<Wrapped>=
type as optional values, you can use implicitly unwrapped optionals in
all the same places in your code that you can use optionals. For
example, you can assign values of implicitly unwrapped optionals to
variables, constants, and properties of optionals, and vice versa.

As with optionals, if you don't provide an initial value when you
declare an implicitly unwrapped optional variable or property, its value
automatically defaults to =nil=.

Use optional chaining to conditionally perform an operation on an
implicitly unwrapped optional expression. If the value is =nil=, no
operation is performed and therefore no runtime error is produced.

For more information about implicitly unwrapped optional types, see
[[info:swift#Implicitly Unwrapped Optionals][Implicitly Unwrapped
Optionals]].

Grammar of an implicitly unwrapped optional type

implicitly-unwrapped-optional-type
→ type =!=


** Protocol Composition Type

A /protocol composition type/ defines a type that conforms to each
protocol in a list of specified protocols, or a type that's a subclass
of a given class and conforms to each protocol in a list of specified
protocols. Protocol composition types may be used only when specifying a
type in type annotations, in generic parameter clauses, and in generic
=where= clauses.

Protocol composition types have the following form:

#+BEGIN_SRC swift
  Protocol 1 & Protocol 2
#+END_SRC   

A protocol composition type allows you to specify a value whose type
conforms to the requirements of multiple protocols without explicitly
defining a new, named protocol that inherits from each protocol you want
the type to conform to. For example, you can use the protocol
composition type =ProtocolA & ProtocolB & ProtocolC= instead of
declaring a new protocol that inherits from =ProtocolA=, =ProtocolB=,
and =ProtocolC=. Likewise, you can use =SuperClass & ProtocolA= instead
of declaring a new protocol that's a subclass of =SuperClass= and
conforms to =ProtocolA=.

Each item in a protocol composition list is one of the following; the
list can contain at most one class:

- The name of a class

- The name of a protocol

- A type alias whose underlying type is a protocol composition type, a
  protocol, or a class.

When a protocol composition type contains type aliases, it's possible
for the same protocol to appear more than once in the
definitions---duplicates are ignored. For example, the definition of
=PQR= in the code below is equivalent to =P & Q & R=.

#+BEGIN_SRC swift
  typealias PQ = P & Q
  typealias PQR = PQ & Q & R
#+END_SRC
   
Grammar of a protocol composition type

protocol-composition-type
→
type-identifier
=&=
protocol-composition-continuation

protocol-composition-continuation
→
type-identifier
|
protocol-composition-type


** Opaque Type

An /opaque type/ defines a type that conforms to a protocol or protocol
composition, without specifying the underlying concrete type.

Opaque types appear as the return type of a function or subscript, or
the type of a property. Opaque types can't appear as part of a tuple
type or a generic type, such as the element type of an array or the
wrapped type of an optional.

Opaque types have the following form:

#+BEGIN_SRC swift
  some constraint
#+END_SRC   

The /constraint/ is a class type, protocol type, protocol composition
type, or =Any=. A value can be used as an instance of the opaque type
only if it's an instance of a type that conforms to the listed protocol
or protocol composition, or inherits from the listed class. Code that
interacts with an opaque value can use the value only in ways that are
part of the interface defined by the /constraint/.

Protocol declarations can't include opaque types. Classes can't use an
opaque type as the return type of a nonfinal method.

A function that uses an opaque type as its return type must return
values that share a single underlying type. The return type can include
types that are part of the function's generic type parameters. For
example, a function =someFunction<T>()= could return a value of type =T=
or =Dictionary<String, T>=.

Grammar of an opaque type

opaque-type → =some=
type


** Metatype Type

A /metatype type/ refers to the type of any type, including class types,
structure types, enumeration types, and protocol types.

The metatype of a class, structure, or enumeration type is the name of
that type followed by =.Type=. The metatype of a protocol type---not the
concrete type that conforms to the protocol at runtime---is the name of
that protocol followed by =.Protocol=. For example, the metatype of the
class type =SomeClass= is =SomeClass.Type= and the metatype of the
protocol =SomeProtocol= is =SomeProtocol.Protocol=.

You can use the postfix =self= expression to access a type as a value.
For example, =SomeClass.self= returns =SomeClass= itself, not an
instance of =SomeClass=. And =SomeProtocol.self= returns =SomeProtocol=
itself, not an instance of a type that conforms to =SomeProtocol= at
runtime. You can call the =type(of:)= function with an instance of a
type to access that instance's dynamic, runtime type as a value, as the
following example shows:

#+BEGIN_SRC swift
  class SomeBaseClass {
      class func printClassName() {
          print("SomeBaseClass")
      }
  }
  class SomeSubClass: SomeBaseClass {
      override class func printClassName() {
          print("SomeSubClass")
      }
  }
  let someInstance: SomeBaseClass = SomeSubClass()
  // The compile-time type of someInstance is SomeBaseClass,
  // and the runtime type of someInstance is SomeSubClass
  type(of: someInstance).printClassName()
  // Prints "SomeSubClass"
#+END_SRC    

For more information, see
[[https://developer.apple.com/documentation/swift/2885064-type][=type(of:)=]]
[https://developer.apple.com/documentation/swift/2885064-type] in the
Swift standard library.

Use an initializer expression to construct an instance of a type from
that type's metatype value. For class instances, the initializer that's
called must be marked with the =required= keyword or the entire class
marked with the =final= keyword.

#+BEGIN_SRC swift
  class AnotherSubClass: SomeBaseClass {
      let string: String
      required init(string: String) {
          self.string = string
      }
      override class func printClassName() {
          print("AnotherSubClass")
      }
  }
  let metatype: AnotherSubClass.Type = AnotherSubClass.self
  let anotherInstance = metatype.init(string: "some string")
#+END_SRC
    
Grammar of a metatype type

metatype-type →
type =.= =Type= |
type =.= =Protocol=

** Any Type

The =Any= type can contain values from all other types. =Any= can be
used as the concrete type for an instance of any of the following types:

- A class, structure, or enumeration

- A metatype, such as =Int.self=

- A tuple with any types of components

- A closure or function type

#+BEGIN_SRC swift  
  let mixed: [Any] = ["one", 2, true, (4, 5.3), { () -> Int in return 6 }]
#+END_SRC   

When you use =Any= as a concrete type for an instance, you need to cast
the instance to a known type before you can access its properties or
methods. Instances with a concrete type of =Any= maintain their original
dynamic type and can be cast to that type using one of the type-cast
operators---=as=, =as?=, or =as!=. For example, use =as?= to
conditionally downcast the first object in a heterogeneous array to a
=String= as follows:

#+BEGIN_SRC swift
  if let first = mixed.first as? String {
      print("The first item, '\(first)', is a string.")
  }
  // Prints "The first item, 'one', is a string."
#+END_SRC
   
For more information about casting, see
[[info:swift#Type Casting][Type Casting]].

The =AnyObject= protocol is similar to the =Any= type. All classes
implicitly conform to =AnyObject=. Unlike =Any=, which is defined by the
language, =AnyObject= is defined by the Swift standard library. For more
information, see [[info:swift#Class-Only Protocols][Class-Only
Protocols]] and
[[https://developer.apple.com/documentation/swift/anyobject][=AnyObject=]]
[https://developer.apple.com/documentation/swift/anyobject].

** Self Type

[[https://github.com/apple/swift-evolution/blob/master/proposals/0068-universal-self.md][Proposal]]

The =Self= type isn't a specific type, but rather lets you conveniently
refer to the current type without repeating or knowing that type's name.

In a protocol declaration or a protocol member declaration, the =Self=
type refers to the eventual type that conforms to the protocol.

In a structure, class, or enumeration declaration, the =Self= type
refers to the type introduced by the declaration. Inside the declaration
for a member of a type, the =Self= type refers to that type. In the
members of a class declaration, =Self= can appear only as follows:

- As the return type of a method

- As the return type of a read-only subscript

- As the type of a read-only computed property

- In the body of a method

For example, the code below shows an instance method =f= whose return
type is =Self=.

#+BEGIN_SRC swift
  class Superclass {
      func f() -> Self { return self }
  }
  let x = Superclass()
  print(type(of: x.f()))
  // Prints "Superclass"

  class Subclass: Superclass { }
  let y = Subclass()
  print(type(of: y.f()))
  // Prints "Subclass"

  let z: Superclass = Subclass()
  print(type(of: z.f()))
  // Prints "Subclass"
#+END_SRC

The last part of the example above shows that =Self= refers to the
runtime type =Subclass= of the value of =z=, not the compile-time type
=Superclass= of the variable itself.

Inside a nested type declaration, the =Self= type refers to the type
introduced by the innermost type declaration.

The =Self= type refers to the same type as the
[[https://developer.apple.com/documentation/swift/2885064-type][=type(of:)=]]
[https://developer.apple.com/documentation/swift/2885064-type] function
in the Swift standard library. Writing =Self.someStaticMember= to access
a member of the current type is the same as writing
=type(of: self).someStaticMember=.

Grammar of a Self type

self-type → =Self=



** Type Inheritance Clause

A /type inheritance clause/ is used to specify which class a named type
inherits from and which protocols a named type conforms to. A type
inheritance clause begins with a colon (=:=), followed by a list of type
identifiers.

Class types can inherit from a single superclass and conform to any
number of protocols. When defining a class, the name of the superclass
must appear first in the list of type identifiers, followed by any
number of protocols the class must conform to. If the class doesn't
inherit from another class, the list can begin with a protocol instead.
For an extended discussion and several examples of class inheritance,
see [[info:swift#Inheritance][Inheritance]].

Other named types can only inherit from or conform to a list of
protocols. Protocol types can inherit from any number of other
protocols. When a protocol type inherits from other protocols, the set
of requirements from those other protocols are aggregated together, and
any type that inherits from the current protocol must conform to all of
those requirements.

A type inheritance clause in an enumeration definition can be either a
list of protocols, or in the case of an enumeration that assigns raw
values to its cases, a single, named type that specifies the type of
those raw values. For an example of an enumeration definition that uses
a type inheritance clause to specify the type of its raw values, see
[[info:swift#Raw Values][Raw Values]].

Grammar of a type inheritance clause

type-inheritance-clause →
=:=
type-inheritance-list

type-inheritance-list →
type-identifier
|
type-identifier
=,=
type-inheritance-list


** Type Inference

Swift uses /type inference/ extensively, allowing you to omit the type
or part of the type of many variables and expressions in your code. For
example, instead of writing =var x: Int = 0=, you can write =var x = 0=,
omitting the type completely---the compiler correctly infers that =x=
names a value of type =Int=. Similarly, you can omit part of a type when
the full type can be inferred from context. For example, if you write
=let dict: Dictionary = ["A": 1]=, the compiler infers that =dict= has
the type =Dictionary<String, Int>=.

In both of the examples above, the type information is passed up from
the leaves of the expression tree to its root. That is, the type of =x=
in =var x: Int = 0= is inferred by first checking the type of =0= and
then passing this type information up to the root (the variable =x=).

In Swift, type information can also flow in the opposite
direction---from the root down to the leaves. In the following example,
for instance, the explicit type annotation (=: Float=) on the constant
=eFloat= causes the numeric literal =2.71828= to have an inferred type
of =Float= instead of =Double=.

#+BEGIN_SRC swift
  let e = 2.71828 // The type of e is inferred to be Double.
  let eFloat: Float = 2.71828 // The type of eFloat is Float.
#+END_SRC   

Type inference in Swift operates at the level of a single expression or
statement. This means that all of the information needed to infer an
omitted type or part of a type in an expression must be accessible from
type-checking the expression or one of its subexpressions.

* Expressions

In Swift, there are four kinds of expressions: prefix expressions,
binary expressions, primary expressions, and postfix expressions.
Evaluating an expression returns a value, causes a side effect, or both.

Prefix and binary expressions let you apply operators to smaller
expressions. Primary expressions are conceptually the simplest kind of
expression, and they provide a way to access values. Postfix
expressions, like prefix and binary expressions, let you build up more
complex expressions using postfixes such as function calls and member
access. Each kind of expression is described in detail in the sections
below.

Grammar of an expression

expression →
try-operator
_{opt}
prefix-expression
binary-expressions
_{opt}

expression-list →
expression
|
expression
=,=
expression-list


** Prefix Expressions

/Prefix expressions/ combine an optional prefix operator with an
expression. Prefix operators take one argument, the expression that
follows them.

For information about the behavior of these operators, see
[[info:swift#Basic Operators][Basic Operators]] and
[[info:swift#Advanced Operators][Advanced Operators]].

For information about the operators provided by the Swift standard
library, see
[[https://developer.apple.com/documentation/swift/operator_declarations][Operator
Declarations]]
[https://developer.apple.com/documentation/swift/operator_declarations].

Grammar of a prefix expression

prefix-expression →
prefix-operator
_{opt}
postfix-expression

prefix-expression →
in-out-expression

in-out-expression → =&=
identifier

*** In-Out Expression

An /in-out expression/ marks a variable that's being passed as an in-out
argument to a function call expression.

#+BEGIN_SRC swift
  &expression
#+END_SRC   

For more information about in-out parameters and to see an example, see

[[info:swift-reference#In-Out Parameters][In-Out Parameters]].

In-out expressions are also used when providing a non-pointer argument
in a context where a pointer is needed, as described in
[[info:swift-reference#Implicit Conversion to a Pointer Type][Implicit Conversion to a Pointer Type]].

Grammar of an in-out expression

in-out-expression → =&=
identifier

*** Try Operator

A /try expression/ consists of the =try= operator followed by an
expression that can throw an error. It has the following form:

#+BEGIN_SRC swift
  try expression
#+END_SRC   

An /optional-try expression/ consists of the =try?= operator followed by
an expression that can throw an error. It has the following form:

#+BEGIN_SRC swift
  try? expression
#+END_SRC   

If the /expression/ doesn't throw an error, the value of the
optional-try expression is an optional containing the value of the
/expression/. Otherwise, the value of the optional-try expression is
=nil=.

A /forced-try expression/ consists of the =try!= operator followed by an
expression that can throw an error. It has the following form:

#+BEGIN_SRC swift
  try! expression
#+END_SRC   

If the /expression/ throws an error, a runtime error is produced.

When the expression on the left-hand side of a binary operator is marked
with =try=, =try?=, or =try!=, that operator applies to the whole binary
expression. That said, you can use parentheses to be explicit about the
scope of the operator's application.

#+BEGIN_SRC swift
  sum = try someThrowingFunction() + anotherThrowingFunction() // try applies to both function calls
  sum = try (someThrowingFunction() + anotherThrowingFunction()) // try applies to both function calls
  sum = (try someThrowingFunction()) + anotherThrowingFunction() // Error: try applies only to the first function call
#+END_SRC   

A =try= expression can't appear on the right-hand side of a binary
operator, unless the binary operator is the assignment operator or the
=try= expression is enclosed in parentheses.

For more information and to see examples of how to use =try=, =try?=,
and =try!=, see [[info:swift#Error Handling][Error
Handling]].

Grammar of a try expression

try-operator → =try= | =try=
=?= | =try= =!=


** Binary Expressions

/Binary expressions/ combine an infix binary operator with the
expression that it takes as its left-hand and right-hand arguments. It
has the following form:

#+BEGIN_SRC swift
  left-hand argument operator right-hand argument
#+END_SRC   

For information about the behavior of these operators, see
[[info:swift#Basic Operators][Basic Operators]] and
[[info:swift#Advanced Operators][Advanced Operators]].

For information about the operators provided by the Swift standard
library, see
[[https://developer.apple.com/documentation/swift/operator_declarations][Operator
Declarations]]
[https://developer.apple.com/documentation/swift/operator_declarations].

Note

At parse time, an expression made up of binary operators is represented
as a flat list. This list is transformed into a tree by applying
operator precedence. For example, the expression =2 + 3 * 5= is
initially understood as a flat list of five items, =2=, =+=, =3=, =*=,
and =5=. This process transforms it into the tree (2 + (3 * 5)).

Grammar of a binary expression

binary-expression →
binary-operator
prefix-expression

binary-expression →
assignment-operator
try-operator
_{opt}
prefix-expression

binary-expression →
conditional-operator
try-operator
_{opt}
prefix-expression

binary-expression →
type-casting-operator

binary-expressions →
binary-expression
binary-expressions
_{opt}


*** Assignment Operator

The /assignment operator/ sets a new value for a given expression. It
has the following form:

#+BEGIN_SRC swift
  expression = value
#+END_SRC

The value of the /expression/ is set to the value obtained by evaluating
the /value/. If the /expression/ is a tuple, the /value/ must be a tuple
with the same number of elements. (Nested tuples are allowed.)
Assignment is performed from each part of the /value/ to the
corresponding part of the /expression/. For example:

#+BEGIN_SRC swift
  (a, _, (b, c)) = ("test", 9.45, (12, 3)) // a is "test", b is 12, c is 3, and 9.45 is ignored
#+END_SRC   

The assignment operator doesn't return any value.

Grammar of an assignment operator

assignment-operator →
===


*** Ternary Conditional Operator

The /ternary conditional operator/ evaluates to one of two given values
based on the value of a condition. It has the following form:

#+BEGIN_SRC swift
  condition ? expression used if true : expression used if false
#+END_SRC   

If the /condition/ evaluates to =true=, the conditional operator
evaluates the first expression and returns its value. Otherwise, it
evaluates the second expression and returns its value. The unused
expression isn't evaluated.

For an example that uses the ternary conditional operator, see
[[info:swift#Ternary Conditional Operator][Ternary Conditional
Operator]].

Grammar of a conditional operator

conditional-operator →
=?=
expression
=:=


*** Type-Casting Operators

There are four type-casting operators: the =is= operator, the =as=
operator, the =as?= operator, and the =as!= operator.

They have the following form:

#+BEGIN_SRC swift
  expression is type
  expression as type
  expression as? type
  expression as! type
#+END_SRC   

The =is= operator checks at runtime whether the /expression/ can be cast
to the specified /type/. It returns =true= if the /expression/ can be
cast to the specified /type/; otherwise, it returns =false=.

The =as= operator performs a cast when it's known at compile time that
the cast always succeeds, such as upcasting or bridging. Upcasting lets
you use an expression as an instance of its type's supertype, without
using an intermediate variable. The following approaches are equivalent:

#+BEGIN_SRC swift
  func f(_ any: Any) { print("Function for Any") }
  func f(_ int: Int) { print("Function for Int") }
  let x = 10
  f(x) // Prints "Function for Int"

  let y: Any = x
  f(y) // Prints "Function for Any"

  f(x as Any) // Prints "Function for Any"
#+END_SRC
    
Bridging lets you use an expression of a Swift standard library type
such as =String= as its corresponding Foundation type such as =NSString=
without needing to create a new instance. For more information on
bridging, see
[[https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types][Working
with Foundation Types]]
[https://developer.apple.com/documentation/swift/imported_c_and_objective_c_apis/working_with_foundation_types].

The =as?= operator performs a conditional cast of the /expression/ to
the specified /type/. The =as?= operator returns an optional of the
specified /type/. At runtime, if the cast succeeds, the value of
/expression/ is wrapped in an optional and returned; otherwise, the
value returned is =nil=. If casting to the specified /type/ is
guaranteed to fail or is guaranteed to succeed, a compile-time error is
raised.

The =as!= operator performs a forced cast of the /expression/ to the
specified /type/. The =as!= operator returns a value of the specified
/type/, not an optional type. If the cast fails, a runtime error is
raised. The behavior of =x as! T= is the same as the behavior of
=(x as? T)!=.

For more information about type casting and to see examples that use the
type-casting operators, see [[info:swift#Type Casting][Type
Casting]].

Grammar of a type-casting operator

type-casting-operator
→ =is= type

type-casting-operator
→ =as= type

type-casting-operator
→ =as= =?= type

type-casting-operator
→ =as= =!= type


** Primary Expressions

/Primary expressions/ are the most basic kind of expression. They can be
used as expressions on their own, and they can be combined with other
tokens to make prefix expressions, binary expressions, and postfix
expressions.

Grammar of a primary expression

primary-expression →
identifier
generic-argument-clause
_{opt}

primary-expression
→
literal-expression

primary-expression
→
self-expression

primary-expression
→
superclass-expression

primary-expression
→
closure-expression

primary-expression
→
parenthesized-expression

primary-expression
→
tuple-expression

primary-expression
→
implicit-member-expression

primary-expression
→
wildcard-expression

primary-expression
→
key-path-expression

primary-expression
→
selector-expression

primary-expression
→
key-path-string-expression


*** Literal Expression

[[https://github.com/apple/swift-evolution/blob/master/proposals/0028-modernizing-debug-identifiers.md][Proposal]]

A /literal expression/ consists of either an ordinary literal (such as a
string or a number), an array or dictionary literal, a playground
literal, or one of the following special literals:

#+FINDEX: #file
#+FINDEX: #fileID
#+FINDEX: #filePath
#+FINDEX: #line
#+FINDEX: #column
#+FINDEX: #function
#+FINDEX: #dsohandle

| Literal        | Type                 | Value                                                             |
|----------------+----------------------+-------------------------------------------------------------------|
| =#file=        | =String=             | The name of the file in which it appears.                         |
| =#fileID=      | =String=             | The name of the file and module in which it appears.              |
| =#filePath=    | =String=             | The path to the file in which it appears.                         |
| =#line=        | =Int=                | The line number on which it appears.                              |
| =#column=      | =Int=                | The column number in which it begins.                             |
| =#function=    | =String=             | The name of the declaration in which it appears.                  |
| =#dsohandle=   | =UnsafeRawPointer=   | The DSO (dynamic shared object) handle in use where it appears.   |

The string value of =#file= depends on the language version, to enable
migration from the old =#filePath= behavior to the new =#fileID=
behavior. Currently, =#file= has the same value as =#filePath=. In a
future version of Swift, =#file= will have the same value as =#fileID=
instead. To adopt the future behavior, replace =#file= with =#fileID= or
=#filePath= as appropriate.

The string value of a =#fileID= expression has the form /module///file/,
where /file/ is the name of the file in which the expression appears and
/module/ is the name of the module that this file is part of. The string
value of a =#filePath= expression is the full file-system path to the
file in which the expression appears. Both of these values can be
changed by =#sourceLocation=, as described in
[[info:swift-reference#Line Control Statement][Line Control Statement]]. Because =#fileID=
doesn't embed the full path to the source file, unlike =#filePath=, it
gives you better privacy and reduces the size of the compiled binary.
Avoid using =#filePath= outside of tests, build scripts, or other code
that doesn't become part of the shipping program.

Note

To parse a =#fileID= expression, read the module name as the text before
the first slash (=/=) and the filename as the text after the last slash.
In the future, the string might contain multiple slashes, such as
=MyModule/some/disambiguation/MyFile.swift=.

Inside a function, the value of =#function= is the name of that
function, inside a method it's the name of that method, inside a
property getter or setter it's the name of that property, inside special
members like =init= or =subscript= it's the name of that keyword, and at
the top level of a file it's the name of the current module.

When used as the default value of a function or method parameter, the
special literal's value is determined when the default value expression
is evaluated at the call site.

#+BEGIN_SRC swift
  func logFunctionName(string: String = #function) {
      print(string)
  }
  func myFunction() {
      logFunctionName() // Prints "myFunction()".
  }
#+END_SRC
   
An /array literal/ is an ordered collection of values. It has the
following form:

#+BEGIN_SRC swift
  [value 1, value 2, ...]
#+END_SRC
   
The last expression in the array can be followed by an optional comma.
The value of an array literal has type =[T]=, where =T= is the type of
the expressions inside it. If there are expressions of multiple types,
=T= is their closest common supertype. Empty array literals are written
using an empty pair of square brackets and can be used to create an
empty array of a specified type.

#+BEGIN_SRC swift
  var emptyArray: [Double] = []
#+END_SRC
   
A /dictionary literal/ is an unordered collection of key-value pairs. It
has the following form:

#+BEGIN_SRC swift
  [key 1: value 1, key 2: value 2, ...]
#+END_SRC   

The last expression in the dictionary can be followed by an optional
comma. The value of a dictionary literal has type =[Key: Value]=, where
=Key= is the type of its key expressions and =Value= is the type of its
value expressions. If there are expressions of multiple types, =Key= and
=Value= are the closest common supertype for their respective values. An
empty dictionary literal is written as a colon inside a pair of brackets
(=[:]=) to distinguish it from an empty array literal. You can use an
empty dictionary literal to create an empty dictionary literal of
specified key and value types.

#+BEGIN_SRC swift
  var emptyDictionary: [String: Double] = [:]
#+END_SRC   

#+FINDEX: #colorLiteral
#+FINDEX: #imageLiteral

A /playground literal/ is used by Xcode to create an interactive
representation of a color, file, or image within the program editor.
Playground literals in plain text outside of Xcode are represented using
a special literal syntax.

For information on using playground literals in Xcode, see
[[https://help.apple.com/xcode/mac/current/#/dev4c60242fc][Add a color,
file, or image literal]]
[https://help.apple.com/xcode/mac/current/#/dev4c60242fc] in Xcode Help.

Grammar of a literal expression

literal-expression →
literal

literal-expression
→
array-literal
|
dictionary-literal
|
playground-literal

literal-expression
→ =#file= | =#fileID= | =#filePath= | =#line= | =#column= | =#function= | =#dsohandle=

array-literal → =[=
array-literal-items
_{opt} =]=

array-literal-items →
array-literal-item
=,=_{opt} |
array-literal-item
=,=
array-literal-items

array-literal-item →
expression

dictionary-literal → =[=
dictionary-literal-items
=]= | =[= =:= =]=

dictionary-literal-items
→
dictionary-literal-item
=,=_{opt} |
dictionary-literal-item
=,=
dictionary-literal-items

dictionary-literal-item
→
expression
=:=
expression

playground-literal →
=#colorLiteral= =(= =red= =:=
expression
=,= =green= =:=
expression
=,= =blue= =:=
expression
=,= =alpha= =:=
expression
=)=

playground-literal
→ =#fileLiteral= =(= =resourceName= =:=
expression
=)=

playground-literal
→ =#imageLiteral= =(= =resourceName= =:=
expression
=)=


*** Self Expression

The =self= expression is an explicit reference to the current type or
instance of the type in which it occurs. It has the following forms:

#+BEGIN_SRC swift
  self
  self.member name
  self[subscript index]
  self(initializer arguments)
  self.init(initializer arguments)
#+END_SRC   

In an initializer, subscript, or instance method, =self= refers to the
current instance of the type in which it occurs. In a type method,
=self= refers to the current type in which it occurs.

The =self= expression is used to specify scope when accessing members,
providing disambiguation when there's another variable of the same name
in scope, such as a function parameter. For example:

#+BEGIN_SRC swift
  class SomeClass {
      var greeting: String
      init(greeting: String) {
          self.greeting = greeting
      }
  }
#+END_SRC   

In a mutating method of a value type, you can assign a new instance of
that value type to =self=. For example:

#+BEGIN_SRC swift
  struct Point {
      var x = 0.0, y = 0.0
      mutating func moveBy(x deltaX: Double, y deltaY: Double) {
          self = Point(x: x + deltaX, y: y + deltaY)
      }
  }
#+END_SRC
   
Grammar of a self expression

self-expression → =self= |
self-method-expression
|
self-subscript-expression
|
self-initializer-expression

self-method-expression
→ =self= =.=
identifier

self-subscript-expression
→ =self= =[=
function-call-argument-list
=]=

self-initializer-expression
→ =self= =.= =init=


*** Superclass Expression

A /superclass expression/ lets a class interact with its superclass. It
has one of the following forms:

#+BEGIN_SRC swift
  super.member name
  super[subscript index]
  super.init(initializer arguments)
#+END_SRC   

The first form is used to access a member of the superclass. The second
form is used to access the superclass's subscript implementation. The
third form is used to access an initializer of the superclass.

Subclasses can use a superclass expression in their implementation of
members, subscripting, and initializers to make use of the
implementation in their superclass.

Grammar of a superclass expression

superclass-expression
→
superclass-method-expression
|
superclass-subscript-expression
|
superclass-initializer-expression

superclass-method-expression
→ =super= =.=
identifier

superclass-subscript-expression
→ =super= =[=
function-call-argument-list
=]=

superclass-initializer-expression
→ =super= =.= =init=


*** Closure Expression

A /closure expression/ creates a closure, also known as a /lambda/ or an
/anonymous function/ in other programming languages. Like a function
declaration, a closure contains statements, and it captures constants
and variables from its enclosing scope. It has the following form:

#+BEGIN_SRC swift
  { (parameters) -> return type in statements }
#+END_SRC   

The /parameters/ have the same form as the parameters in a function
declaration, as described in [[Function Declaration][Function
Declaration]].

There are several special forms that allow closures to be written more
concisely:

- A closure can omit the types of its parameters, its return type, or
  both. If you omit the parameter names and both types, omit the =in=
  keyword before the statements. If the omitted types can't be inferred,
  a compile-time error is raised.

- A closure may omit names for its parameters. Its parameters are then
  implicitly named =$= followed by their position: =$0=, =$1=, =$2=, and
  so on.

- A closure that consists of only a single expression is understood to
  return the value of that expression. The contents of this expression
  are also considered when performing type inference on the surrounding
  expression.

The following closure expressions are equivalent:

#+BEGIN_SRC swift
  myFunction { (x: Int, y: Int) -> Int in
      return x + y
  }

  myFunction { x, y in
      return x + y
  }

  myFunction { return $0 + $1 }

  myFunction { $0 + $1 }
#+END_SRC

For information about passing a closure as an argument to a function,
see [[Function Call Expression][Function Call Expression]].

Closure expressions can be used without being stored in a variable or
constant, such as when you immediately use a closure as part of a
function call. The closure expressions passed to =myFunction= in code
above are examples of this kind of immediate use. As a result, whether a
closure expression is escaping or nonescaping depends on the surrounding
context of the expression. A closure expression is nonescaping if it's
called immediately or passed as a nonescaping function argument.
Otherwise, the closure expression is escaping.

For more information about escaping closures, see
[[info:swift#Escaping Closures][Escaping Closures]].


**** Capture Lists

By default, a closure expression captures constants and variables from
its surrounding scope with strong references to those values. You can
use a /capture list/ to explicitly control how values are captured in a
closure.

A capture list is written as a comma-separated list of expressions
surrounded by square brackets, before the list of parameters. If you use
a capture list, you must also use the =in= keyword, even if you omit the
parameter names, parameter types, and return type.

The entries in the capture list are initialized when the closure is
created. For each entry in the capture list, a constant is initialized
to the value of the constant or variable that has the same name in the
surrounding scope. For example in the code below, =a= is included in the
capture list but =b= is not, which gives them different behavior.

#+BEGIN_SRC swift
  var a = 0
  var b = 0
  let closure = { [a] in
      print(a, b)
  }

  a = 10
  b = 10
  closure()
  // Prints "0 10"
#+END_SRC    

There are two different things named =a=, the variable in the
surrounding scope and the constant in the closure's scope, but only one
variable named =b=. The =a= in the inner scope is initialized with the
value of the =a= in the outer scope when the closure is created, but
their values aren't connected in any special way. This means that a
change to the value of =a= in the outer scope doesn't affect the value
of =a= in the inner scope, nor does a change to =a= inside the closure
affect the value of =a= outside the closure. In contrast, there's only
one variable named =b=---the =b= in the outer scope---so changes from
inside or outside the closure are visible in both places.

This distinction isn't visible when the captured variable's type has
reference semantics. For example, there are two things named =x= in the
code below, a variable in the outer scope and a constant in the inner
scope, but they both refer to the same object because of reference
semantics.

#+BEGIN_SRC swift
  class SimpleClass {
      var value: Int = 0
  }
  var x = SimpleClass()
  var y = SimpleClass()
  let closure = { [x] in
      print(x.value, y.value)
  }

  x.value = 10
  y.value = 10
  closure()
  // Prints "10 10"
#+END_SRC    

If the type of the expression's value is a class, you can mark the
expression in a capture list with =weak= or =unowned= to capture a weak
or unowned reference to the expression's value.

#+BEGIN_SRC swift
  myFunction { print(self.title) } // implicit strong capture
  myFunction { [self] in print(self.title) } // explicit strong capture
  myFunction { [weak self] in print(self!.title) } // weak capture
  myFunction { [unowned self] in print(self.title) } // unowned capture
#+END_SRC   

You can also bind an arbitrary expression to a named value in a capture
list. The expression is evaluated when the closure is created, and the
value is captured with the specified strength. For example:

#+BEGIN_SRC swift
  // Weak capture of "self.parent" as "parent"
  myFunction { [weak parent = self.parent] in print(parent!.title) }
#+END_SRC   

For more information and examples of closure expressions, see
[[info:swift#Closure Expressions][Closure Expressions]]. For more
information and examples of capture lists, see
[[info:swift#Resolving Strong Reference Cycles for Closures][Resolving
Strong Reference Cycles for Closures]].

Grammar of a closure expression

closure-expression → ={=
closure-signature
_{opt}
statements
_{opt} =}=

closure-signature →
capture-list
_{opt}
closure-parameter-clause
=throws=_{opt}
function-result
_{opt} =in=

closure-signature →
capture-list
=in=

closure-parameter-clause
→ =(= =)= | =(=
closure-parameter-list
=)= |
identifier-list

closure-parameter-list
→
closure-parameter
|
closure-parameter
=,=
closure-parameter-list

closure-parameter →
closure-parameter-name
type-annotation
_{opt}

closure-parameter →
closure-parameter-name
type-annotation
=...=

closure-parameter-name
→
identifier

capture-list → =[=
capture-list-items
=]=

capture-list-items →
capture-list-item
|
capture-list-item
=,=
capture-list-items

capture-list-item →
capture-specifier
_{opt}
expression

capture-specifier →
=weak= | =unowned= | =unowned(safe)= | =unowned(unsafe)=


*** Implicit Member Expression

An /implicit member expression/ is an abbreviated way to access a member
of a type, such as an enumeration case or a type method, in a context
where type inference can determine the implied type. It has the
following form:

#+BEGIN_SRC swift
  .member name
#+END_SRC
   
For example:

#+BEGIN_SRC swift
  var x = MyEnumeration.someValue
  x = .anotherValue
#+END_SRC
   
Grammar of a implicit member expression

implicit-member-expression
→ =.=
identifier


*** Parenthesized Expression

A /parenthesized expression/ consists of an expression surrounded by
parentheses. You can use parentheses to specify the precedence of
operations by explicitly grouping expressions. Grouping parentheses
don't change an expression's type---for example, the type of =(1)= is
simply =Int=.

Grammar of a parenthesized expression

parenthesized-expression
→ =(=
expression
=)=


*** Tuple Expression

A /tuple expression/ consists of a comma-separated list of expressions
surrounded by parentheses. Each expression can have an optional
identifier before it, separated by a colon (=:=). It has the following
form:

#+BEGIN_SRC swift
  (identifier 1: expression 1, identifier 2: expression 2, ...)
#+END_SRC   

Each identifier in a tuple expression must be unique within the scope of
the tuple expression. In a nested tuple expression, identifiers at the
same level of nesting must be unique. For example, =(a: 10, a: 20)= is
invalid because the label =a= appears twice at the same level. However,
=(a: 10, b: (a: 1, x: 2))= is valid---although =a= appears twice, it
appears once in the outer tuple and once in the inner tuple.

A tuple expression can contain zero expressions, or it can contain two
or more expressions. A single expression inside parentheses is a
parenthesized expression.

Note

Both an empty tuple expression and an empty tuple type are written =()=
in Swift. Because =Void= is a type alias for =()=, you can use it to
write an empty tuple type. However, like all type aliases, =Void= is
always a type---you can't use it to write an empty tuple expression.

Grammar of a tuple expression

tuple-expression → =(= =)=
| =(=
tuple-element
=,=
tuple-element-list
=)=

tuple-element-list →
tuple-element
|
tuple-element
=,=
tuple-element-list

tuple-element →
expression
|
identifier
=:=
expression


*** Wildcard Expression

A /wildcard expression/ is used to explicitly ignore a value during an
assignment. For example, in the following assignment 10 is assigned to
=x= and 20 is ignored:

#+BEGIN_SRC swift
  (x, _) = (10, 20) // x is 10, and 20 is ignored
#+END_SRC   

Grammar of a wildcard expression

wildcard-expression →
=_=


*** Key-Path Expression

A /key-path expression/ refers to a property or subscript of a type. You
use key-path expressions in dynamic programming tasks, such as key-value
observing. They have the following form:

#+BEGIN_SRC swift
  \type name.path
#+END_SRC

The /type name/ is the name of a concrete type, including any generic
parameters, such as =String=, =[Int]=, or =Set<Int>=.

The /path/ consists of property names, subscripts, optional-chaining
expressions, and forced unwrapping expressions. Each of these key-path
components can be repeated as many times as needed, in any order.

At compile time, a key-path expression is replaced by an instance of the
[[https://developer.apple.com/documentation/swift/keypath][=KeyPath=]]
[https://developer.apple.com/documentation/swift/keypath] class.

To access a value using a key path, pass the key path to the
=subscript(keyPath:)= subscript, which is available on all types. For
example:

#+BEGIN_SRC swift
  struct SomeStructure {
      var someValue: Int
  }

  let s = SomeStructure(someValue: 12)
  let pathToProperty = \SomeStructure.someValue

  let value = s[keyPath: pathToProperty] // value is 12
#+END_SRC   

The /type name/ can be omitted in contexts where type inference can
determine the implied type. The following code uses =\.someProperty=
instead of =\SomeClass.someProperty=:

#+BEGIN_SRC swift
  class SomeClass: NSObject {
      @objc dynamic var someProperty: Int
      init(someProperty: Int) {
          self.someProperty = someProperty
      }
  }

  let c = SomeClass(someProperty: 10)
  c.observe(\.someProperty) { object, change in
      // ...
  }
#+END_SRC    

The /path/ can refer to =self= to create the identity key path
(=\.self=). The identity key path refers to a whole instance, so you can
use it to access and change all of the data stored in a variable in a
single step. For example:

#+BEGIN_SRC swift
  var compoundValue = (a: 1, b: 2)
  // Equivalent to compoundValue = (a: 10, b: 20)
  compoundValue[keyPath: \.self] = (a: 10, b: 20)
#+END_SRC   

The /path/ can contain multiple property names, separated by periods, to
refer to a property of a property's value. This code uses the key path
expression =\OuterStructure.outer.someValue= to access the =someValue=
property of the =OuterStructure= type's =outer= property:

#+BEGIN_SRC swift
  struct OuterStructure {
      var outer: SomeStructure
      init(someValue: Int) {
          self.outer = SomeStructure(someValue: someValue)
      }
  }

  let nested = OuterStructure(someValue: 24)
  let nestedKeyPath = \OuterStructure.outer.someValue

  let nestedValue = nested[keyPath: nestedKeyPath]
  // nestedValue is 24
#+END_SRC    

The /path/ can include subscripts using brackets, as long as the
subscript's parameter type conforms to the =Hashable= protocol. This
example uses a subscript in a key path to access the second element of
an array:

#+BEGIN_SRC swift
  let greetings = ["hello", "hola", "bonjour", "안녕"]
  let myGreeting = greetings[keyPath: \[String].[1]]
  // myGreeting is 'hola'
#+END_SRC   

The value used in a subscript can be a named value or a literal. Values
are captured in key paths using value semantics. The following code uses
the variable =index= in both a key-path expression and in a closure to
access the third element of the =greetings= array. When =index= is
modified, the key-path expression still references the third element,
while the closure uses the new index.

#+BEGIN_SRC swift
  var index = 2
  let path = \[String].[index]
  let fn: ([String]) -> String = { strings in strings[index] }

  print(greetings[keyPath: path])
  // Prints "bonjour"
  print(fn(greetings))
  // Prints "bonjour"

  // Setting 'index' to a new value doesn't affect 'path'
  index += 1
  print(greetings[keyPath: path])
  // Prints "bonjour"

  // Because 'fn' closes over 'index', it uses the new value
  print(fn(greetings))
  // Prints "안녕"
#+END_SRC    

The /path/ can use optional chaining and forced unwrapping. This code
uses optional chaining in a key path to access a property of an optional
string:

#+BEGIN_SRC swift
  let firstGreeting: String? = greetings.first
  print(firstGreeting?.count as Any)
  // Prints "Optional(5)"

  // Do the same thing using a key path.
  let count = greetings[keyPath: \[String].first?.count]
  print(count as Any)
  // Prints "Optional(5)"
#+END_SRC   

You can mix and match components of key paths to access values that are
deeply nested within a type. The following code accesses different
values and properties of a dictionary of arrays by using key-path
expressions that combine these components.

#+BEGIN_SRC swift
  let interestingNumbers = ["prime": [2, 3, 5, 7, 11, 13, 17],
                            "triangular": [1, 3, 6, 10, 15, 21, 28],
                            "hexagonal": [1, 6, 15, 28, 45, 66, 91]]
  print(interestingNumbers[keyPath: \[String: [Int]].["prime"]] as Any)
  // Prints "Optional([2, 3, 5, 7, 11, 13, 17])"
  print(interestingNumbers[keyPath: \[String: [Int]].["prime"]![0]])
  // Prints "2"
  print(interestingNumbers[keyPath: \[String: [Int]].["hexagonal"]!.count])
  // Prints "7"
  print(interestingNumbers[keyPath: \[String: [Int]].["hexagonal"]!.count.bitWidth])
  // Prints "64"
#+END_SRC    

You can use a key path expression in contexts where you would normally
provide a function or closure. Specifically, you can use a key path
expression whose root type is =SomeType= and whose path produces a value
of type =Value=, instead of a function or closure of type
=(SomeType) -> Value=.

#+BEGIN_SRC swift
  struct Task {
      var description: String
      var completed: Bool
  }
  var toDoList = [
    Task(description: "Practice ping-pong.", completed: false),
    Task(description: "Buy a pirate costume.", completed: true),
    Task(description: "Visit Boston in the Fall.", completed: false),
  ]

  // Both approaches below are equivalent.
  let descriptions = toDoList.filter(\.completed).map(\.description)
  let descriptions2 = toDoList.filter { $0.completed }.map { $0.description }
#+END_SRC    

Any side effects of a key path expression are evaluated only at the
point where the expression is evaluated. For example, if you make a
function call inside a subscript in a key path expression, the function
is called only once as part of evaluating the expression, not every time
the key path is used.

#+BEGIN_SRC swift
  func makeIndex() -> Int {
      print("Made an index")
      return 0
  }
  // The line below calls makeIndex().
  let taskKeyPath = \[Task][makeIndex()]
  // Prints "Made an index"

  // Using taskKeyPath doesn't call makeIndex() again.
  let someTask = toDoList[keyPath: taskKeyPath]
#+END_SRC    

For more information about using key paths in code that interacts with
Objective-C APIs, see
[[https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift][Using
Objective-C Runtime Features in Swift]]
[https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift].
For information about key-value coding and key-value observing, see
[[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i][Key-Value
Coding Programming Guide]]
[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i]
and
[[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i][Key-Value
Observing Programming Guide]]
[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i].

Grammar of a key-path expression

key-path-expression →
=\= type _{opt} =.=
key-path-components

key-path-components →
key-path-component
|
key-path-component
=.=
key-path-components

key-path-component →
identifier
key-path-postfixes
_{opt} |
key-path-postfixes

key-path-postfixes →
key-path-postfix
key-path-postfixes
_{opt}

key-path-postfix → =?= |
=!= | =self= | =[=
function-call-argument-list
=]=


*** Selector Expression

A selector expression lets you access the selector used to refer to a
method or to a property's getter or setter in Objective-C. It has the
following form:

#+FINDEX: #selector

#+BEGIN_SRC swift
  #selector(method name)
  #selector(getter: property name)
  #selector(setter: property name)
#+END_SRC   

The /method name/ and /property name/ must be a reference to a method or
a property that's available in the Objective-C runtime. The value of a
selector expression is an instance of the =Selector= type. For example:

#+BEGIN_SRC swift
  class SomeClass: NSObject {
      @objc let property: String

      @objc(doSomethingWithInt:)
      func doSomething(_ x: Int) { }


      init(property: String) {
          self.property = property
      }
  }
  let selectorForMethod = #selector(SomeClass.doSomething(_:))
  let selectorForPropertyGetter = #selector(getter:SomeClass.property)
#+END_SRC    

When creating a selector for a property's getter, the /property name/
can be a reference to a variable or constant property. In contrast, when
creating a selector for a property's setter, the /property name/ must be
a reference to a variable property only.

The /method name/ can contain parentheses for grouping, as well the =as=
operator to disambiguate between methods that share a name but have
different type signatures. For example:

#+BEGIN_SRC swift
  extension SomeClass {
      @objc(doSomethingWithString:)
      func doSomething(_ x: String) { }
  }
  let anotherSelector = #selector(SomeClass.doSomething(_:) as (SomeClass) -> (String) -> Void)
#+END_SRC   

Because a selector is created at compile time, not at runtime, the
compiler can check that a method or property exists and that they're
exposed to the Objective-C runtime.

Note

Although the /method name/ and the /property name/ are expressions,
they're never evaluated.

For more information about using selectors in Swift code that interacts
with Objective-C APIs, see
[[https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift][Using
Objective-C Runtime Features in Swift]]
[https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift].

Grammar of a selector expression

selector-expression →
=#selector= =(=
expression
=)=

selector-expression
→ =#selector= =(= =getter:=
expression
=)=

selector-expression
→ =#selector= =(= =setter:=
expression
=)=


*** Key-Path String Expression

A key-path string expression lets you access the string used to refer to
a property in Objective-C, for use in key-value coding and key-value
observing APIs. It has the following form:

#+BEGIN_SRC swift
  #keyPath(property name)
#+END_SRC
   
The /property name/ must be a reference to a property that's available
in the Objective-C runtime. At compile time, the key-path string
expression is replaced by a string literal. For example:

#+BEGIN_SRC swift
  class SomeClass: NSObject {
      @objc var someProperty: Int
      init(someProperty: Int) {
          self.someProperty = someProperty
      }
  }

  let c = SomeClass(someProperty: 12)
  let keyPath = #keyPath(SomeClass.someProperty)

  if let value = c.value(forKey: keyPath) {
      print(value)
  }
  // Prints "12"
#+END_SRC    

When you use a key-path string expression within a class, you can refer
to a property of that class by writing just the property name, without
the class name.

#+BEGIN_SRC swift
  extension SomeClass {
      func getSomeKeyPath() -> String {
          return #keyPath(someProperty)
      }
  }
  print(keyPath == c.getSomeKeyPath())
  // Prints "true"
#+END_SRC   

Because the key path string is created at compile time, not at runtime,
the compiler can check that the property exists and that the property is
exposed to the Objective-C runtime.

For more information about using key paths in Swift code that interacts
with Objective-C APIs, see
[[https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift][Using
Objective-C Runtime Features in Swift]]
[https://developer.apple.com/documentation/swift/using_objective_c_runtime_features_in_swift].
For information about key-value coding and key-value observing, see
[[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i][Key-Value
Coding Programming Guide]]
[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i]
and
[[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i][Key-Value
Observing Programming Guide]]
[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i].

Note

Although the /property name/ is an expression, it's never evaluated.

Grammar of a key-path string expression

key-path-string-expression
→ =#keyPath= =(=
expression
=)=


** Postfix Expressions

/Postfix expressions/ are formed by applying a postfix operator or other
postfix syntax to an expression. Syntactically, every primary expression
is also a postfix expression.

For information about the behavior of these operators, see
[[info:swift#Basic Operators][Basic Operators]] and
[[info:swift#Advanced Operators][Advanced Operators]].

For information about the operators provided by the Swift standard
library, see
[[https://developer.apple.com/documentation/swift/operator_declarations][Operator
Declarations]]
[https://developer.apple.com/documentation/swift/operator_declarations].

Grammar of a postfix expression

postfix-expression →
primary-expression

postfix-expression
→
postfix-expression
postfix-operator

postfix-expression
→
function-call-expression

postfix-expression
→
initializer-expression

postfix-expression
→
explicit-member-expression

postfix-expression
→
postfix-self-expression

postfix-expression
→
subscript-expression

postfix-expression
→
forced-value-expression

postfix-expression
→
optional-chaining-expression


*** Function Call Expression

A /function call expression/ consists of a function name followed by a
comma-separated list of the function's arguments in parentheses.
Function call expressions have the following form:

#+BEGIN_SRC swift
  function name(argument value 1, argument value 2)
#+END_SRC   

The /function name/ can be any expression whose value is of a function
type.

If the function definition includes names for its parameters, the
function call must include names before its argument values, separated
by a colon (=:=). This kind of function call expression has the
following form:

#+BEGIN_SRC swift
  function name(argument name 1: argument value 1, argument name 2: argument value 2)
#+END_SRC   

A function call expression can include trailing closures in the form of
closure expressions immediately after the closing parenthesis. The
trailing closures are understood as arguments to the function, added
after the last parenthesized argument. The first closure expression is
unlabeled; any additional closure expressions are preceded by their
argument labels. The example below shows the equivalent version of
function calls that do and don't use trailing closure syntax:

#+BEGIN_SRC swift
  // someFunction takes an integer and a closure as its arguments
  someFunction(x: x, f: { $0 == 13 })
  someFunction(x: x) { $0 == 13 }

  // anotherFunction takes an integer and two closures as its arguments
  anotherFunction(x: x, f: { $0 == 13 }, g: { print(99) })
  anotherFunction(x: x) { $0 == 13 } g: { print(99) }
#+END_SRC   

If the trailing closure is the function's only argument, you can omit
the parentheses.

#+BEGIN_SRC swift
  // someMethod takes a closure as its only argument
  myData.someMethod() { $0 == 13 }
  myData.someMethod { $0 == 13 }
#+END_SRC   

To include the trailing closures in the arguments, the compiler examines
the function's parameters from left to right as follows:

| Trailing Closure | Parameter            | Action                                                                                                                                             |
|------------------+----------------------+----------------------------------------------------------------------------------------------------------------------------------------------------|
| Labeled          | Labeled              | If the labels are the same, the closure matches the parameter; otherwise, the parameter is skipped.                                                |
| Labeled          | Unlabeled            | The parameter is skipped.                                                                                                                          |
| Unlabeled        | Labeled or unlabeled | If the parameter structurally resembles a function type, as defined below, the closure matches the parameter; otherwise, the parameter is skipped. |

The trailing closure is passed as the argument for the parameter that it
matches. Parameters that were skipped during the scanning process don't
have an argument passed to them---for example, they can use a default
parameter. After finding a match, scanning continues with the next
trailing closure and the next parameter. At the end of the matching
process, all trailing closures must have a match.

A parameter /structurally resembles/ a function type if the parameter
isn't an in-out parameter, and the parameter is one of the following:

- A parameter whose type is a function type, like =(Bool) -> Int=

- An autoclosure parameter whose wrapped expression's type is a function
  type, like =@autoclosure () -> ((Bool) -> Int)=

- A variadic parameter whose array element type is a function type, like
  =((Bool) -> Int)...=

- A parameter whose type is wrapped in one or more layers of optional,
  like =Optional<(Bool) -> Int>=

- A parameter whose type combines these allowed types, like
  =(Optional<(Bool) -> Int>)...=

When a trailing closure is matched to a parameter whose type
structurally resembles a function type, but isn't a function, the
closure is wrapped as needed. For example, if the parameter's type is an
optional type, the closure is wrapped in =Optional= automatically.

To ease migration of code from versions of Swift prior to 5.3---which
performed this matching from right to left---the compiler checks both
the left-to-right and right-to-left orderings. If the scan directions
produce different results, the old right-to-left ordering is used and
the compiler generates a warning. A future version of Swift will always
use the left-to-right ordering.

#+BEGIN_SRC swift
  typealias Callback = (Int) -> Int
  func someFunction(firstClosure: Callback? = nil,
                    secondClosure: Callback? = nil) {
      let first = firstClosure?(10)
      let second = secondClosure?(20)
      print(first ?? "-", second ?? "-")
  }

  someFunction() // Prints "- -"
  someFunction { return $0 + 100 } // Ambiguous
  someFunction { return $0 } secondClosure: { return $0 } // Prints "10 20"
#+END_SRC    

In the example above, the function call marked “Ambiguous” prints “-
120” and produces a compiler warning on Swift 5.3. A future version of
Swift will print “110 -”.   

A class, structure, or enumeration type can enable syntactic sugar for
function call syntax by declaring one of several methods, as described
in [[Methods with Special Names][Methods with Special Names]].

**** Implicit Conversion to a Pointer Type

In a function call expression, if the argument and parameter have a
different type, the compiler tries to make their types match by applying
one of the implicit conversions in the following list:

- =inout SomeType= can become =UnsafePointer<SomeType>= or
  =UnsafeMutablePointer<SomeType>=

- =inout Array<SomeType>= can become =UnsafePointer<SomeType>= or
  =UnsafeMutablePointer<SomeType>=

- =Array<SomeType>= can become =UnsafePointer<SomeType>=

- =String= can become =UnsafePointer<CChar>=

The following two function calls are equivalent:

#+BEGIN_SRC swift
  func unsafeFunction(pointer: UnsafePointer<Int>) {
      // ...
  }
  var myNumber = 1234

  unsafeFunction(pointer: &myNumber)
  withUnsafePointer(to: myNumber) { unsafeFunction(pointer: $0) }
#+END_SRC   

A pointer that's created by these implicit conversions is valid only for
the duration of the function call. To avoid undefined behavior, ensure
that your code never persists the pointer after the function call ends.

Note

When implicitly converting an array to an unsafe pointer, Swift ensures
that the array's storage is contiguous by converting or copying the
array as needed. For example, you can use this syntax with an array that
was bridged to =Array= from an =NSArray= subclass that makes no API
contract about its storage. If you need to guarantee that the array's
storage is already contiguous, so the implicit conversion never needs to
do this work, use =ContiguousArray= instead of =Array=.

Using =&= instead of an explicit function like =withUnsafePointer(to:)=
can help make calls to low-level C functions more readable, especially
when the function takes several pointer arguments. However, when calling
functions from other Swift code, avoid using =&= instead of using the
unsafe APIs explicitly.

Grammar of a function call expression

function-call-expression
→
postfix-expression
function-call-argument-clause

function-call-expression
→
postfix-expression
function-call-argument-clause
_{opt}
trailing-closure

function-call-argument-clause
→ =(= =)= | =(=
function-call-argument-list
=)=

function-call-argument-list
→
function-call-argument
|
function-call-argument
=,=
function-call-argument-list

function-call-argument
→
expression
|
identifier
=:=
expression

function-call-argument
→
operator
|
identifier
=:=
operator

trailing-closure →
closure-expression


*** Initializer Expression

An /initializer expression/ provides access to a type's initializer. It
has the following form:

#+BEGIN_SRC swift
  expression.init(initializer arguments)
#+END_SRC   

You use the initializer expression in a function call expression to
initialize a new instance of a type. You also use an initializer
expression to delegate to the initializer of a superclass.

#+BEGIN_SRC swift
  class SomeSubClass: SomeSuperClass {
      override init() {
          // subclass initialization goes here
          super.init()
      }
  }
#+END_SRC   

Like a function, an initializer can be used as a value. For example:

#+BEGIN_SRC swift
  // Type annotation is required because String has multiple initializers.
  let initializer: (Int) -> String = String.init
  let oneTwoThree = [1, 2, 3].map(initializer).reduce("", +)
  print(oneTwoThree)
  // Prints "123"
#+END_SRC
   
If you specify a type by name, you can access the type's initializer
without using an initializer expression. In all other cases, you must
use an initializer expression.

#+BEGIN_SRC swift
  let s1 = SomeType.init(data: 3) // Valid
  let s2 = SomeType(data: 1) // Also valid

  let s3 = type(of: someValue).init(data: 7) // Valid
  let s4 = type(of: someValue)(data: 5) // Error
#+END_SRC   

Grammar of an initializer expression

initializer-expression
→
postfix-expression
=.= =init=

initializer-expression
→
postfix-expression
=.= =init= =(=
argument-names
=)=


*** Explicit Member Expression

An /explicit member expression/ allows access to the members of a named
type, a tuple, or a module. It consists of a period (=.=) between the
item and the identifier of its member.

#+BEGIN_SRC swift
  expression.member name
#+END_SRC   

The members of a named type are named as part of the type's declaration
or extension. For example:

#+BEGIN_SRC swift
  class SomeClass {
      var someProperty = 42
  }
  let c = SomeClass()
  let y = c.someProperty // Member access
#+END_SRC   

The members of a tuple are implicitly named using integers in the order
they appear, starting from zero. For example:

#+BEGIN_SRC swift
  var t = (10, 20, 30)
  t.0 = t.1
  // Now t is (20, 20, 30)
#+END_SRC   

The members of a module access the top-level declarations of that
module.

Types declared with the =dynamicMemberLookup= attribute include members
that are looked up at runtime, as described in
[[Attributes][Attributes]].

To distinguish between methods or initializers whose names differ only
by the names of their arguments, include the argument names in
parentheses, with each argument name followed by a colon (=:=). Write an
underscore (=_=) for an argument with no name. To distinguish between
overloaded methods, use a type annotation. For example:

#+BEGIN_SRC swift
  class SomeClass {
      func someMethod(x: Int, y: Int) {}
      func someMethod(x: Int, z: Int) {}
      func overloadedMethod(x: Int, y: Int) {}
      func overloadedMethod(x: Int, y: Bool) {}
  }
  let instance = SomeClass()

  let a = instance.someMethod // Ambiguous
  let b = instance.someMethod(x:y:) // Unambiguous

  let d = instance.overloadedMethod // Ambiguous
  let d = instance.overloadedMethod(x:y:) // Still ambiguous
  let d: (Int, Bool) -> Void = instance.overloadedMethod(x:y:) // Unambiguous
#+END_SRC    

If a period appears at the beginning of a line, it's understood as part
of an explicit member expression, not as an implicit member expression.
For example, the following listing shows chained method calls split over
several lines:

#+BEGIN_SRC swift
  let x = [10, 3, 20, 15, 4]
    .sorted()
    .filter { $0 > 5 }
    .map { $0 * 100 }
#+END_SRC   

Grammar of an explicit member expression

explicit-member-expression
→
postfix-expression
=.=
decimal-digits

explicit-member-expression
→
postfix-expression
=.=
identifier
generic-argument-clause
_{opt}

explicit-member-expression
→
postfix-expression
=.=
identifier
=(=
argument-names
=)=

argument-names →
argument-name
argument-names
_{opt}

argument-name →
identifier
=:=


*** Postfix Self Expression

A postfix =self= expression consists of an expression or the name of a
type, immediately followed by =.self=. It has the following forms:

#+BEGIN_SRC swift
  expression.self
  type.self
#+END_SRC   

The first form evaluates to the value of the /expression/. For example,
=x.self= evaluates to =x=.

The second form evaluates to the value of the /type/. Use this form to
access a type as a value. For example, because =SomeClass.self=
evaluates to the =SomeClass= type itself, you can pass it to a function
or method that accepts a type-level argument.

Grammar of a postfix self expression

postfix-self-expression
→
postfix-expression
=.= =self=


*** Subscript Expression

A /subscript expression/ provides subscript access using the getter and
setter of the corresponding subscript declaration. It has the following
form:

#+BEGIN_SRC swift
  expression[index expressions]
#+END_SRC   

To evaluate the value of a subscript expression, the subscript getter
for the /expression/'s type is called with the /index expressions/
passed as the subscript parameters. To set its value, the subscript
setter is called in the same way.

For information about subscript declarations, see
[[Protocol Subscript Declaration][Protocol Subscript Declaration]]X.

Grammar of a subscript expression

subscript-expression →
postfix-expression
=[=
function-call-argument-list
=]=


*** Forced-Value Expression

A /forced-value expression/ unwraps an optional value that you are
certain isn't =nil=. It has the following form:

#+BEGIN_SRC swift
  expression!
#+END_SRC   

If the value of the /expression/ isn't =nil=, the optional value is
unwrapped and returned with the corresponding non-optional type.
Otherwise, a runtime error is raised.

The unwrapped value of a forced-value expression can be modified, either
by mutating the value itself, or by assigning to one of the value's
members. For example:

#+BEGIN_SRC swift
  var x: Int? = 0
  x! += 1
  // x is now 1

  var someDictionary = ["a": [1, 2, 3], "b": [10, 20]]
  someDictionary["a"]![0] = 100
  // someDictionary is now ["a": [100, 2, 3], "b": [10, 20]]
#+END_SRC   

Grammar of a forced-value expression

forced-value-expression
→
postfix-expression
=!=


*** Optional-Chaining Expression

An /optional-chaining expression/ provides a simplified syntax for using
optional values in postfix expressions. It has the following form:

#+BEGIN_SRC swift
  expression?
#+END_SRC   

The postfix =?= operator makes an optional-chaining expression from an
expression without changing the expression's value.

Optional-chaining expressions must appear within a postfix expression,
and they cause the postfix expression to be evaluated in a special way.
If the value of the optional-chaining expression is =nil=, all of the
other operations in the postfix expression are ignored and the entire
postfix expression evaluates to =nil=. If the value of the
optional-chaining expression isn't =nil=, the value of the
optional-chaining expression is unwrapped and used to evaluate the rest
of the postfix expression. In either case, the value of the postfix
expression is still of an optional type.

If a postfix expression that contains an optional-chaining expression is
nested inside other postfix expressions, only the outermost expression
returns an optional type. In the example below, when =c= isn't =nil=,
its value is unwrapped and used to evaluate =.property=, the value of
which is used to evaluate =.performAction()=. The entire expression
=c?.property.performAction()= has a value of an optional type.

#+BEGIN_SRC swift
  var c: SomeClass?
  var result: Bool? = c?.property.performAction()
#+END_SRC   

The following example shows the behavior of the example above without
using optional chaining.

#+BEGIN_SRC swift
  var result: Bool?
  if let unwrappedC = c {
      result = unwrappedC.property.performAction()
  }
#+END_SRC   

The unwrapped value of an optional-chaining expression can be modified,
either by mutating the value itself, or by assigning to one of the
value's members. If the value of the optional-chaining expression is
=nil=, the expression on the right-hand side of the assignment operator
isn't evaluated. For example:

#+BEGIN_SRC swift
  func someFunctionWithSideEffects() -> Int {
      return 42 // No actual side effects.
  }
  var someDictionary = ["a": [1, 2, 3], "b": [10, 20]]

  someDictionary["not here"]?[0] = someFunctionWithSideEffects()
  // someFunctionWithSideEffects isn't evaluated
  // someDictionary is still ["a": [1, 2, 3], "b": [10, 20]]

  someDictionary["a"]?[0] = someFunctionWithSideEffects()
  // someFunctionWithSideEffects is evaluated and returns 42
  // someDictionary is now ["a": [42, 2, 3], "b": [10, 20]]
#+END_SRC    

Grammar of an optional-chaining expression

optional-chaining-expression
→
postfix-expression
=?=

* Statements

In Swift, there are three kinds of statements: simple statements,
compiler control statements, and control flow statements. Simple
statements are the most common and consist of either an expression or a
declaration. Compiler control statements allow the program to change
aspects of the compiler's behavior and include a conditional compilation
block and a line control statement.

Control flow statements are used to control the flow of execution in a
program. There are several types of control flow statements in Swift,
including loop statements, branch statements, and control transfer
statements. Loop statements allow a block of code to be executed
repeatedly, branch statements allow a certain block of code to be
executed only when certain conditions are met, and control transfer
statements provide a way to alter the order in which code is executed.
In addition, Swift provides a =do= statement to introduce scope, and
catch and handle errors, and a =defer= statement for running cleanup
actions just before the current scope exits.

A semicolon (=;=) can optionally appear after any statement and is used
to separate multiple statements if they appear on the same line.

Grammar of a statement

statement →
expression
=;=_{opt}

statement →
declaration
=;=_{opt}

statement →
loop-statement
=;=_{opt}

statement →
branch-statement
=;=_{opt}

statement →
labeled-statement
=;=_{opt}

statement →
control-transfer-statement
=;=_{opt}

statement →
defer-statement
=;=_{opt}

statement →
do-statement
=;=_{opt}

statement →
compiler-control-statement

statements →
statement
statements
_{opt}


** Loop Statements

Loop statements allow a block of code to be executed repeatedly,
depending on the conditions specified in the loop. Swift has three loop
statements: a =for=-=in= statement, a =while= statement, and a
=repeat=-=while= statement.

Control flow in a loop statement can be changed by a =break= statement
and a =continue= statement and is discussed in
[[Break Statement][Break Statement]] and
[[Continue Statement][Continue Statement]] below.

Grammar of a loop statement

loop-statement →
for-in-statement

loop-statement →
while-statement

loop-statement →
repeat-while-statement


*** For-In Statement

A =for=-=in= statement allows a block of code to be executed once for
each item in a collection (or any type) that conforms to the
[[https://developer.apple.com/documentation/swift/sequence][=Sequence=]]
[https://developer.apple.com/documentation/swift/sequence] protocol.

A =for=-=in= statement has the following form:

#+BEGIN_SRC swift
  for item in collection {
      statements
  }
#+END_SRC   

The =makeIterator()= method is called on the /collection/ expression to
obtain a value of an iterator type---that is, a type that conforms to
the
[[https://developer.apple.com/documentation/swift/iteratorprotocol][=IteratorProtocol=]]
[https://developer.apple.com/documentation/swift/iteratorprotocol]
protocol. The program begins executing a loop by calling the =next()=
method on the iterator. If the value returned isn't =nil=, it's assigned
to the /item/ pattern, the program executes the /statements/, and then
continues execution at the beginning of the loop. Otherwise, the program
doesn't perform assignment or execute the /statements/, and it's
finished executing the =for=-=in= statement.

Grammar of a for-in statement

for-in-statement → =for=
=case=_{opt}
pattern =in=
expression
where-clause
_{opt}
code-block


*** While Statement

A =while= statement allows a block of code to be executed repeatedly, as
long as a condition remains true.

A =while= statement has the following form:

#+BEGIN_SRC swift
  while condition {
      statements
  }
#+END_SRC   

A =while= statement is executed as follows:

1. The /condition/ is evaluated.

   If =true=, execution continues to step 2. If =false=, the program is
   finished executing the =while= statement.

2. The program executes the /statements/, and execution returns to step
   1.

Because the value of the /condition/ is evaluated before the
/statements/ are executed, the /statements/ in a =while= statement can
be executed zero or more times.

The value of the /condition/ must be of type =Bool= or a type bridged to
=Bool=. The condition can also be an optional binding declaration, as
discussed in [[info:swift#Optional Binding][Optional
Binding]].

Grammar of a while statement

while-statement → =while=
condition-list
code-block

condition-list →
condition |
condition =,=
condition-list

condition →
expression
|
availability-condition
|
case-condition
|
optional-binding-condition

case-condition → =case=
pattern
initializer

optional-binding-condition
→ =let= pattern
initializer
| =var= pattern
initializer


*** Repeat-While Statement

A =repeat=-=while= statement allows a block of code to be executed one
or more times, as long as a condition remains true.

A =repeat=-=while= statement has the following form:

#+BEGIN_SRC swift
  repeat {
      statements
  } while condition
#+END_SRC   

A =repeat=-=while= statement is executed as follows:

1. The program executes the /statements/, and execution continues to
   step 2.

2. The /condition/ is evaluated.

   If =true=, execution returns to step 1. If =false=, the program is
   finished executing the =repeat=-=while= statement.

Because the value of the /condition/ is evaluated after the /statements/
are executed, the /statements/ in a =repeat=-=while= statement are
executed at least once.

The value of the /condition/ must be of type =Bool= or a type bridged to
=Bool=. The condition can also be an optional binding declaration, as
discussed in [[info:swift#Optional Binding][Optional
Binding]].

Grammar of a repeat-while statement

repeat-while-statement
→ =repeat=
code-block
=while=
expression


*** Branch Statements

Branch statements allow the program to execute certain parts of code
depending on the value of one or more conditions. The values of the
conditions specified in a branch statement control how the program
branches and, therefore, what block of code is executed. Swift has three
branch statements: an =if= statement, a =guard= statement, and a
=switch= statement.

Control flow in an =if= statement or a =switch= statement can be changed
by a =break= statement and is discussed in
[[Break Statement][Break Statement]] below.

Grammar of a branch statement

branch-statement →
if-statement

branch-statement →
guard-statement

branch-statement →
switch-statement


*** If Statement

An =if= statement is used for executing code based on the evaluation of
one or more conditions.

There are two basic forms of an =if= statement. In each form, the
opening and closing braces are required.

The first form allows code to be executed only when a condition is true
and has the following form:

#+BEGIN_SRC swift
  if condition {
      statements
  }
#+END_SRC   

The second form of an =if= statement provides an additional /else
clause/ (introduced by the =else= keyword) and is used for executing one
part of code when the condition is true and another part of code when
the same condition is false. When a single else clause is present, an
=if= statement has the following form:

#+BEGIN_SRC swift
  if condition {
      statements to execute if condition is true
  } else {
      statements to execute if condition is false
  }
#+END_SRC   

The else clause of an =if= statement can contain another =if= statement
to test more than one condition. An =if= statement chained together in
this way has the following form:

#+BEGIN_SRC swift
  if condition 1 {
      statements to execute if condition 1 is true
  } else if condition 2 {
      statements to execute if condition 2 is true
  } else {
      statements to execute if both conditions are false
  }
#+END_SRC   

The value of any condition in an =if= statement must be of type =Bool=
or a type bridged to =Bool=. The condition can also be an optional
binding declaration, as discussed in
[[info:swift#Optional Binding][Optional Binding]].

Grammar of an if statement

if-statement → =if=
condition-list
code-block
else-clause
_{opt}

else-clause → =else=
code-block
| =else=
if-statement


*** Guard Statement

A =guard= statement is used to transfer program control out of a scope
if one or more conditions aren't met.

A =guard= statement has the following form:

#+BEGIN_SRC swift
  guard condition else {
      statements
  }
#+END_SRC   

The value of any condition in a =guard= statement must be of type =Bool=
or a type bridged to =Bool=. The condition can also be an optional
binding declaration, as discussed in
[[info:swift#Optional Binding][Optional Binding]].

Any constants or variables assigned a value from an optional binding
declaration in a =guard= statement condition can be used for the rest of
the guard statement's enclosing scope.

The =else= clause of a =guard= statement is required, and must either
call a function with the =Never= return type or transfer program control
outside the guard statement's enclosing scope using one of the following
statements:

- =return=

- =break=

- =continue=

- =throw=

Control transfer statements are discussed in
[[Control Transfer Statements][Control Transfer Statements]] below. For more
information on functions with the =Never= return type, see
[[Functions that Never Return][Functions that Never Return]].

Grammar of a guard statement

guard-statement → =guard=
condition-list
=else=
code-block


**** Switch Statement

A =switch= statement allows certain blocks of code to be executed
depending on the value of a control expression.

A =switch= statement has the following form:

#+BEGIN_SRC swift
  switch control expression {
  case pattern 1:
      statements
  case pattern 2 where condition:
      statements
  case pattern 3 where condition,
       pattern 4 where condition:
      statements
  default:
      statements
  }
#+END_SRC    

The /control expression/ of the =switch= statement is evaluated and then
compared with the patterns specified in each case. If a match is found,
the program executes the /statements/ listed within the scope of that
case. The scope of each case can't be empty. As a result, you must
include at least one statement following the colon (=:=) of each case
label. Use a single =break= statement if you don't intend to execute any
code in the body of a matched case.

The values of expressions your code can branch on are very flexible. For
example, in addition to the values of scalar types, such as integers and
characters, your code can branch on the values of any type, including
floating-point numbers, strings, tuples, instances of custom classes,
and optionals. The value of the /control expression/ can even be matched
to the value of a case in an enumeration and checked for inclusion in a
specified range of values. For examples of how to use these various
types of values in =switch= statements, see
[[info:swift#Switch][Switch]] in
[[info:swift#Control Flow][Control Flow]].

A =switch= case can optionally contain a =where= clause after each
pattern. A /where clause/ is introduced by the =where= keyword followed
by an expression, and is used to provide an additional condition before
a pattern in a case is considered matched to the /control expression/.
If a =where= clause is present, the /statements/ within the relevant
case are executed only if the value of the /control expression/ matches
one of the patterns of the case and the expression of the =where= clause
evaluates to =true=. For example, a /control expression/ matches the
case in the example below only if it's a tuple that contains two
elements of the same value, such as =(1, 1)=.

#+BEGIN_SRC swift
  case let (x, y) where x == y:
#+END_SRC   

As the above example shows, patterns in a case can also bind constants
using the =let= keyword (they can also bind variables using the =var=
keyword). These constants (or variables) can then be referenced in a
corresponding =where= clause and throughout the rest of the code within
the scope of the case. If the case contains multiple patterns that match
the control expression, all of the patterns must contain the same
constant or variable bindings, and each bound variable or constant must
have the same type in all of the case's patterns.

A =switch= statement can also include a default case, introduced by the
=default= keyword. The code within a default case is executed only if no
other cases match the control expression. A =switch= statement can
include only one default case, which must appear at the end of the
=switch= statement.

Although the actual execution order of pattern-matching operations, and
in particular the evaluation order of patterns in cases, is unspecified,
pattern matching in a =switch= statement behaves as if the evaluation is
performed in source order---that is, the order in which they appear in
source code. As a result, if multiple cases contain patterns that
evaluate to the same value, and thus can match the value of the control
expression, the program executes only the code within the first matching
case in source order.


**** Switch Statements Must Be Exhaustive

In Swift, every possible value of the control expression's type must
match the value of at least one pattern of a case. When this simply
isn't feasible (for example, when the control expression's type is
=Int=), you can include a default case to satisfy the requirement.


***** Switching Over Future Enumeration Cases

#+FINDEX: @@unknown

A /nonfrozen enumeration/ is a special kind of enumeration that may gain
new enumeration cases in the future---even after you compile and ship an
app. Switching over a nonfrozen enumeration requires extra
consideration. When a library's authors mark an enumeration as
nonfrozen, they reserve the right to add new enumeration cases, and any
code that interacts with that enumeration /must/ be able to handle those
future cases without being recompiled. Code that's compiled in library
evolution mode, code in the standard library, Swift overlays for Apple
frameworks, and C and Objective-C code can declare nonfrozen
enumerations. For information about frozen and nonfrozen enumerations,
see [[frozen][frozen]].

When switching over a nonfrozen enumeration value, you always need to
include a default case, even if every case of the enumeration already
has a corresponding switch case. You can apply the =@unknown= attribute
to the default case, which indicates that the default case should match
only enumeration cases that are added in the future. Swift produces a
warning if the default case matches any enumeration case that's known
at compiler time. This future warning informs you that the library
author added a new case to the enumeration that doesn't have a
corresponding switch case.

The following example switches over all three existing cases of the
standard library's
[[https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation][=Mirror.AncestorRepresentation=]]
[https://developer.apple.com/documentation/swift/mirror/ancestorrepresentation]
enumeration. If you add additional cases in the future, the compiler
generates a warning to indicate that you need to update the switch
statement to take the new cases into account.

#+BEGIN_SRC swift
  let representation: Mirror.AncestorRepresentation = .generated
  switch representation {
  case .customized:
      print("Use the nearest ancestor's implementation.")
  case .generated:
      print("Generate a default mirror for all ancestor classes.")
  case .suppressed:
      print("Suppress the representation of all ancestor classes.")
  @unknown default:
      print("Use a representation that was unknown when this code was compiled.")
  }
  // Prints "Generate a default mirror for all ancestor classes."
#+END_SRC


**** Execution Does Not Fall Through Cases Implicitly

After the code within a matched case has finished executing, the program
exits from the =switch= statement. Program execution doesn't continue or
“fall through” to the next case or default case. That said, if you want
execution to continue from one case to the next, explicitly include a
=fallthrough= statement, which simply consists of the =fallthrough=
keyword, in the case from which you want execution to continue. For more
information about the =fallthrough= statement, see
[[Fallthrough Statement][Fallthrough Statement]] below.

Grammar of a switch statement

switch-statement → =switch=
expression
={=
switch-cases
_{opt} =}=

switch-cases →
switch-case
switch-cases
_{opt}

switch-case →
case-label
statements

switch-case →
default-label
statements

switch-case →
conditional-switch-case

case-label →
attributes
_{opt} =case=
case-item-list
=:=

case-item-list →
pattern
where-clause
_{opt} | pattern
where-clause
_{opt} =,=
case-item-list

default-label →
attributes
_{opt} =default= =:=

where-clause → =where=
where-expression

where-expression →
expression

conditional-switch-case
→
switch-if-directive-clause
switch-elseif-directive-clauses
_{opt}
switch-else-directive-clause
_{opt}
endif-directive

switch-if-directive-clause
→
if-directive
compilation-condition
switch-cases
_{opt}

switch-elseif-directive-clauses
→
elseif-directive-clause
switch-elseif-directive-clauses
_{opt}

switch-elseif-directive-clause
→
elseif-directive
compilation-condition
switch-cases
_{opt}

switch-else-directive-clause
→
else-directive
switch-cases
_{opt}


** Labeled Statement

You can prefix a loop statement, an =if= statement, a =switch=
statement, or a =do= statement with a /statement label/, which consists
of the name of the label followed immediately by a colon (:). Use
statement labels with =break= and =continue= statements to be explicit
about how you want to change control flow in a loop statement or a
=switch= statement, as discussed in [[Break Statement][Break
Statement]] and [[Continue Statement][Continue Statement]] below.

The scope of a labeled statement is the entire statement following the
statement label. You can nest labeled statements, but the name of each
statement label must be unique.

For more information and to see examples of how to use statement labels,
see [[info:swift#Labeled Statements][Labeled Statements]] in
[[info:swift#Control Flow][Control Flow]].

Grammar of a labeled statement

labeled-statement →
statement-label
loop-statement

labeled-statement →
statement-label
if-statement

labeled-statement →
statement-label
switch-statement

labeled-statement →
statement-label
do-statement

statement-label →
label-name
=:=

label-name →
identifier


** Control Transfer Statements

Control transfer statements can change the order in which code in your
program is executed by unconditionally transferring program control from
one piece of code to another. Swift has five control transfer
statements: a =break= statement, a =continue= statement, a =fallthrough=
statement, a =return= statement, and a =throw= statement.

Grammar of a control transfer statement

control-transfer-statement
→
break-statement

control-transfer-statement
→
continue-statement

control-transfer-statement
→
fallthrough-statement

control-transfer-statement
→
return-statement

control-transfer-statement
→
throw-statement


*** Break Statement

A =break= statement ends program execution of a loop, an =if= statement,
or a =switch= statement. A =break= statement can consist of only the
=break= keyword, or it can consist of the =break= keyword followed by
the name of a statement label, as shown below.

#+BEGIN_SRC swift
  break
  break label name
#+END_SRC   

When a =break= statement is followed by the name of a statement label,
it ends program execution of the loop, =if= statement, or =switch=
statement named by that label.

When a =break= statement isn't followed by the name of a statement
label, it ends program execution of the =switch= statement or the
innermost enclosing loop statement in which it occurs. You can't use an
unlabeled =break= statement to break out of an =if= statement.

In both cases, program control is then transferred to the first line of
code following the enclosing loop or =switch= statement, if any.

For examples of how to use a =break= statement, see
[[info:swift#Break][Break]] and
[[info:swift#Labeled Statements][Labeled Statements]] in
[[info:swift#Control Flow][Control Flow]].

Grammar of a break statement

break-statement → =break=
label-name
_{opt}


*** Continue Statement

A =continue= statement ends program execution of the current iteration
of a loop statement but doesn't stop execution of the loop statement. A
=continue= statement can consist of only the =continue= keyword, or it
can consist of the =continue= keyword followed by the name of a
statement label, as shown below.

#+BEGIN_SRC swift
  continue
  continue label name
#+END_SRC   

When a =continue= statement is followed by the name of a statement
label, it ends program execution of the current iteration of the loop
statement named by that label.

When a =continue= statement isn't followed by the name of a statement
label, it ends program execution of the current iteration of the
innermost enclosing loop statement in which it occurs.

In both cases, program control is then transferred to the condition of
the enclosing loop statement.

In a =for= statement, the increment expression is still evaluated after
the =continue= statement is executed, because the increment expression
is evaluated after the execution of the loop's body.

For examples of how to use a =continue= statement, see
[[info:swift#Continue][Continue]] and
[[info:swift#Labeled Statements][Labeled Statements]] in
[[info:swift#Control Flow][Control Flow]].

Grammar of a continue statement

continue-statement →
=continue=
label-name
_{opt}


*** Fallthrough Statement

A =fallthrough= statement consists of the =fallthrough= keyword and
occurs only in a case block of a =switch= statement. A =fallthrough=
statement causes program execution to continue from one case in a
=switch= statement to the next case. Program execution continues to the
next case even if the patterns of the case label don't match the value
of the =switch= statement's control expression.

A =fallthrough= statement can appear anywhere inside a =switch=
statement, not just as the last statement of a case block, but it can't
be used in the final case block. It also can't transfer control into a
case block whose pattern contains value binding patterns.

For an example of how to use a =fallthrough= statement in a =switch=
statement, see [[Control Transfer Statements][Control
Transfer Statements]] in [[info:swift#Control Flow][Control
Flow]].

Grammar of a fallthrough statement

fallthrough-statement
→ =fallthrough=


*** Return Statement

A =return= statement occurs in the body of a function or method
definition and causes program execution to return to the calling
function or method. Program execution continues at the point immediately
following the function or method call.

A =return= statement can consist of only the =return= keyword, or it can
consist of the =return= keyword followed by an expression, as shown
below.

#+BEGIN_SRC swift
  return
  return expression
#+END_SRC   

When a =return= statement is followed by an expression, the value of the
expression is returned to the calling function or method. If the value
of the expression doesn't match the value of the return type declared
in the function or method declaration, the expression's value is
converted to the return type before it's returned to the calling
function or method.

Note

As described in [[Failable Initializers][Failable Initializers]], a
special form of the =return= statement (=return nil=) can be used in a
failable initializer to indicate initialization failure.

When a =return= statement isn't followed by an expression, it can be
used only to return from a function or method that doesn't return a
value (that is, when the return type of the function or method is =Void=
or =()=).

Grammar of a return statement

return-statement → =return=
expression
_{opt}


*** Throw Statement

A =throw= statement occurs in the body of a throwing function or method,
or in the body of a closure expression whose type is marked with the
=throws= keyword.

A =throw= statement causes a program to end execution of the current
scope and begin error propagation to its enclosing scope. The error
that's thrown continues to propagate until it's handled by a =catch=
clause of a =do= statement.

A =throw= statement consists of the =throw= keyword followed by an
expression, as shown below.

#+BEGIN_SRC swift
  throw expression
#+END_SRC   

The value of the /expression/ must have a type that conforms to the
=Error= protocol.

For an example of how to use a =throw= statement, see
[[info:swift#Propagating Errors Using Throwing Functions][Propagating Errors Using
Throwing Functions]] in [[info:swift#Error Handling][Error
Handling]].

Grammar of a throw statement

throw-statement → =throw=
expression


** Defer Statement

A =defer= statement is used for executing code just before transferring
program control outside of the scope that the =defer= statement appears
in.

A =defer= statement has the following form:

#+BEGIN_SRC swift
  defer {
      statements
  }
#+END_SRC   

The statements within the =defer= statement are executed no matter how
program control is transferred. This means that a =defer= statement can
be used, for example, to perform manual resource management such as
closing file descriptors, and to perform actions that need to happen
even if an error is thrown.

If multiple =defer= statements appear in the same scope, the order they
appear is the reverse of the order they're executed. Executing the last
=defer= statement in a given scope first means that statements inside
that last =defer= statement can refer to resources that will be cleaned
up by other =defer= statements.

#+BEGIN_SRC swift
  func f() {
      defer { print("First defer") }
      defer { print("Second defer") }
      print("End of function")
  }
  f()
  // Prints "End of function"
  // Prints "Second defer"
  // Prints "First defer"
#+END_SRC   

The statements in the =defer= statement can't transfer program control
outside of the =defer= statement.

Grammar of a defer statement

defer-statement → =defer=
code-block


** Do Statement

The =do= statement is used to introduce a new scope and can optionally
contain one or more =catch= clauses, which contain patterns that match
against defined error conditions. Variables and constants declared in
the scope of a =do= statement can be accessed only within that scope.

A =do= statement in Swift is similar to curly braces (={}=) in C used to
delimit a code block, and doesn't incur a performance cost at runtime.

A =do= statement has the following form:

#+BEGIN_SRC swift
  do {
      try expression
      statements
  } catch pattern 1 {
      statements
  } catch pattern 2 where condition {
      statements
  } catch pattern 3, pattern 4 where condition {
      statements
  } catch {
      statements
  }
#+END_SRC    

If any statement in the =do= code block throws an error, program control
is transferred to the first =catch= clause whose pattern matches the
error. If none of the clauses match, the error propagates to the
surrounding scope. If an error is unhandled at the top level, program
execution stops with a runtime error.

Like a =switch= statement, the compiler attempts to infer whether
=catch= clauses are exhaustive. If such a determination can be made, the
error is considered handled. Otherwise, the error can propagate out of
the containing scope, which means the error must be handled by an
enclosing =catch= clause or the containing function must be declared
with =throws=.

#+CINDEX: catching multiple error patterns

A =catch= clause that has multiple patterns matches the error if any of
its patterns match the error. If a =catch= clause contains multiple
patterns, all of the patterns must contain the same constant or variable
bindings, and each bound variable or constant must have the same type in
all of the =catch= clause's patterns.

To ensure that an error is handled, use a =catch= clause with a pattern
that matches all errors, such as a wildcard pattern (=_=). If a =catch=
clause doesn't specify a pattern, the =catch= clause matches and binds
any error to a local constant named =error=. For more information about
the patterns you can use in a =catch= clause, see
[[Patterns][Patterns]].

To see an example of how to use a =do= statement with several =catch=
clauses, see [[info:swift#Handling Errors][Handling
Errors]].

Grammar of a do statement

do-statement → =do=
code-block
catch-clauses
_{opt}

catch-clauses →
catch-clause
catch-clauses
_{opt}

catch-clause → =catch=
catch-pattern-list
_{opt}
code-block

catch-pattern-list →
catch-pattern
|
catch-pattern
=,=
catch-pattern-list

catch-pattern →
pattern
where-clause
_{opt}

** Compiler Control Statements

Compiler control statements allow the program to change aspects of the
compiler's behavior. Swift has three compiler control statements: a
conditional compilation block a line control statement, and a
compile-time diagnostic statement.

Grammar of a compiler control statement

compiler-control-statement
→
conditional-compilation-block

compiler-control-statement
→
line-control-statement

compiler-control-statement
→
diagnostic-statement


*** Conditional Compilation Block

[[https://github.com/apple/swift-evolution/blob/master/proposals/0020-if-swift-version.md][Proposal]]

A conditional compilation block allows code to be conditionally compiled
depending on the value of one or more compilation conditions.

#+FINDEX: #if

Every conditional compilation block begins with the =#if= compilation
directive and ends with the =#endif= compilation directive. A simple
conditional compilation block has the following form:

#+BEGIN_SRC swift
  #if compilation condition
  statements
  #endif
#+END_SRC   

Unlike the condition of an =if= statement, the /compilation condition/
is evaluated at compile time. As a result, the /statements/ are compiled
and executed only if the /compilation condition/ evaluates to =true= at
compile time.

The /compilation condition/ can include the =true= and =false= Boolean
literals, an identifier used with the =-D= command line flag, or any of
the platform conditions listed in the table below.

| Platform condition      | Valid arguments                              |
|-------------------------+----------------------------------------------|
| =os()=                  | =macOS=, =iOS=, =watchOS=, =tvOS=, =Linux=   |
| =arch()=                | =i386=, =x86_64=, =arm=, =arm64=             |
| =swift()=               | =>== or =<= followed by a version number     |
| =compiler()=            | =>== or =<= followed by a version number     |
| =canImport()=           | A module name                                |
| =targetEnvironment()=   | =simulator=, =macCatalyst=                   |

#+FINDEX: swift
#+FINDEX: compiler

The version number for the =swift()= and =compiler()= platform
conditions consists of a major number, optional minor number, optional
patch number, and so on, with a dot (=.=) separating each part of the
version number. There must not be whitespace between the comparison
operator and the version number. The version for =compiler()= is the
compiler version, regardless of the Swift version setting passed to the
compiler. The version for =swift()= is the language version currently
being compiled. For example, if you compile your code using the Swift 5
compiler in Swift 4.2 mode, the compiler version is 5 and the language
version is 4.2. With those settings, the following code prints all three
messages:

#+BEGIN_SRC swift
  #if compiler(>=5)
  print("Compiled with the Swift 5 compiler or later")
  #endif
  #if swift(>=4.2)
  print("Compiled in Swift 4.2 mode or later")
  #endif
  #if compiler(>=5) && swift(<5)
  print("Compiled with the Swift 5 compiler or later in a Swift mode
          earlier than 5")
  #endif
  // Prints "Compiled with the Swift 5 compiler or later"
  // Prints "Compiled in Swift 4.2 mode or later"
  // Prints "Compiled with the Swift 5 compiler or later in a Swift mode earlier than 5"
#+END_SRC    

#+FINDEX: canImport

The argument for the =canImport()= platform condition is the name of a
module that may not be present on all platforms. This condition tests
whether it's possible to import the module, but doesn't actually import
it. If the module is present, the platform condition returns =true=;
otherwise, it returns =false=.

#+FINDEX: targetEnvironment

The =targetEnvironment()= platform condition returns =true= when code is
being compiled for the specified environment; otherwise, it returns
=false=.

Note

#+FINDEX: arch

The =arch(arm)= platform condition doesn't return =true= for ARM 64
devices. The =arch(i386)= platform condition returns =true= when code is
compiled for the 32--bit iOS simulator.

You can combine and negate compilation conditions using the logical
operators =&&=, =||=, and =!= and use parentheses for grouping. These
operators have the same associativity and precedence as the logical
operators that are used to combine ordinary Boolean expressions.

Similar to an =if= statement, you can add multiple conditional branches
to test for different compilation conditions. You can add any number of
additional branches using =#elseif= clauses. You can also add a final
additional branch using an =#else= clause. Conditional compilation
blocks that contain multiple branches have the following form:

#+BEGIN_SRC swift
  #if compilation condition 1
  statements to compile if compilation condition 1 is true
  #elseif compilation condition 2
  statements to compile if compilation condition 2 is true
  #else
  statements to compile if both compilation conditions are false
  #endif
#+END_SRC   

Note

Each statement in the body of a conditional compilation block is parsed
even if it's not compiled. However, there's an exception if the
compilation condition includes a =swift()= or =compiler()= platform
condition: The statements are parsed only if the language or compiler
version matches what is specified in the platform condition. This
exception ensures that an older compiler doesn't attempt to parse syntax
introduced in a newer version of Swift.

Grammar of a conditional compilation block

conditional-compilation-block
→
if-directive-clause
elseif-directive-clauses
_{opt}
else-directive-clause
_{opt}
endif-directive

if-directive-clause →
if-directive
compilation-condition
statements
_{opt}

elseif-directive-clauses
→
elseif-directive-clause
elseif-directive-clauses
_{opt}

elseif-directive-clause
→
elseif-directive
compilation-condition
statements
_{opt}

else-directive-clause
→
else-directive
statements
_{opt}

if-directive → =#if=

elseif-directive →
=#elseif=

else-directive → =#else=

endif-directive → =#endif=

compilation-condition
→
platform-condition

compilation-condition
→
identifier

compilation-condition
→
boolean-literal

compilation-condition
→ =(=
compilation-condition
=)=

compilation-condition
→ =!=
compilation-condition

compilation-condition
→
compilation-condition
=&&=
compilation-condition

compilation-condition
→
compilation-condition
=||=
compilation-condition

platform-condition → =os=
=(=
operating-system
=)=

platform-condition →
=arch= =(=
architecture
=)=

platform-condition →
=swift= =(= =>==
swift-version
=)= | =swift= =(= =<=
swift-version
=)=

platform-condition →
=compiler= =(= =>==
swift-version
=)= | =compiler= =(= =<=
swift-version
=)=

platform-condition →
=canImport= =(=
module-name
=)=

platform-condition →
=targetEnvironment= =(=
environment
=)=

operating-system → =macOS=
| =iOS= | =watchOS= | =tvOS=

architecture → =i386= |
=x86_64= | =arm= | =arm64=

swift-version →
decimal-digits
swift-version-continuation
_{opt}

swift-version-continuation
→ =.=
decimal-digits
swift-version-continuation
_{opt}

module-name →
identifier

environment → =simulator= |
=macCatalyst=

*** Line Control Statement

A line control statement is used to specify a line number and filename
that can be different from the line number and filename of the source
code being compiled. Use a line control statement to change the source
code location used by Swift for diagnostic and debugging purposes.

#+FINDEX: #sourceLocation

A line control statement has the following forms:

#+BEGIN_SRC swift
  #sourceLocation(file: file path, line: line number)
  #sourceLocation()
#+END_SRC   

The first form of a line control statement changes the values of the
=#line=, =#file=, =#fileID=, and =#filePath= literal expressions,
beginning with the line of code following the line control statement.
The /line number/ changes the value of =#line=, and is any integer
literal greater than zero. The /file path/ changes the value of =#file=,
=#fileID=, and =#filePath=, and is a string literal. The specified
string becomes the value of =#filePath=, and the last path component of
the string is used by the value of =#fileID=. For information about
=#file=, =#fileID=, and =#filePath=, see
[[info:swift-reference#Literal Expression][Literal Expression]].

The second form of a line control statement, =#sourceLocation()=, resets
the source code location back to the default line numbering and file
path.

Grammar of a line control statement

line-control-statement
→ =#sourceLocation= =(= =file:=
file-name =,=
=line:=
line-number
=)=

line-control-statement
→ =#sourceLocation= =(= =)=

line-number → A decimal integer
greater than zero

file-name →
static-string-literal


*** Compile-Time Diagnostic Statement

A compile-time diagnostic statement causes the compiler to emit an error
or a warning during compilation. A compile-time diagnostic statement has
the following forms:

#+FINDEX: #error
#+FINDEX: #warning

#+BEGIN_SRC swift
  #error("error message")
  #warning("warning message")
#+END_SRC   

The first form emits the /error message/ as a fatal error and terminates
the compilation process. The second form emits the /warning message/ as
a nonfatal warning and allows compilation to proceed. You write the
diagnostic message as a static string literal. Static string literals
can't use features like string interpolation or concatenation, but they
can use the multiline string literal syntax.

Grammar of a compile-time diagnostic statement

diagnostic-statement →
=#error= =(=
diagnostic-message
=)=

diagnostic-statement
→ =#warning= =(=
diagnostic-message
=)=

diagnostic-message →
static-string-literal


** Availability Condition

An /availability condition/ is used as a condition of an =if=, =while=,
and =guard= statement to query the availability of APIs at runtime,
based on specified platforms arguments.

An availability condition has the following form:

#+BEGIN_SRC swift
  if #available(platform name version, ..., *) {
      statements to execute if the APIs are available
  } else {
      fallback statements to execute if the APIs are unavailable
  }
#+END_SRC   

You use an availability condition to execute a block of code, depending
on whether the APIs you want to use are available at runtime. The
compiler uses the information from the availability condition when it
verifies that the APIs in that block of code are available.

The availability condition takes a comma-separated list of platform
names and versions. Use =iOS=, =macOS=, =watchOS=, and =tvOS= for the
platform names, and include the corresponding version numbers. The =*=
argument is required and specifies that on any other platform, the body
of the code block guarded by the availability condition executes on the
minimum deployment target specified by your target.

Unlike Boolean conditions, you can't combine availability conditions
using logical operators such as =&&= and =||=.

Grammar of an availability condition

availability-condition
→ =#available= =(=
availability-arguments
=)=

availability-arguments
→
availability-argument
|
availability-argument
=,=
availability-arguments

availability-argument
→
platform-name
platform-version

availability-argument
→ =*=

platform-name → =iOS= |
=iOSApplicationExtension=

platform-name → =macOS= |
=macOSApplicationExtension=

platform-name → =watchOS=

platform-name → =tvOS=

platform-version →
decimal-digits

platform-version →
decimal-digits
=.=
decimal-digits

platform-version →
decimal-digits
=.=
decimal-digits
=.=
decimal-digits

* Declarations

A /declaration/ introduces a new name or construct into your program.
For example, you use declarations to introduce functions and methods, to
introduce variables and constants, and to define enumeration, structure,
class, and protocol types. You can also use a declaration to extend the
behavior of an existing named type and to import symbols into your
program that are declared elsewhere.

In Swift, most declarations are also definitions in the sense that
they're implemented or initialized at the same time they're declared.
That said, because protocols don't implement their members, most
protocol members are declarations only. For convenience and because the
distinction isn't that important in Swift, the term /declaration/ covers
both declarations and definitions.

Grammar of a declaration

declaration →
import-declaration

declaration →
constant-declaration

declaration →
variable-declaration

declaration →
typealias-declaration

declaration →
function-declaration

declaration →
enum-declaration

declaration →
struct-declaration

declaration →
class-declaration

declaration →
protocol-declaration

declaration →
initializer-declaration

declaration →
deinitializer-declaration

declaration →
extension-declaration

declaration →
subscript-declaration

declaration →
operator-declaration

declaration →
precedence-group-declaration

declarations →
declaration
declarations
_{opt}


** Top-Level Code

The top-level code in a Swift source file consists of zero or more
statements, declarations, and expressions. By default, variables,
constants, and other named declarations that are declared at the
top-level of a source file are accessible to code in every source file
that's part of the same module. You can override this default behavior
by marking the declaration with an access-level modifier, as described
in [[Access Control Levels][Access Control Levels]].

There are two kinds of top-level code: top-level declarations and
executable top-level code. Top-level declarations consist of only
declarations, and are allowed in all Swift source files. Executable
top-level code contains statements and expressions, not just
declarations, and is allowed only as the top-level entry point for the
program.

The Swift code you compile to make an executable can contain at most one
of the following approaches to mark the top-level entry point,
regardless of how the code is organized into files and modules: the
=main= attribute, the =NSApplicationMain= attribute, the
=UIApplicationMain= attribute, a =main.swift= file, or a file that
contains top-level executable code.

Grammar of a top-level declaration

top-level-declaration
→ statements
_{opt}


** Code Blocks

A /code block/ is used by a variety of declarations and control
structures to group statements together. It has the following form:

#+BEGIN_SRC swift
  {
      statements
  }
#+END_SRC   

The /statements/ inside a code block include declarations, expressions,
and other kinds of statements and are executed in order of their
appearance in source code.

Grammar of a code block

code-block → ={=
statements
_{opt} =}=


** Import Declaration

An /import declaration/ lets you access symbols that are declared
outside the current file. The basic form imports the entire module; it
consists of the =import= keyword followed by a module name:

#+BEGIN_SRC swift
  import module
#+END_SRC   

Providing more detail limits which symbols are imported---you can
specify a specific submodule or a specific declaration within a module
or submodule. When this detailed form is used, only the imported symbol
(and not the module that declares it) is made available in the current
scope.

#+BEGIN_SRC swift
  import import kind module.symbol name
  import module.submodule
#+END_SRC   

Grammar of an import declaration

import-declaration →
attributes
_{opt} =import=
import-kind
_{opt}
import-path

import-kind → =typealias= |
=struct= | =class= | =enum= | =protocol= | =let= | =var= | =func=

import-path →
import-path-identifier
|
import-path-identifier
=.=
import-path

import-path-identifier
→
identifier
|
operator


** Constant Declaration

A /constant declaration/ introduces a constant named value into your
program. Constant declarations are declared using the =let= keyword and
have the following form:

#+BEGIN_SRC swift
  let constant name: type = expression
#+END_SRC   

A constant declaration defines an immutable binding between the
/constant name/ and the value of the initializer /expression/; after the
value of a constant is set, it can't be changed. That said, if a
constant is initialized with a class object, the object itself can
change, but the binding between the constant name and the object it
refers to can't.

When a constant is declared at global scope, it must be initialized with
a value. When a constant declaration occurs in the context of a function
or method, it can be initialized later, as long as it's guaranteed to
have a value set before the first time its value is read. If the
compiler can prove that the constant's value is never read, the constant
isn't required to have a value set at all. When a constant declaration
occurs in the context of a class or structure declaration, it's
considered a /constant property/. Constant declarations aren't computed
properties and therefore don't have getters or setters.

If the /constant name/ of a constant declaration is a tuple pattern, the
name of each item in the tuple is bound to the corresponding value in
the initializer /expression/.

#+BEGIN_SRC swift
  let (firstNumber, secondNumber) = (10, 42)
#+END_SRC   

In this example, =firstNumber= is a named constant for the value =10=,
and =secondNumber= is a named constant for the value =42=. Both
constants can now be used independently:

#+BEGIN_SRC swift
  print("The first number is \(firstNumber).")
  // Prints "The first number is 10."
  print("The second number is \(secondNumber).")
  // Prints "The second number is 42."
#+END_SRC   

The type annotation (=:= /type/) is optional in a constant declaration
when the type of the /constant name/ can be inferred, as described in
[[Type Inference][Type Inference]].

To declare a constant type property, mark the declaration with the
=static= declaration modifier. A constant type property of a class is
always implicitly final; you can't mark it with the =class= or =final=
declaration modifier to allow or disallow overriding by subclasses. Type
properties are discussed in
[[info:swift#Type Properties][Type Properties]].

For more information about constants and for guidance about when to use
them, see [[info:swift#Constants and Variables][Constants and
Variables]] and [[info:swift#Stored Properties][Stored
Properties]].

Grammar of a constant declaration

constant-declaration
→ attributes
_{opt}
declaration-modifiers
_{opt} =let=
pattern-initializer-list

pattern-initializer-list
→
pattern-initializer
|
pattern-initializer
=,=
pattern-initializer-list

pattern-initializer →
pattern
initializer
_{opt}

initializer → ===
expression


** Variable Declaration

A /variable declaration/ introduces a variable named value into your
program and is declared using the =var= keyword.

Variable declarations have several forms that declare different kinds of
named, mutable values, including stored and computed variables and
properties, stored variable and property observers, and static variable
properties. The appropriate form to use depends on the scope at which
the variable is declared and the kind of variable you intend to declare.

Note

You can also declare properties in the context of a protocol
declaration, as described in [[Protocol Property Declaration][Protocol
Property Declaration]].

You can override a property in a subclass by marking the subclass's
property declaration with the =override= declaration modifier, as
described in [[info:swift#Overriding][Overriding]].


*** Stored Variables and Stored Variable Properties

The following form declares a stored variable or stored variable
property:

#+BEGIN_SRC swift
  var variable name: type = expression
#+END_SRC   

You define this form of a variable declaration at global scope, the
local scope of a function, or in the context of a class or structure
declaration. When a variable declaration of this form is declared at
global scope or the local scope of a function, it's referred to as a
/stored variable/. When it's declared in the context of a class or
structure declaration, it's referred to as a /stored variable
property/.

The initializer /expression/ can't be present in a protocol declaration,
but in all other contexts, the initializer /expression/ is optional.
That said, if no initializer /expression/ is present, the variable
declaration must include an explicit type annotation (=:= /type/).

As with constant declarations, if the /variable name/ is a tuple
pattern, the name of each item in the tuple is bound to the
corresponding value in the initializer /expression/.

As their names suggest, the value of a stored variable or a stored
variable property is stored in memory.


*** Computed Variables and Computed Properties

The following form declares a computed variable or computed property:

#+BEGIN_SRC swift
  var variable name: type {
      get {
          statements
      }
      set(setter name) {
          statements
      }
  }
#+END_SRC   

You define this form of a variable declaration at global scope, the
local scope of a function, or in the context of a class, structure,
enumeration, or extension declaration. When a variable declaration of
this form is declared at global scope or the local scope of a function,
it's referred to as a /computed variable/. When it's declared in the
context of a class, structure, or extension declaration, it's referred
to as a /computed property/.

The getter is used to read the value, and the setter is used to write
the value. The setter clause is optional, and when only a getter is
needed, you can omit both clauses and simply return the requested value
directly, as described in
[[info:swift#Read-Only Computed Properties][Read-Only Computed
Properties]]. But if you provide a setter clause, you must also provide
a getter clause.

The /setter name/ and enclosing parentheses is optional. If you provide
a setter name, it's used as the name of the parameter to the setter. If
you don't provide a setter name, the default parameter name to the
setter is =newValue=, as described in
[[info:swift#Shorthand Setter Declaration][Shorthand Setter
Declaration]].

Unlike stored named values and stored variable properties, the value of
a computed named value or a computed property isn't stored in memory.

For more information and to see examples of computed properties, see
[[info:swift#Computed Properties][Computed Properties]].


*** Stored Variable Observers and Property Observers

You can also declare a stored variable or property with =willSet= and
=didSet= observers. A stored variable or property declared with
observers has the following form:

#+BEGIN_SRC swift
  var variable name: type = expression {
      willSet(setter name) {
          statements
      }
      didSet(setter name) {
          statements
      }
  }
#+END_SRC
   
You define this form of a variable declaration at global scope, the
local scope of a function, or in the context of a class or structure
declaration. When a variable declaration of this form is declared at
global scope or the local scope of a function, the observers are
referred to as /stored variable observers/. When it's declared in the
context of a class or structure declaration, the observers are referred
to as /property observers/.

You can add property observers to any stored property. You can also add
property observers to any inherited property (whether stored or
computed) by overriding the property within a subclass, as described in
[[info:swift#Overriding Property Observers][Overriding Property
Observers]].

The initializer /expression/ is optional in the context of a class or
structure declaration, but required elsewhere. The /type/ annotation is
optional when the type can be inferred from the initializer
/expression/. This expression is evaluated the first time you read the
property's value. If you overwrite the property's initial value without
reading it, this expression is evaluated before the first time you write
to the property.

The =willSet= and =didSet= observers provide a way to observe (and to
respond appropriately) when the value of a variable or property is being
set. The observers aren't called when the variable or property is first
initialized. Instead, they're called only when the value is set outside
of an initialization context.

A =willSet= observer is called just before the value of the variable or
property is set. The new value is passed to the =willSet= observer as a
constant, and therefore it can't be changed in the implementation of the
=willSet= clause. The =didSet= observer is called immediately after the
new value is set. In contrast to the =willSet= observer, the old value
of the variable or property is passed to the =didSet= observer in case
you still need access to it. That said, if you assign a value to a
variable or property within its own =didSet= observer clause, that new
value that you assign will replace the one that was just set and passed
to the =willSet= observer.

The /setter name/ and enclosing parentheses in the =willSet= and
=didSet= clauses are optional. If you provide setter names, they're used
as the parameter names to the =willSet= and =didSet= observers. If you
don't provide setter names, the default parameter name to the =willSet=
observer is =newValue= and the default parameter name to the =didSet=
observer is =oldValue=.

The =didSet= clause is optional when you provide a =willSet= clause.
Likewise, the =willSet= clause is optional when you provide a =didSet=
clause.

#+CINDEX: order of execution of getters and property observers

If the body of the =didSet= observer refers to the old value, the getter
is called before the observer, to make the old value available.
Otherwise, the new value is stored without calling the superclass's
getter. The example below shows a computed property that's defined by
the superclass and overridden by its subclasses to add an observer.

#+BEGIN_SRC swift
  class Superclass {
      private var xValue = 12
      var x: Int {
          get { print("Getter was called"); return xValue }
          set { print("Setter was called"); xValue = newValue }
      }
  }

  // This subclass doesn't refer to oldValue in its observer, so the
  // superclass's getter is called only once to print the value.
  class New: Superclass {
      override var x: Int {
          didSet { print("New value \(x)") }
      }
  }
  let new = New()
  new.x = 100
  // Prints "Setter was called"
  // Prints "Getter was called"
  // Prints "New value 100"

  // This subclass refers to oldValue in its observer, so the superclass's
  // getter is called once before the setter, and again to print the value.
    class NewAndOld: Superclass {
        override var x: Int {
            didSet { print("Old value \(oldValue) - new value \(x)") }
        }
    }
  let newAndOld = NewAndOld()
  newAndOld.x = 200
  // Prints "Getter was called"
  // Prints "Setter was called"
  // Prints "Getter was called"
  // Prints "Old value 12 - new value 200"
#+END_SRC    

For more information and to see an example of how to use property
observers, see [[info:swift#Property Observers][Property
Observers]].


*** Type Variable Properties

To declare a type variable property, mark the declaration with the
=static= declaration modifier. Classes can mark type computed properties
with the =class= declaration modifier instead to allow subclasses to
override the superclass's implementation. Type properties are discussed
in [[info:swift#Type Properties][Type Properties]].

Grammar of a variable declaration

variable-declaration
→
variable-declaration-head
pattern-initializer-list

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
code-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-keyword-block

variable-declaration
→
variable-declaration-head
variable-name
initializer
willSet-didSet-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
initializer
_{opt}
willSet-didSet-block

variable-declaration-head
→ attributes
_{opt}
declaration-modifiers
_{opt} =var=

variable-name →
identifier

getter-setter-block →
code-block

getter-setter-block
→ ={=
getter-clause
setter-clause
_{opt} =}=

getter-setter-block
→ ={=
setter-clause
getter-clause
=}=

getter-clause →
attributes
_{opt}
mutation-modifier
_{opt} =get=
code-block

setter-clause →
attributes
_{opt}
mutation-modifier
_{opt} =set=
setter-name
_{opt}
code-block

setter-name → =(=
identifier
=)=

getter-setter-keyword-block
→ ={=
getter-keyword-clause
setter-keyword-clause
_{opt} =}=

getter-setter-keyword-block
→ ={=
setter-keyword-clause
getter-keyword-clause
=}=

getter-keyword-clause
→ attributes
_{opt}
mutation-modifier
_{opt} =get=

setter-keyword-clause
→ attributes
_{opt}
mutation-modifier
_{opt} =set=

willSet-didSet-block
→ ={=
willSet-clause
didSet-clause
_{opt} =}=

willSet-didSet-block
→ ={=
didSet-clause
willSet-clause
_{opt} =}=

willSet-clause →
attributes
_{opt} =willSet=
setter-name
_{opt}
code-block

didSet-clause →
attributes
_{opt} =didSet=
setter-name
_{opt}
code-block


** Type Alias Declaration

A /type alias declaration/ introduces a named alias of an existing type
into your program. Type alias declarations are declared using the
=typealias= keyword and have the following form:

#+BEGIN_SRC swift
  typealias name = existing type
#+END_SRC
   
After a type alias is declared, the aliased /name/ can be used instead
of the /existing type/ everywhere in your program. The /existing type/
can be a named type or a compound type. Type aliases don't create new
types; they simply allow a name to refer to an existing type.

A type alias declaration can use generic parameters to give a name to an
existing generic type. The type alias can provide concrete types for
some or all of the generic parameters of the existing type. For example:

#+BEGIN_SRC swift
  typealias StringDictionary<Value> = Dictionary<String, Value>

  // The following dictionaries have the same type.
  var dictionary1: StringDictionary<Int> = [:]
  var dictionary2: Dictionary<String, Int> = [:]
#+END_SRC   

When a type alias is declared with generic parameters, the constraints
on those parameters must match exactly the constraints on the existing
type's generic parameters. For example:

#+BEGIN_SRC swift
  typealias DictionaryOfInts<Key: Hashable> = Dictionary<Key, Int>
#+END_SRC   

Because the type alias and the existing type can be used
interchangeably, the type alias can't introduce additional generic
constraints.

A type alias can forward an existing type's generic parameters by
omitting all generic parameters from the declaration. For example, the
=Diccionario= type alias declared here has the same generic parameters
and constraints as =Dictionary=.

#+BEGIN_SRC swift
  typealias Diccionario = Dictionary
#+END_SRC   

Inside a protocol declaration, a type alias can give a shorter and more
convenient name to a type that's used frequently. For example:

#+BEGIN_SRC swift
  protocol Sequence {
      associatedtype Iterator: IteratorProtocol
      typealias Element = Iterator.Element
  }


  func sum<T: Sequence>(_ sequence: T) -> Int where T.Element == Int {
      // ...
  }
#+END_SRC   

Without this type alias, the =sum= function would have to refer to the
associated type as =T.Iterator.Element= instead of =T.Element=.

See also [[Protocol Associated Type Declaration][Protocol Associated Type
Declaration]].

Grammar of a type alias declaration

typealias-declaration
→ attributes
_{opt}
access-level-modifier
_{opt} =typealias=
typealias-name
generic-parameter-clause
_{opt}
typealias-assignment

typealias-name →
identifier

typealias-assignment
→ === type


** Function Declaration

A /function declaration/ introduces a function or method into your
program. A function declared in the context of class, structure,
enumeration, or protocol is referred to as a /method/. Function
declarations are declared using the =func= keyword and have the
following form:

#+BEGIN_SRC swift
  func function name(parameters) -> return type {
      statements
  }
#+END_SRC   

If the function has a return type of =Void=, the return type can be
omitted as follows:

#+BEGIN_SRC swift
  func function name(parameters) {
      statements
  }
#+END_SRC   

The type of each parameter must be included---it can't be inferred. If
you write =inout= in front of a parameter's type, the parameter can be
modified inside the scope of the function. In-out parameters are
discussed in detail in [[In-Out Parameters][In-Out Parameters]],
below.

A function declaration whose /statements/ include only a single
expression is understood to return the value of that expression. This
implicit return syntax is considered only when the expression's type and
the function's return type aren't =Void= and aren't an enumeration like
=Never= that doesn't have any cases.

Functions can return multiple values using a tuple type as the return
type of the function.

A function definition can appear inside another function declaration.
This kind of function is known as a /nested function/.

A nested function is nonescaping if it captures a value that's
guaranteed to never escape---such as an in-out parameter---or passed as
a nonescaping function argument. Otherwise, the nested function is an
escaping function.

For a discussion of nested functions, see
[[info:swift#Nested Functions][Nested Functions]].


*** Parameter Names

Function parameters are a comma-separated list where each parameter has
one of several forms. The order of arguments in a function call must
match the order of parameters in the function's declaration. The
simplest entry in a parameter list has the following form:

#+BEGIN_SRC swift
  parameter name: parameter type
#+END_SRC   

A parameter has a name, which is used within the function body, as well
as an argument label, which is used when calling the function or method.
By default, parameter names are also used as argument labels. For
example:

#+BEGIN_SRC swift
  func f(x: Int, y: Int) -> Int { return x + y }
  f(x: 1, y: 2) // both x and y are labeled
#+END_SRC   

You can override the default behavior for argument labels with one of
the following forms:

#+BEGIN_SRC swift
  argument label parameter name: parameter type
  _ parameter name: parameter type
#+END_SRC   

A name before the parameter name gives the parameter an explicit
argument label, which can be different from the parameter name. The
corresponding argument must use the given argument label in function or
method calls.

An underscore (=_=) before a parameter name suppresses the argument
label. The corresponding argument must have no label in function or
method calls.

#+BEGIN_SRC swift
  func repeatGreeting(_ greeting: String, count n: Int) { /* Greet n times */ }
  repeatGreeting("Hello, world!", count: 2) // count is labeled, greeting is not
#+END_SRC   


*** In-Out Parameters

#+FINDEX: inout

In-out parameters are passed as follows:

1. When the function is called, the value of the argument is copied.

2. In the body of the function, the copy is modified.

3. When the function returns, the copy's value is assigned to the
   original argument.

This behavior is known as /copy-in copy-out/ or /call by value result/.
For example, when a computed property or a property with observers is
passed as an in-out parameter, its getter is called as part of the
function call and its setter is called as part of the function return.

As an optimization, when the argument is a value stored at a physical
address in memory, the same memory location is used both inside and
outside the function body. The optimized behavior is known as /call by
reference/; it satisfies all of the requirements of the copy-in copy-out
model while removing the overhead of copying. Write your code using the
model given by copy-in copy-out, without depending on the
call-by-reference optimization, so that it behaves correctly with or
without the optimization.

Within a function, don't access a value that was passed as an in-out
argument, even if the original value is available in the current scope.
Accessing the original is a simultaneous access of the value, which
violates Swift's memory exclusivity guarantee. For the same reason, you
can't pass the same value to multiple in-out parameters.

For more information about memory safety and memory exclusivity, see
[[info:swift#Memory Safety][Memory Safety]].

A closure or nested function that captures an in-out parameter must be
nonescaping. If you need to capture an in-out parameter without mutating
it, use a capture list to explicitly capture the parameter immutably.

#+BEGIN_SRC swift
  func someFunction(a: inout Int) -> () -> Int {
      return { [a] in return a + 1 }
  }
#+END_SRC   

If you need to capture and mutate an in-out parameter, use an explicit
local copy, such as in multithreaded code that ensures all mutation has
finished before the function returns.

#+BEGIN_SRC swift
  func multithreadedFunction(queue: DispatchQueue, x: inout Int) {
      // Make a local copy and manually copy it back.
      var localX = x
      defer { x = localX }

      // Operate on localX asynchronously, then wait before returning.
      queue.async { someMutatingOperation(&localX) }
      queue.sync {}
  }
#+END_SRC   

For more discussion and examples of in-out parameters, see
[[In-Out Parameters][In-Out Parameters]].


*** Special Kinds of Parameters

Parameters can be ignored, take a variable number of values, and provide
default values using the following forms:

#+BEGIN_SRC swift
  _ : parameter type
  parameter name: parameter type...
  parameter name: parameter type = default argument value
#+END_SRC   

An underscore (=_=) parameter is explicitly ignored and can't be
accessed within the body of the function.

A parameter with a base type name followed immediately by three dots
(=...=) is understood as a variadic parameter. A parameter that
immediately follows a variadic parameter must have an argument label. A
function can have multiple variadic parameters. A variadic parameter is
treated as an array that contains elements of the base type name. For
example, the variadic parameter =Int...= is treated as =[Int]=. For an
example that uses a variadic parameter, see
[[info:swift#Variadic Parameters][Variadic Parameters]].

A parameter with an equals sign (===) and an expression after its type
is understood to have a default value of the given expression. The given
expression is evaluated when the function is called. If the parameter is
omitted when calling the function, the default value is used instead.

#+BEGIN_SRC swift
  func f(x: Int = 42) -> Int { return x }
  f() // Valid, uses default value
  f(x: 7) // Valid, uses the value provided
  f(7) // Invalid, missing argument label
#+END_SRC   


*** Special Kinds of Methods

#+FINDEX: mutating

Methods on an enumeration or a structure that modify =self= must be
marked with the =mutating= declaration modifier.

Methods that override a superclass method must be marked with the
=override= declaration modifier. It's a compile-time error to override a
method without the =override= modifier or to use the =override= modifier
on a method that doesn't override a superclass method.

Methods associated with a type rather than an instance of a type must be
marked with the =static= declaration modifier for enumerations and
structures, or with either the =static= or =class= declaration modifier
for classes. A class type method marked with the =class= declaration
modifier can be overridden by a subclass implementation; a class type
method marked with =class final= or =static= can't be overridden.

*** Methods with Special Names

Several methods that have special names enable syntactic sugar for
function call syntax. If a type defines one of these methods, instances
of the type can be used in function call syntax. The function call is
understood to be a call to one of the specially named methods on that
instance.

A class, structure, or enumeration type can support function call syntax
by defining a =dynamicallyCall(withArguments:)= method or a
=dynamicallyCall(withKeywordArguments:)= method, as described in
[[dynamicCallable][dynamicCallable]], or by defining a
call-as-function method, as described below. If the type defines both a
call-as-function method and one of the methods used by the
=dynamicCallable= attribute, the compiler gives preference to the
call-as-function method in circumstances where either method could be
used.

The name of a call-as-function method is =callAsFunction()=, or another
name that begins with =callAsFunction(= and adds labeled or unlabeled
arguments---for example, =callAsFunction(_:_:)= and
=callAsFunction(something:)= are also valid call-as-function method
names.

The following function calls are equivalent:

#+BEGIN_SRC swift
  struct CallableStruct {
      var value: Int
      func callAsFunction(_ number: Int, scale: Int) {
          print(scale * (number + value))
      }
  }
  let callable = CallableStruct(value: 100)
  callable(4, scale: 2)
  callable.callAsFunction(4, scale: 2)
  // Both function calls print 208.
#+END_SRC
    
The call-as-function methods and the methods from the =dynamicCallable=
attribute make different trade-offs between how much information you
encode into the type system and how much dynamic behavior is possible at
runtime. When you declare a call-as-function method, you specify the
number of arguments, and each argument's type and label. The
=dynamicCallable= attribute's methods specify only the type used to hold
the array of arguments.

Defining a call-as-function method, or a method from the
=dynamicCallable= attribute, doesn't let you use an instance of that
type as if it were a function in any context other than a function call
expression. For example:

#+BEGIN_SRC swift
  let someFunction1: (Int, Int) -> Void = callable(_:scale:) // Error
  let someFunction2: (Int, Int) -> Void = callable.callAsFunction(_:scale:)
#+END_SRC   

The =subscript(dynamicMemberLookup:)= subscript enables syntactic sugar
for member lookup, as described in
[[dynamicMemberLookup][dynamicMemberLookup]].


*** Throwing Functions and Methods

Functions and methods that can throw an error must be marked with the
=throws= keyword. These functions and methods are known as /throwing
functions/ and /throwing methods/. They have the following form:

#+BEGIN_SRC swift
  func function name(parameters) throws -> return type {
      statements
  }
#+END_SRC   

Calls to a throwing function or method must be wrapped in a =try= or
=try!= expression (that is, in the scope of a =try= or =try!= operator).

The =throws= keyword is part of a function's type, and nonthrowing
functions are subtypes of throwing functions. As a result, you can use a
nonthrowing function in the same places as a throwing one.

You can't overload a function based only on whether the function can
throw an error. That said, you can overload a function based on whether
a function /parameter/ can throw an error.

A throwing method can't override a nonthrowing method, and a throwing
method can't satisfy a protocol requirement for a nonthrowing method.
That said, a nonthrowing method can override a throwing method, and a
nonthrowing method can satisfy a protocol requirement for a throwing
method.


*** Rethrowing Functions and Methods

#+FINDEX: rethrows

A function or method can be declared with the =rethrows= keyword to
indicate that it throws an error only if one of its function parameters
throws an error. These functions and methods are known as /rethrowing
functions/ and /rethrowing methods/. Rethrowing functions and methods
must have at least one throwing function parameter.

#+BEGIN_SRC swift
  func someFunction(callback: () throws -> Void) rethrows {
      try callback()
  }
#+END_SRC   

A rethrowing function or method can contain a =throw= statement only
inside a =catch= clause. This lets you call the throwing function inside
a =do=-=catch= statement and handle errors in the =catch= clause by
throwing a different error. In addition, the =catch= clause must handle
only errors thrown by one of the rethrowing function's throwing
parameters. For example, the following is invalid because the =catch=
clause would handle the error thrown by =alwaysThrows()=.

#+BEGIN_SRC swift
  func alwaysThrows() throws {
      throw SomeError.error
  }
  func someFunction(callback: () throws -> Void) rethrows {
      do {
          try callback()
          try alwaysThrows() // Invalid, alwaysThrows() isn't a throwing
          parameter
      } catch {
          throw AnotherError.error
      }
  }
#+END_SRC    

A throwing method can't override a rethrowing method, and a throwing
method can't satisfy a protocol requirement for a rethrowing method.
That said, a rethrowing method can override a throwing method, and a
rethrowing method can satisfy a protocol requirement for a throwing
method.


*** Functions that Never Return

Swift defines a =Never= type, which indicates that a function or method
doesn't return to its caller. Functions and methods with the =Never=
return type are called /nonreturning/. Nonreturning functions and
methods either cause an irrecoverable error or begin a sequence of work
that continues indefinitely. This means that code that would otherwise
run immediately after the call is never executed. Throwing and
rethrowing functions can transfer program control to an appropriate
=catch= block, even when they're nonreturning.

A nonreturning function or method can be called to conclude the =else=
clause of a guard statement, as discussed in
[[Guard Statement][Guard Statement]].

You can override a nonreturning method, but the new method must preserve
its return type and nonreturning behavior.

Grammar of a function declaration

function-declaration
→
function-head
function-name
generic-parameter-clause
_{opt}
function-signature
generic-where-clause
_{opt}
function-body
_{opt}

function-head →
attributes
_{opt}
declaration-modifiers
_{opt} =func=

function-name →
identifier
|
operator

function-signature →
parameter-clause
=throws=_{opt}
function-result
_{opt}

function-signature
→
parameter-clause
=rethrows=
function-result
_{opt}

function-result → =->=
attributes
_{opt} type

function-body →
code-block

parameter-clause → =(=
=)= | =(=
parameter-list
=)=

parameter-list →
parameter |
parameter
=,=
parameter-list

parameter →
external-parameter-name
_{opt}
local-parameter-name
type-annotation
default-argument-clause
_{opt}

parameter →
external-parameter-name
_{opt}
local-parameter-name
type-annotation

parameter →
external-parameter-name
_{opt}
local-parameter-name
type-annotation
=...=

external-parameter-name
→
identifier

local-parameter-name
→
identifier

default-argument-clause
→ ===
expression


** Enumeration Declaration

An /enumeration declaration/ introduces a named enumeration type into
your program.

#+FINDEX: enum

Enumeration declarations have two basic forms and are declared using the
=enum= keyword. The body of an enumeration declared using either form
contains zero or more values---called /enumeration cases/---and any
number of declarations, including computed properties, instance methods,
type methods, initializers, type aliases, and even other enumeration,
structure, and class declarations. Enumeration declarations can't
contain deinitializer or protocol declarations.

Enumeration types can adopt any number of protocols, but can't inherit
from classes, structures, or other enumerations.

Unlike classes and structures, enumeration types don't have an
implicitly provided default initializer; all initializers must be
declared explicitly. Initializers can delegate to other initializers in
the enumeration, but the initialization process is complete only after
an initializer assigns one of the enumeration cases to =self=.

Like structures but unlike classes, enumerations are value types;
instances of an enumeration are copied when assigned to variables or
constants, or when passed as arguments to a function call. For
information about value types, see
[[info:swift#Structures and Enumerations Are Value Types][Structures and
Enumerations Are Value Types]].

You can extend the behavior of an enumeration type with an extension
declaration, as discussed in [[Extension Declaration][Extension
Declaration]].


*** Enumerations with Cases of Any Type

The following form declares an enumeration type that contains
enumeration cases of any type:

#+BEGIN_SRC swift
  enum enumeration name: adopted protocols {
      case enumeration case 1
      case enumeration case 2(associated value types)
  }
#+END_SRC
   
Enumerations declared in this form are sometimes called /discriminated
unions/ in other programming languages.

In this form, each case block consists of the =case= keyword followed by
one or more enumeration cases, separated by commas. The name of each
case must be unique. Each case can also specify that it stores values of
a given type. These types are specified in the /associated value types/
tuple, immediately following the name of the case.

Enumeration cases that store associated values can be used as functions
that create instances of the enumeration with the specified associated
values. And just like functions, you can get a reference to an
enumeration case and apply it later in your code.

#+BEGIN_SRC swift
  enum Number {
      case integer(Int)
      case real(Double)
  }
  let f = Number.integer
  // f is a function of type (Int) -> Number

  // Apply f to create an array of Number instances with integer values
  let evenInts: [Number] = [0, 2, 4, 6].map(f)
#+END_SRC
   
For more information and to see examples of cases with associated value
types, see [[info:swift#Associated Values][Associated
Values]].


**** Enumerations with Indirection

Enumerations can have a recursive structure, that is, they can have
cases with associated values that are instances of the enumeration type
itself. However, instances of enumeration types have value semantics,
which means they have a fixed layout in memory. To support recursion,
the compiler must insert a layer of indirection.

To enable indirection for a particular enumeration case, mark it with
the =indirect= declaration modifier. An indirect case must have an
associated value.

#+BEGIN_SRC swift
  enum Tree<T> {
      case empty
      indirect case node(value: T, left: Tree, right: Tree)
  }
#+END_SRC   

To enable indirection for all the cases of an enumeration that have an
associated value, mark the entire enumeration with the =indirect=
modifier---this is convenient when the enumeration contains many cases
that would each need to be marked with the =indirect= modifier.

An enumeration that's marked with the =indirect= modifier can contain a
mixture of cases that have associated values and cases those that don't.
That said, it can't contain any cases that are also marked with the
=indirect= modifier.


*** Enumerations with Cases of a Raw-Value Type

The following form declares an enumeration type that contains
enumeration cases of the same basic type:

#+BEGIN_SRC swift
  enum enumeration name: raw-value type, adopted protocols {
      case enumeration case 1 = raw value 1
      case enumeration case 2 = raw value 2
  }
#+END_SRC   

In this form, each case block consists of the =case= keyword, followed
by one or more enumeration cases, separated by commas. Unlike the cases
in the first form, each case has an underlying value, called a /raw
value/, of the same basic type. The type of these values is specified in
the /raw-value type/ and must represent an integer, floating-point
number, string, or single character. In particular, the /raw-value type/
must conform to the =Equatable= protocol and one of the following
protocols: =ExpressibleByIntegerLiteral= for integer literals,
=ExpressibleByFloatLiteral= for floating-point literals,
=ExpressibleByStringLiteral= for string literals that contain any number
of characters, and =ExpressibleByUnicodeScalarLiteral= or
=ExpressibleByExtendedGraphemeClusterLiteral= for string literals that
contain only a single character. Each case must have a unique name and
be assigned a unique raw value.

If the raw-value type is specified as =Int= and you don't assign a value
to the cases explicitly, they're implicitly assigned the values =0=,
=1=, =2=, and so on. Each unassigned case of type =Int= is implicitly
assigned a raw value that's automatically incremented from the raw value
of the previous case.

#+BEGIN_SRC swift
  enum ExampleEnum: Int {
      case a, b, c = 5, d
  }
#+END_SRC   

In the above example, the raw value of =ExampleEnum.a= is =0= and the
value of =ExampleEnum.b= is =1=. And because the value of
=ExampleEnum.c= is explicitly set to =5=, the value of =ExampleEnum.d=
is automatically incremented from =5= and is therefore =6=.

If the raw-value type is specified as =String= and you don't assign
values to the cases explicitly, each unassigned case is implicitly
assigned a string with the same text as the name of that case.

#+BEGIN_SRC swift
  enum GamePlayMode: String {
      case cooperative, individual, competitive
  }
#+END_SRC   

In the above example, the raw value of =GamePlayMode.cooperative= is
="cooperative"=, the raw value of =GamePlayMode.individual= is
="individual"=, and the raw value of =GamePlayMode.competitive= is
="competitive"=.

Enumerations that have cases of a raw-value type implicitly conform to
the =RawRepresentable= protocol, defined in the Swift standard library.
As a result, they have a =rawValue= property and a failable initializer
with the signature =init?(rawValue: RawValue)=. You can use the
=rawValue= property to access the raw value of an enumeration case, as
in =ExampleEnum.b.rawValue=. You can also use a raw value to find a
corresponding case, if there is one, by calling the enumeration's
failable initializer, as in =ExampleEnum(rawValue: 5)=, which returns an
optional case. For more information and to see examples of cases with
raw-value types, see [[info:swift#Raw Values][Raw
Values]].


*** Accessing Enumeration Cases

To reference the case of an enumeration type, use dot (=.=) syntax, as
in =EnumerationType.enumerationCase=. When the enumeration type can be
inferred from context, you can omit it (the dot is still required), as
described in [[info:swift#Enumeration Syntax][Enumeration
Syntax]] and [[Implicit Member Expression][Implicit Member Expression]].

To check the values of enumeration cases, use a =switch= statement, as
shown in [[info:swift#Matching Enumeration Values with a Switch Statement][Matching
Enumeration Values with a Switch Statement]]. The enumeration type is
pattern-matched against the enumeration case patterns in the case blocks
of the =switch= statement, as described in
[[Enumeration Case Pattern][Enumeration Case Pattern]].

Grammar of an enumeration declaration

enum-declaration →
attributes
_{opt}
access-level-modifier
_{opt}
union-style-enum

enum-declaration →
attributes
_{opt}
access-level-modifier
_{opt}
raw-value-style-enum

union-style-enum →
=indirect=_{opt} =enum=
enum-name
generic-parameter-clause
_{opt}
type-inheritance-clause
_{opt}
generic-where-clause
_{opt} ={=
union-style-enum-members
_{opt} =}=

union-style-enum-members
→
union-style-enum-member
union-style-enum-members
_{opt}

union-style-enum-member
→
declaration
|
union-style-enum-case-clause
|
compiler-control-statement

union-style-enum-case-clause
→ attributes
_{opt} =indirect=_{opt} =case=
union-style-enum-case-list

union-style-enum-case-list
→
union-style-enum-case
|
union-style-enum-case
=,=
union-style-enum-case-list

union-style-enum-case
→
enum-case-name
tuple-type _{opt}

enum-name →
identifier

enum-case-name →
identifier

raw-value-style-enum
→ =enum=
enum-name
generic-parameter-clause
_{opt}
type-inheritance-clause
generic-where-clause
_{opt} ={=
raw-value-style-enum-members
=}=

raw-value-style-enum-members
→
raw-value-style-enum-member
raw-value-style-enum-members
_{opt}

raw-value-style-enum-member
→
declaration
|
raw-value-style-enum-case-clause
|
compiler-control-statement

raw-value-style-enum-case-clause
→ attributes
_{opt} =case=
raw-value-style-enum-case-list

raw-value-style-enum-case-list
→
raw-value-style-enum-case
|
raw-value-style-enum-case
=,=
raw-value-style-enum-case-list

raw-value-style-enum-case
→
enum-case-name
raw-value-assignment
_{opt}

raw-value-assignment
→ ===
raw-value-literal

raw-value-literal →
numeric-literal
|
static-string-literal
|
boolean-literal


** Structure Declaration

A /structure declaration/ introduces a named structure type into your
program. Structure declarations are declared using the =struct= keyword
and have the following form:

#+BEGIN_SRC swift
  struct structure name: adopted protocols {
      declarations
  }
#+END_SRC
   
The body of a structure contains zero or more /declarations/. These
/declarations/ can include both stored and computed properties, type
properties, instance methods, type methods, initializers, subscripts,
type aliases, and even other structure, class, and enumeration
declarations. Structure declarations can't contain deinitializer or
protocol declarations. For a discussion and several examples of
structures that include various kinds of declarations, see
[[info:swift#Structures and Classes][Structures and Classes]].

Structure types can adopt any number of protocols, but can't inherit
from classes, enumerations, or other structures.

There are three ways to create an instance of a previously declared
structure:

- Call one of the initializers declared within the structure, as
  described in
  [[info:swift#Initializers][Initializers]].

- If no initializers are declared, call the structure's memberwise
  initializer, as described in
  [[info:swift#Memberwise Initializers for Structure Types][Memberwise Initializers
  for Structure Types]].

- If no initializers are declared, and all properties of the structure
  declaration were given initial values, call the structure's default
  initializer, as described in
  [[info:swift#Default Initializers][Default Initializers]].

The process of initializing a structure's declared properties is
described in [[info:swift#Initialization][Initialization]].

Properties of a structure instance can be accessed using dot (=.=)
syntax, as described in
[[info:swift#Accessing Properties][Accessing
Properties]].

Structures are value types; instances of a structure are copied when
assigned to variables or constants, or when passed as arguments to a
function call. For information about value types, see
[[info:swift#Structures and Enumerations Are Value Types][Structures and
Enumerations Are Value Types]].

You can extend the behavior of a structure type with an extension
declaration, as discussed in [[Extension Declaration][Extension
Declaration]].

Grammar of a structure declaration

struct-declaration →
attributes
_{opt}
access-level-modifier
_{opt} =struct=
struct-name
generic-parameter-clause
_{opt}
type-inheritance-clause
_{opt}
generic-where-clause
_{opt}
struct-body

struct-name →
identifier

struct-body → ={=
struct-members
_{opt} =}=

struct-members →
struct-member
struct-members
_{opt}

struct-member →
declaration
|
compiler-control-statement


** Class Declaration

A /class declaration/ introduces a named class type into your program.
Class declarations are declared using the =class= keyword and have the
following form:

#+BEGIN_SRC swift
  class class name: superclass, adopted protocols {
      declarations
  }
#+END_SRC
   
The body of a class contains zero or more /declarations/. These
/declarations/ can include both stored and computed properties, instance
methods, type methods, initializers, a single deinitializer, subscripts,
type aliases, and even other class, structure, and enumeration
declarations. Class declarations can't contain protocol declarations.
For a discussion and several examples of classes that include various
kinds of declarations, see
[[info:swift#Structures and Classes][Structures and Classes]].

A class type can inherit from only one parent class, its /superclass/,
but can adopt any number of protocols. The /superclass/ appears first
after the /class name/ and colon, followed by any /adopted protocols/.
Generic classes can inherit from other generic and nongeneric classes,
but a nongeneric class can inherit only from other nongeneric classes.
When you write the name of a generic superclass class after the colon,
you must include the full name of that generic class, including its
generic parameter clause.

As discussed in [[Initializer Declaration][Initializer Declaration]],
classes can have designated and convenience initializers. The designated
initializer of a class must initialize all of the class's declared
properties and it must do so before calling any of its superclass's
designated initializers.

A class can override properties, methods, subscripts, and initializers
of its superclass. Overridden properties, methods, subscripts, and
designated initializers must be marked with the =override= declaration
modifier.

To require that subclasses implement a superclass's initializer, mark
the superclass's initializer with the =required= declaration modifier.
The subclass's implementation of that initializer must also be marked
with the =required= declaration modifier.

Although properties and methods declared in the /superclass/ are
inherited by the current class, designated initializers declared in the
/superclass/ are only inherited when the subclass meets the conditions
described in [[info:swift#Automatic Initializer Inheritance][Automatic
Initializer Inheritance]]. Swift classes don't inherit from a universal
base class.

There are two ways to create an instance of a previously declared class:

- Call one of the initializers declared within the class, as described
  in [[info:swift#Initializers][Initializers]].

- If no initializers are declared, and all properties of the class
  declaration were given initial values, call the class's default
  initializer, as described in
  [[info:swift#Default Initializers][Default Initializers]].

Access properties of a class instance with dot (=.=) syntax, as
described in
[[info:swift#Accessing Properties][Accessing
Properties]].

Classes are reference types; instances of a class are referred to,
rather than copied, when assigned to variables or constants, or when
passed as arguments to a function call. For information about reference
types, see
[[info:swift#Structures and Enumerations Are Value Types][Structures and
Enumerations Are Value Types]].

You can extend the behavior of a class type with an extension
declaration, as discussed in [[Extension Declaration][Extension
Declaration]].

Grammar of a class declaration

class-declaration →
attributes
_{opt}
access-level-modifier
_{opt} =final=_{opt} =class=
class-name
generic-parameter-clause
_{opt}
type-inheritance-clause
_{opt}
generic-where-clause
_{opt}
class-body

class-declaration →
attributes
_{opt} =final=
access-level-modifier
_{opt} =class=
class-name
generic-parameter-clause
_{opt}
type-inheritance-clause
_{opt}
generic-where-clause
_{opt}
class-body

class-name →
identifier

class-body → ={=
class-members
_{opt} =}=

class-members →
class-member
class-members
_{opt}

class-member →
declaration
|
compiler-control-statement


** Protocol Declaration

A /protocol declaration/ introduces a named protocol type into your
program. Protocol declarations are declared at global scope using the
=protocol= keyword and have the following form:

#+BEGIN_SRC swift
  protocol protocol name: inherited protocols {
      protocol member declarations
  }
#+END_SRC

The body of a protocol contains zero or more /protocol member
declarations/, which describe the conformance requirements that any type
adopting the protocol must fulfill. In particular, a protocol can
declare that conforming types must implement certain properties,
methods, initializers, and subscripts. Protocols can also declare
special kinds of type aliases, called /associated types/, that can
specify relationships among the various declarations of the protocol.
Protocol declarations can't contain class, structure, enumeration, or
other protocol declarations. The /protocol member declarations/ are
discussed in detail below.

Protocol types can inherit from any number of other protocols. When a
protocol type inherits from other protocols, the set of requirements
from those other protocols are aggregated, and any type that inherits
from the current protocol must conform to all those requirements. For an
example of how to use protocol inheritance, see
[[info:swift#Protocol Inheritance][Protocol Inheritance]].

Note

You can also aggregate the conformance requirements of multiple
protocols using protocol composition types, as described in
[[Protocol Composition Type][Protocol Composition Type]] and
[[info:swift#Protocol Composition][Protocol Composition]].

You can add protocol conformance to a previously declared type by
adopting the protocol in an extension declaration of that type. In the
extension, you must implement all of the adopted protocol's
requirements. If the type already implements all of the requirements,
you can leave the body of the extension declaration empty.

By default, types that conform to a protocol must implement all
properties, methods, and subscripts declared in the protocol. That said,
you can mark these protocol member declarations with the =optional=
declaration modifier to specify that their implementation by a
conforming type is optional. The =optional= modifier can be applied only
to members that are marked with the =objc= attribute, and only to
members of protocols that are marked with the =objc= attribute. As a
result, only class types can adopt and conform to a protocol that
contains optional member requirements. For more information about how to
use the =optional= declaration modifier and for guidance about how to
access optional protocol members---for example, when you're not sure
whether a conforming type implements them---see
[[info:swift#Optional Protocol Requirements][Optional Protocol
Requirements]].

The cases of an enumeration can satisfy protocol requirements for type
members. Specifically, an enumeration case without any associated values
satisfies a protocol requirement for a get-only type variable of type
=Self=, and an enumeration case with associated values satisfies a
protocol requirement for a function that returns =Self= whose parameters
and their argument labels match the case's associated values. For
example:

#+BEGIN_SRC swift
  protocol SomeProtocol {
      static var someValue: Self { get }
      static func someFunction(x: Int) -> Self
  }
  enum MyEnum: SomeProtocol {
      case someValue
      case someFunction(x: Int)
  }
#+END_SRC   

To restrict the adoption of a protocol to class types only, include the
=AnyObject= protocol in the /inherited protocols/ list after the colon.
For example, the following protocol can be adopted only by class types:

#+BEGIN_SRC swift
  protocol SomeProtocol: AnyObject {
      /* Protocol members go here */
  }
#+END_SRC   

Any protocol that inherits from a protocol that's marked with the
=AnyObject= requirement can likewise be adopted only by class types.

Note

If a protocol is marked with the =objc= attribute, the =AnyObject=
requirement is implicitly applied to that protocol; there's no need to
mark the protocol with the =AnyObject= requirement explicitly.

Protocols are named types, and thus they can appear in all the same
places in your code as other named types, as discussed in
[[info:swift#Protocols as Types][Protocols as Types]]. However,
you can't construct an instance of a protocol, because protocols don't
actually provide the implementations for the requirements they specify.

You can use protocols to declare which methods a delegate of a class or
structure should implement, as described in
[[info:swift#Delegation][Delegation]].

Grammar of a protocol declaration

protocol-declaration
→ attributes
_{opt}
access-level-modifier
_{opt} =protocol=
protocol-name
type-inheritance-clause
_{opt}
generic-where-clause
_{opt}
protocol-body

protocol-name →
identifier

protocol-body → ={=
protocol-members
_{opt} =}=

protocol-members →
protocol-member
protocol-members
_{opt}

protocol-member →
protocol-member-declaration
|
compiler-control-statement

protocol-member-declaration
→
protocol-property-declaration

protocol-member-declaration
→
protocol-method-declaration

protocol-member-declaration
→
protocol-initializer-declaration

protocol-member-declaration
→
protocol-subscript-declaration

protocol-member-declaration
→
protocol-associated-type-declaration

protocol-member-declaration
→
typealias-declaration


*** Protocol Property Declaration

Protocols declare that conforming types must implement a property by
including a /protocol property declaration/ in the body of the protocol
declaration. Protocol property declarations have a special form of a
variable declaration:

#+BEGIN_SRC swift
  var property name: type { get set }
#+END_SRC   

As with other protocol member declarations, these property declarations
declare only the getter and setter requirements for types that conform
to the protocol. As a result, you don't implement the getter or setter
directly in the protocol in which it's declared.

The getter and setter requirements can be satisfied by a conforming type
in a variety of ways. If a property declaration includes both the =get=
and =set= keywords, a conforming type can implement it with a stored
variable property or a computed property that's both readable and
writeable (that is, one that implements both a getter and a setter).
However, that property declaration can't be implemented as a constant
property or a read-only computed property. If a property declaration
includes only the =get= keyword, it can be implemented as any kind of
property. For examples of conforming types that implement the property
requirements of a protocol, see
[[info:swift#Property Requirements][Property Requirements]].

To declare a type property requirement in a protocol declaration, mark
the property declaration with the =static= keyword. Structures and
enumerations that conform to the protocol declare the property with the
=static= keyword, and classes that conform to the protocol declare the
property with either the =static= or =class= keyword. Extensions that
add protocol conformance to a structure, enumeration, or class use the
same keyword as the type they extend uses. Extensions that provide a
default implementation for a type property requirement use the =static=
keyword.

See also [[Variable Declaration][Variable Declaration]].

Grammar of a protocol property declaration

protocol-property-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-keyword-block


*** Protocol Method Declaration

Protocols declare that conforming types must implement a method by
including a protocol method declaration in the body of the protocol
declaration. Protocol method declarations have the same form as function
declarations, with two exceptions: They don't include a function body,
and you can't provide any default parameter values as part of the
function declaration. For examples of conforming types that implement
the method requirements of a protocol, see
[[info:swift#Method Requirements][Method Requirements]].

To declare a class or static method requirement in a protocol
declaration, mark the method declaration with the =static= declaration
modifier. Structures and enumerations that conform to the protocol
declare the method with the =static= keyword, and classes that conform
to the protocol declare the method with either the =static= or =class=
keyword. Extensions that add protocol conformance to a structure,
enumeration, or class use the same keyword as the type they extend uses.
Extensions that provide a default implementation for a type method
requirement use the =static= keyword.

See also [[Function Declaration][Function Declaration]].

Grammar of a protocol method declaration

protocol-method-declaration
→
function-head
function-name
generic-parameter-clause
_{opt}
function-signature
generic-where-clause
_{opt}


*** Protocol Initializer Declaration

Protocols declare that conforming types must implement an initializer by
including a protocol initializer declaration in the body of the protocol
declaration. Protocol initializer declarations have the same form as
initializer declarations, except they don't include the initializer's
body.

A conforming type can satisfy a nonfailable protocol initializer
requirement by implementing a nonfailable initializer or an =init!=
failable initializer. A conforming type can satisfy a failable protocol
initializer requirement by implementing any kind of initializer.

When a class implements an initializer to satisfy a protocol's
initializer requirement, the initializer must be marked with the
=required= declaration modifier if the class isn't already marked with
the =final= declaration modifier.

See also [[Initializer Declaration][Initializer Declaration]].

Grammar of a protocol initializer declaration

protocol-initializer-declaration
→
initializer-head
generic-parameter-clause
_{opt}
parameter-clause
=throws=_{opt}
generic-where-clause
_{opt}

protocol-initializer-declaration
→
initializer-head
generic-parameter-clause
_{opt}
parameter-clause
=rethrows=
generic-where-clause
_{opt}


*** Protocol Subscript Declaration

Protocols declare that conforming types must implement a subscript by
including a protocol subscript declaration in the body of the protocol
declaration. Protocol subscript declarations have a special form of a
subscript declaration:

#+BEGIN_SRC swift
  subscript (parameters) -> return type { get set }
#+END_SRC   

Subscript declarations only declare the minimum getter and setter
implementation requirements for types that conform to the protocol. If
the subscript declaration includes both the =get= and =set= keywords, a
conforming type must implement both a getter and a setter clause. If the
subscript declaration includes only the =get= keyword, a conforming type
must implement /at least/ a getter clause and optionally can implement a
setter clause.

To declare a static subscript requirement in a protocol declaration,
mark the subscript declaration with the =static= declaration modifier.
Structures and enumerations that conform to the protocol declare the
subscript with the =static= keyword, and classes that conform to the
protocol declare the subscript with either the =static= or =class=
keyword. Extensions that add protocol conformance to a structure,
enumeration, or class use the same keyword as the type they extend uses.
Extensions that provide a default implementation for a static subscript
requirement use the =static= keyword.

See also [[Subscript Declaration][Subscript Declaration]].

Grammar of a protocol subscript declaration

protocol-subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_{opt}
getter-setter-keyword-block


*** Protocol Associated Type Declaration

#+FINDEX: associatedtype
#+FINDEX: Self

Protocols declare associated types using the =associatedtype= keyword.
An associated type provides an alias for a type that's used as part of
a protocol's declaration. Associated types are similar to type
parameters in generic parameter clauses, but they're associated with
=Self= in the protocol in which they're declared. In that context,
=Self= refers to the eventual type that conforms to the protocol. For
more information and examples, see
[[info:swift#Associated Types][Associated Types]].

#+FINDEX: where

You use a generic =where= clause in a protocol declaration to add
constraints to an associated types inherited from another protocol,
without redeclaring the associated types. For example, the declarations
of =SubProtocol= below are equivalent:

#+BEGIN_SRC swift
  protocol SomeProtocol {
      associatedtype SomeType
  }

  protocol SubProtocolA: SomeProtocol {
      // This syntax produces a warning.
      associatedtype SomeType: Equatable
  }

  // This syntax is preferred.
  protocol SubProtocolB: SomeProtocol where SomeType: Equatable { }
#+END_SRC    

See also [[Type Alias Declaration][Type Alias Declaration]].

Grammar of a protocol associated type declaration

protocol-associated-type-declaration
→ attributes
_{opt}
access-level-modifier
_{opt} =associatedtype=
typealias-name
type-inheritance-clause
_{opt}
typealias-assignment
_{opt}
generic-where-clause
_{opt}


** Initializer Declaration

An /initializer declaration/ introduces an initializer for a class,
structure, or enumeration into your program. Initializer declarations
are declared using the =init= keyword and have two basic forms.

Structure, enumeration, and class types can have any number of
initializers, but the rules and associated behavior for class
initializers are different. Unlike structures and enumerations, classes
have two kinds of initializers: designated initializers and convenience
initializers, as described in
[[info:swift#Initialization][Initialization]].

The following form declares initializers for structures, enumerations,
and designated initializers of classes:

#+BEGIN_SRC swift
  init(parameters) {
      statements
  }
#+END_SRC   

A designated initializer of a class initializes all of the class's
properties directly. It can't call any other initializers of the same
class, and if the class has a superclass, it must call one of the
superclass's designated initializers. If the class inherits any
properties from its superclass, one of the superclass's designated
initializers must be called before any of these properties can be set or
modified in the current class.

Designated initializers can be declared in the context of a class
declaration only and therefore can't be added to a class using an
extension declaration.

Initializers in structures and enumerations can call other declared
initializers to delegate part or all of the initialization process.

To declare convenience initializers for a class, mark the initializer
declaration with the =convenience= declaration modifier.

#+BEGIN_SRC swift
  convenience init(parameters) {
      statements
  }
#+END_SRC   

Convenience initializers can delegate the initialization process to
another convenience initializer or to one of the class's designated
initializers. That said, the initialization processes must end with a
call to a designated initializer that ultimately initializes the class's
properties. Convenience initializers can't call a superclass's
initializers.

You can mark designated and convenience initializers with the =required=
declaration modifier to require that every subclass implement the
initializer. A subclass's implementation of that initializer must also
be marked with the =required= declaration modifier.

By default, initializers declared in a superclass aren't inherited by
subclasses. That said, if a subclass initializes all of its stored
properties with default values and doesn't define any initializers of
its own, it inherits all of the superclass's initializers. If the
subclass overrides all of the superclass's designated initializers, it
inherits the superclass's convenience initializers.

As with methods, properties, and subscripts, you need to mark overridden
designated initializers with the =override= declaration modifier.

Note

If you mark an initializer with the =required= declaration modifier, you
don't also mark the initializer with the =override= modifier when you
override the required initializer in a subclass.

Just like functions and methods, initializers can throw or rethrow
errors. And just like functions and methods, you use the =throws= or
=rethrows= keyword after an initializer's parameters to indicate the
appropriate behavior.

To see examples of initializers in various type declarations, see
[[info:swift#Initialization][Initialization]].


*** Failable Initializers

A /failable initializer/ is a type of initializer that produces an
optional instance or an implicitly unwrapped optional instance of the
type the initializer is declared on. As a result, a failable initializer
can return =nil= to indicate that initialization failed.

To declare a failable initializer that produces an optional instance,
append a question mark to the =init= keyword in the initializer
declaration (=init?=). To declare a failable initializer that produces
an implicitly unwrapped optional instance, append an exclamation point
instead (=init!=). The example below shows an =init?= failable
initializer that produces an optional instance of a structure.

#+BEGIN_SRC swift
  struct SomeStruct {
      let property: String
      // produces an optional instance of 'SomeStruct'
      init?(input: String) {
          if input.isEmpty {
              // discard 'self' and return 'nil'
              return nil
          }
          property = input
      }
  }
#+END_SRC    

You call an =init?= failable initializer in the same way that you call a
nonfailable initializer, except that you must deal with the optionality
of the result.

#+BEGIN_SRC swift
  if let actualInstance = SomeStruct(input: "Hello") {
      // do something with the instance of 'SomeStruct'
  } else {
      // initialization of 'SomeStruct' failed and the initializer returned
      'nil'
  }
#+END_SRC   

A failable initializer can return =nil= at any point in the
implementation of the initializer's body.

A failable initializer can delegate to any kind of initializer. A
nonfailable initializer can delegate to another nonfailable initializer
or to an =init!= failable initializer. A nonfailable initializer can
delegate to an =init?= failable initializer by force-unwrapping the
result of the superclass's initializer---for example, by writing
=super.init()!=.

Initialization failure propagates through initializer delegation.
Specifically, if a failable initializer delegates to an initializer that
fails and returns =nil=, then the initializer that delegated also fails
and implicitly returns =nil=. If a nonfailable initializer delegates to
an =init!= failable initializer that fails and returns =nil=, then a
runtime error is raised (as if you used the =!= operator to unwrap an
optional that has a =nil= value).

A failable designated initializer can be overridden in a subclass by any
kind of designated initializer. A nonfailable designated initializer can
be overridden in a subclass by a nonfailable designated initializer
only.

For more information and to see examples of failable initializers, see
[[Failable Initializers][Failable Initializers]].

Grammar of an initializer declaration

initializer-declaration
→
initializer-head
generic-parameter-clause
_{opt}
parameter-clause
=throws=_{opt}
generic-where-clause
_{opt}
initializer-body

initializer-declaration
→
initializer-head
generic-parameter-clause
_{opt}
parameter-clause
=rethrows=
generic-where-clause
_{opt}
initializer-body

initializer-head →
attributes
_{opt}
declaration-modifiers
_{opt} =init=

initializer-head →
attributes
_{opt}
declaration-modifiers
_{opt} =init= =?=

initializer-head →
attributes
_{opt}
declaration-modifiers
_{opt} =init= =!=

initializer-body →
code-block


** Deinitializer Declaration

#+FINDEX: deinit

A /deinitializer declaration/ declares a deinitializer for a class type.
Deinitializers take no parameters and have the following form:

#+BEGIN_SRC swift
  deinit {
      statements
  }
#+END_SRC
   
A deinitializer is called automatically when there are no longer any
references to a class object, just before the class object is
deallocated. A deinitializer can be declared only in the body of a class
declaration---but not in an extension of a class---and each class can
have at most one.

A subclass inherits its superclass's deinitializer, which is implicitly
called just before the subclass object is deallocated. The subclass
object isn't deallocated until all deinitializers in its inheritance
chain have finished executing.

Deinitializers aren't called directly.

For an example of how to use a deinitializer in a class declaration, see
[[info:swift#Deinitialization][Deinitialization]].

Grammar of a deinitializer declaration

deinitializer-declaration
→ attributes
_{opt} =deinit=
code-block


** Extension Declaration

#+FINDEX: extension

An /extension declaration/ allows you to extend the behavior of existing
types. Extension declarations are declared using the =extension= keyword
and have the following form:

#+BEGIN_SRC swift
  extension type name where requirements {
      declarations
  }
#+END_SRC   

The body of an extension declaration contains zero or more
/declarations/. These /declarations/ can include computed properties,
computed type properties, instance methods, type methods, initializers,
subscript declarations, and even class, structure, and enumeration
declarations. Extension declarations can't contain deinitializer or
protocol declarations, stored properties, property observers, or other
extension declarations. Declarations in a protocol extension can't be
marked =final=. For a discussion and several examples of extensions that
include various kinds of declarations, see
[[info:swift#Extensions][Extensions]].

If the /type name/ is a class, structure, or enumeration type, the
extension extends that type. If the /type name/ is a protocol type, the
extension extends all types that conform to that protocol.

Extension declarations that extend a generic type or a protocol with
associated types can include /requirements/. If an instance of the
extended type or of a type that conforms to the extended protocol
satisfies the /requirements/, the instance gains the behavior specified
in the declaration.

Extension declarations can contain initializer declarations. That said,
if the type you're extending is defined in another module, an
initializer declaration must delegate to an initializer already defined
in that module to ensure members of that type are properly initialized.

Properties, methods, and initializers of an existing type can't be
overridden in an extension of that type.

Extension declarations can add protocol conformance to an existing
class, structure, or enumeration type by specifying /adopted protocols/:

#+BEGIN_SRC swift
  extension type name: adopted protocols where requirements {
      declarations
  }
#+END_SRC   

Extension declarations can't add class inheritance to an existing class,
and therefore you can specify only a list of protocols after the /type
name/ and colon.


*** Conditional Conformance

You can extend a generic type to conditionally conform to a protocol, so
that instances of the type conform to the protocol only when certain
requirements are met. You add conditional conformance to a protocol by
including /requirements/ in an extension declaration.


**** Overridden Requirements Aren't Used in Some Generic Contexts

In some generic contexts, types that get behavior from conditional
conformance to a protocol don't always use the specialized
implementations of that protocol's requirements. To illustrate this
behavior, the following example defines two protocols and a generic type
that conditionally conforms to both protocols.

#+BEGIN_SRC swift
  protocol Loggable {
      func log()
  }
  extension Loggable {
      func log() {
          print(self)
      }
  }

  protocol TitledLoggable: Loggable {
      static var logTitle: String { get }
  }
  extension TitledLoggable {
      func log() {
          print("\(Self.logTitle): \(self)")
      }
  }

  struct Pair<T>: CustomStringConvertible {
      let first: T
      let second: T
      var description: String {
          return "(\(first), \(second))"
      }
  }

  extension Pair: Loggable where T: Loggable { }
  extension Pair: TitledLoggable where T: TitledLoggable {
      static var logTitle: String {
          return "Pair of '\(T.logTitle)'"
      }
  }

  extension String: TitledLoggable {
      static var logTitle: String {
          return "String"
      }
  }
#+END_SRC    

The =Pair= structure conforms to =Loggable= and =TitledLoggable=
whenever its generic type conforms to =Loggable= or =TitledLoggable=,
respectively. In the example below, =oneAndTwo= is an instance of
=Pair<String>=, which conforms to =TitledLoggable= because =String=
conforms to =TitledLoggable=. When the =log()= method is called on
=oneAndTwo= directly, the specialized version containing the title
string is used.

#+BEGIN_SRC swift
  let oneAndTwo = Pair(first: "one", second: "two")
  oneAndTwo.log()
  // Prints "Pair of 'String': (one, two)"
#+END_SRC   

However, when =oneAndTwo= is used in a generic context or as an instance
of the =Loggable= protocol, the specialized version isn't used. Swift
picks which implementation of =log()= to call by consulting only the
minimum requirements that =Pair= needs to conform to =Loggable=. For
this reason, the default implementation provided by the =Loggable=
protocol is used instead.

#+BEGIN_SRC swift
  func doSomething<T: Loggable>(with x: T) {
      x.log()
  }
  doSomething(with: oneAndTwo)
  // Prints "(one, two)"
#+END_SRC   

When =log()= is called on the instance that's passed to
=doSomething(_:)=, the customized title is omitted from the logged
string.


*** Protocol Conformance Must Not Be Redundant

A concrete type can conform to a particular protocol only once. Swift
marks redundant protocol conformances as an error. You're likely to
encounter this kind of error in two kinds of situations. The first
situation is when you explicitly conform to the same protocol multiple
times, but with different requirements. The second situation is when you
implicitly inherit from the same protocol multiple times. These
situations are discussed in the sections below.


**** Resolving Explicit Redundancy

Multiple extensions on a concrete type can't add conformance to the same
protocol, even if the extensions' requirements are mutually exclusive.
This restriction is demonstrated in the example below. Two extension
declarations attempt to add conditional conformance to the
=Serializable= protocol, one for for arrays with =Int= elements, and one
for arrays with =String= elements.

#+BEGIN_SRC swift
  protocol Serializable {
      func serialize() -> Any
  }


  extension Array: Serializable where Element == Int {
      func serialize() -> Any {
          // implementation
      }
  }
  extension Array: Serializable where Element == String {
      func serialize() -> Any {
          // implementation
      }
  }
  // Error: redundant conformance of 'Array<Element>' to protocol 'Serializable'
#+END_SRC    

If you need to add conditional conformance based on multiple concrete
types, create a new protocol that each type can conform to and use that
protocol as the requirement when declaring conditional conformance.

#+BEGIN_SRC swift
  protocol SerializableInArray { }
  extension Int: SerializableInArray { }
  extension String: SerializableInArray { }

  extension Array: Serializable where Element: SerializableInArray {
      func serialize() -> Any {
          // implementation
      }
  }
#+END_SRC

**** Resolving Implicit Redundancy

When a concrete type conditionally conforms to a protocol, that type
implicitly conforms to any parent protocols with the same requirements.

If you need a type to conditionally conform to two protocols that
inherit from a single parent, explicitly declare conformance to the
parent protocol. This avoids implicitly conforming to the parent
protocol twice with different requirements.

The following example explicitly declares the conditional conformance of
=Array= to =Loggable= to avoid a conflict when declaring its conditional
conformance to both =TitledLoggable= and the new =MarkedLoggable=
protocol.

#+BEGIN_SRC swift
  protocol MarkedLoggable: Loggable {
      func markAndLog()
  }

  extension MarkedLoggable {
      func markAndLog() {
          print("----------")
          log()
      }
  }

  extension Array: Loggable where Element: Loggable { }
  extension Array: TitledLoggable where Element: TitledLoggable {
      static var logTitle: String {
          return "Array of '\(Element.logTitle)'"
      }
  }
  extension Array: MarkedLoggable where Element: MarkedLoggable { }
#+END_SRC    

Without the extension to explicitly declare conditional conformance to
=Loggable=, the other =Array= extensions would implicitly create these
declarations, resulting in an error:

#+BEGIN_SRC swift
  extension Array: Loggable where Element: TitledLoggable { }
  extension Array: Loggable where Element: MarkedLoggable { }
  // Error: redundant conformance of 'Array<Element>' to protocol 'Loggable'
#+END_SRC   

Grammar of an extension declaration

extension-declaration
→ attributes
_{opt}
access-level-modifier
_{opt} =extension=
type-identifier
type-inheritance-clause
_{opt}
generic-where-clause
_{opt}
extension-body

extension-body → ={=
extension-members
_{opt} =}=

extension-members →
extension-member
extension-members
_{opt}

extension-member →
declaration
|
compiler-control-statement


** Subscript Declaration

A /subscript/ declaration allows you to add subscripting support for
objects of a particular type and are typically used to provide a
convenient syntax for accessing the elements in a collection, list, or
sequence. Subscript declarations are declared using the =subscript=
keyword and have the following form:

#+BEGIN_SRC swift
  subscript (parameters) -> return type {
      get {
          statements
      }
      set(setter name) {
          statements
      }
  }
#+END_SRC   

Subscript declarations can appear only in the context of a class,
structure, enumeration, extension, or protocol declaration.

The /parameters/ specify one or more indexes used to access elements of
the corresponding type in a subscript expression (for example, the =i=
in the expression =object[i]=). Although the indexes used to access the
elements can be of any type, each parameter must include a type
annotation to specify the type of each index. The /return type/
specifies the type of the element being accessed.

As with computed properties, subscript declarations support reading and
writing the value of the accessed elements. The getter is used to read
the value, and the setter is used to write the value. The setter clause
is optional, and when only a getter is needed, you can omit both clauses
and simply return the requested value directly. That said, if you
provide a setter clause, you must also provide a getter clause.

The /setter name/ and enclosing parentheses are optional. If you provide
a setter name, it's used as the name of the parameter to the setter. If
you don't provide a setter name, the default parameter name to the
setter is =value=. The type of the parameter to the setter is the same
as the /return type/.

You can overload a subscript declaration in the type in which it's
declared, as long as the /parameters/ or the /return type/ differ from
the one you're overloading. You can also override a subscript
declaration inherited from a superclass. When you do so, you must mark
the overridden subscript declaration with the =override= declaration
modifier.

Subscript parameters follow the same rules as function parameters, with
two exceptions. By default, the parameters used in subscripting don't
have argument labels, unlike functions, methods, and initializers.
However, you can provide explicit argument labels using the same syntax
that functions, methods, and initializers use. In addition, subscripts
can't have in-out parameters. A subscript parameter can have a default
value, using the syntax described in
[[Special Kinds of Parameters][Special Kinds of Parameters]].

You can also declare subscripts in the context of a protocol
declaration, as described in [[Protocol Subscript Declaration][Protocol
Subscript Declaration]].

For more information about subscripting and to see examples of subscript
declarations, see [[info:swift#Subscripts][Subscripts]].

Grammar of a subscript declaration

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_{opt}
code-block

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_{opt}
getter-setter-block

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_{opt}
getter-setter-keyword-block

subscript-head →
attributes
_{opt}
declaration-modifiers
_{opt} =subscript=
generic-parameter-clause
_{opt}
parameter-clause

subscript-result → =->=
attributes
_{opt} type


** Operator Declaration

An /operator declaration/ introduces a new infix, prefix, or postfix
operator into your program and is declared using the =operator= keyword.

You can declare operators of three different fixities: infix, prefix,
and postfix. The /fixity/ of an operator specifies the relative position
of an operator to its operands.

There are three basic forms of an operator declaration, one for each
fixity. The fixity of the operator is specified by marking the operator
declaration with the =infix=, =prefix=, or =postfix= declaration
modifier before the =operator= keyword. In each form, the name of the
operator can contain only the operator characters defined in
[[Operators][Operators]].

The following form declares a new infix operator:

#+BEGIN_SRC swift
  infix operator operator name: precedence group
#+END_SRC   

An /infix operator/ is a binary operator that's written between its two
operands, such as the familiar addition operator (=+=) in the expression
=1 + 2=.

Infix operators can optionally specify a precedence group. If you omit
the precedence group for an operator, Swift uses the default precedence
group, =DefaultPrecedence=, which specifies a precedence just higher
than =TernaryPrecedence=. For more information, see
[[Precedence Group Declaration][Precedence Group Declaration]].

The following form declares a new prefix operator:

#+BEGIN_SRC swift
  prefix operator operator name
#+END_SRC   

A /prefix operator/ is a unary operator that's written immediately
before its operand, such as the prefix logical NOT operator (=!=) in the
expression =!a=.

Prefix operators declarations don't specify a precedence level. Prefix
operators are nonassociative.

The following form declares a new postfix operator:

#+BEGIN_SRC swift
  postfix operator operator name
#+END_SRC   

A /postfix operator/ is a unary operator that's written immediately
after its operand, such as the postfix forced-unwrap operator (=!=) in
the expression =a!=.

As with prefix operators, postfix operator declarations don't specify a
precedence level. Postfix operators are nonassociative.

After declaring a new operator, you implement it by declaring a static
method that has the same name as the operator. The static method is a
member of one of the types whose values the operator takes as an
argument---for example, an operator that multiplies a =Double= by an
=Int= is implemented as a static method on either the =Double= or =Int=
structure. If you're implementing a prefix or postfix operator, you must
also mark that method declaration with the corresponding =prefix= or
=postfix= declaration modifier. To see an example of how to create and
implement a new operator, see
[[info:swift#Custom Operators][Custom Operators]].

Grammar of an operator declaration

operator-declaration
→
prefix-operator-declaration
|
postfix-operator-declaration
|
infix-operator-declaration

prefix-operator-declaration
→ =prefix= =operator=
operator

postfix-operator-declaration
→ =postfix= =operator=
operator

infix-operator-declaration
→ =infix= =operator=
operator
infix-operator-group
_{opt}

infix-operator-group
→ =:=
precedence-group-name


** Precedence Group Declaration

A /precedence group declaration/ introduces a new grouping for infix
operator precedence into your program. The precedence of an operator
specifies how tightly the operator binds to its operands, in the absence
of grouping parentheses.

A precedence group declaration has the following form:

#+BEGIN_SRC swift
  precedencegroup precedence group name {
      higherThan: lower group names
      lowerThan: higher group names
      associativity: associativity
      assignment: assignment
  }
#+END_SRC   

The /lower group names/ and /higher group names/ lists specify the new
precedence group's relation to existing precedence groups. The
=lowerThan= precedence group attribute may only be used to refer to
precedence groups declared outside of the current module. When two
operators compete with each other for their operands, such as in the
expression =2 + 3 * 5=, the operator with the higher relative precedence
binds more tightly to its operands.

Note

Precedence groups related to each other using /lower group names/ and
/higher group names/ must fit into a single relational hierarchy, but
they /don't/ have to form a linear hierarchy. This means it's possible
to have precedence groups with undefined relative precedence. Operators
from those precedence groups can't be used next to each other without
grouping parentheses.

Swift defines numerous precedence groups to go along with the operators
provided by the standard library. For example, the addition (=+=) and
subtraction (=-=) operators belong to the =AdditionPrecedence= group,
and the multiplication (=*=) and division (=/=) operators belong to the
=MultiplicationPrecedence= group. For a complete list of precedence
groups provided by the Swift standard library, see
[[https://developer.apple.com/documentation/swift/operator_declarations][Operator
Declarations]]
[https://developer.apple.com/documentation/swift/operator_declarations].

#+FINDEX: associativity

The /associativity/ of an operator specifies how a sequence of operators
with the same precedence level are grouped together in the absence of
grouping parentheses. You specify the associativity of an operator by
writing one of the context-sensitive keywords =left=, =right=, or
=none=---if your omit the associativity, the default is =none=.
Operators that are left-associative group left-to-right. For example,
the subtraction operator (=-=) is left-associative, so the expression
=4 - 5 - 6= is grouped as =(4 - 5) - 6= and evaluates to =-7=. Operators
that are right-associative group right-to-left, and operators that are
specified with an associativity of =none= don't associate at all.
Nonassociative operators of the same precedence level can't appear
adjacent to each to other. For example, the =<= operator has an
associativity of =none=, which means =1 < 2 < 3= isn't a valid
expression.

The /assignment/ of a precedence group specifies the precedence of an
operator when used in an operation that includes optional chaining. When
set to =true=, an operator in the corresponding precedence group uses
the same grouping rules during optional chaining as the assignment
operators from the standard library. Otherwise, when set to =false= or
omitted, operators in the precedence group follows the same optional
chaining rules as operators that don't perform assignment.

Grammar of a precedence group declaration

precedence-group-declaration
→ =precedencegroup=
precedence-group-name
={=
precedence-group-attributes
_{opt} =}=

precedence-group-attributes
→
precedence-group-attribute
precedence-group-attributes
_{opt}

precedence-group-attribute
→
precedence-group-relation

precedence-group-attribute
→
precedence-group-assignment

precedence-group-attribute
→
precedence-group-associativity

precedence-group-relation
→ =higherThan= =:=
precedence-group-names

precedence-group-relation
→ =lowerThan= =:=
precedence-group-names

precedence-group-assignment
→ =assignment= =:=
boolean-literal

precedence-group-associativity
→ =associativity= =:= =left=

precedence-group-associativity
→ =associativity= =:= =right=

precedence-group-associativity
→ =associativity= =:= =none=

precedence-group-names
→
precedence-group-name
|
precedence-group-name
=,=
precedence-group-names

precedence-group-name
→
identifier


** Declaration Modifiers

/Declaration modifiers/ are keywords or context-sensitive keywords that
modify the behavior or meaning of a declaration. You specify a
declaration modifier by writing the appropriate keyword or
context-sensitive keyword between a declaration's attributes (if any)
and the keyword that introduces the declaration.

#+FINDEX: class
- =class= :: Apply this modifier to a member of a class to indicate that
  the member is a member of the class itself, rather than a member of
  instances of the class. Members of a superclass that have this
  modifier and don't have the =final= modifier can be overridden by
  subclasses.

#+FINDEX: dynamic
- =dynamic= :: Apply this modifier to any member of a class that can be
  represented by Objective-C. When you mark a member declaration with
  the =dynamic= modifier, access to that member is always dynamically
  dispatched using the Objective-C runtime. Access to that member is
  never inlined or devirtualized by the compiler.

  Because declarations marked with the =dynamic= modifier are dispatched
  using the Objective-C runtime, they must be marked with the =objc=
  attribute.

#+FINDEX: final
- =final= :: Apply this modifier to a class or to a property, method, or
  subscript member of a class. It's applied to a class to indicate that
  the class can't be subclassed. It's applied to a property, method, or
  subscript of a class to indicate that a class member can't be
  overridden in any subclass. For an example of how to use the =final=
  attribute, see [[info:swift#Preventing Overrides][Preventing
  Overrides]].

#+FINDEX: lazy
- =lazy= :: Apply this modifier to a stored variable property of a class
  or structure to indicate that the property's initial value is
  calculated and stored at most once, when the property is first
  accessed. For an example of how to use the =lazy= modifier, see
  [[info:swift#Lazy Stored Properties][Lazy Stored Properties]].

#+FINDEX: optional
- =optional= :: Apply this modifier to a protocol's property, method, or
  subscript members to indicate that a conforming type isn't required to
  implement those members.

  You can apply the =optional= modifier only to protocols that are
  marked with the =objc= attribute. As a result, only class types can
  adopt and conform to a protocol that contains optional member
  requirements. For more information about how to use the =optional=
  modifier and for guidance about how to access optional protocol
  members---for example, when you're not sure whether a conforming type
  implements them---see
  [[info:swift#Optional Protocol Requirements][Optional Protocol
  Requirements]].

#+FINDEX: required
- =required= :: Apply this modifier to a designated or convenience
  initializer of a class to indicate that every subclass must implement
  that initializer. The subclass's implementation of that initializer
  must also be marked with the =required= modifier.

#+FINDEX: static
- =static= :: Apply this modifier to a member of a structure, class,
  enumeration, or protocol to indicate that the member is a member of
  the type, rather than a member of instances of that type. In the scope
  of a class declaration, writing the =static= modifier on a member
  declaration has the same effect as writing the =class= and =final=
  modifiers on that member declaration. However, constant type
  properties of a class are an exception: =static= has its normal,
  nonclass meaning there because you can't write =class= or =final= on
  those declarations.

#+FINDEX: unowned
- =unowned= :: Apply this modifier to a stored variable, constant, or
  stored property to indicate that the variable or property has an
  unowned reference to the object stored as its value. If you try to
  access the variable or property after the object has been deallocated,
  a runtime error is raised. Like a weak reference, the type of the
  property or value must be a class type; unlike a weak reference, the
  type is non-optional. For an example and more information about the
  =unowned= modifier, see
  [[info:swift#Unowned References][Unowned
  References]].

- =unowned(safe)= :: An explicit spelling of =unowned=.

- =unowned(unsafe)= :: Apply this modifier to a stored variable,
  constant, or stored property to indicate that the variable or property
  has an unowned reference to the object stored as its value. If you try
  to access the variable or property after the object has been
  deallocated, you'll access the memory at the location where the object
  used to be, which is a memory-unsafe operation. Like a weak reference,
  the type of the property or value must be a class type; unlike a weak
  reference, the type is non-optional. For an example and more
  information about the =unowned= modifier, see
  [[info:swift#Unowned References][Unowned
  References]].

#+FINDEX: weak
- =weak= :: Apply this modifier to a stored variable or stored variable
  property to indicate that the variable or property has a weak
  reference to the object stored as its value. The type of the variable
  or property must be an optional class type. If you access the variable
  or property after the object has been deallocated, its value is =nil=.
  For an example and more information about the =weak= modifier, see
  [[info:swift#Weak References][Weak
  References]].


*** Access Control Levels

Swift provides five levels of access control: open, public, internal,
file private, and private. You can mark a declaration with one of the
access-level modifiers below to specify the declaration's access level.
Access control is discussed in detail in
[[info:swift#Access Control][Access Control]].

#+FINDEX: open

- =open= :: Apply this modifier to a declaration to indicate the
  declaration can be accessed and subclassed by code in the same module
  as the declaration. Declarations marked with the =open= access-level
  modifier can also be accessed and subclassed by code in a module that
  imports the module that contains that declaration.

#+FINDEX: public

- =public= :: Apply this modifier to a declaration to indicate the
  declaration can be accessed and subclassed by code in the same module
  as the declaration. Declarations marked with the =public= access-level
  modifier can also be accessed (but not subclassed) by code in a module
  that imports the module that contains that declaration.

#+FINDEX: internal

- =internal= :: Apply this modifier to a declaration to indicate the
  declaration can be accessed only by code in the same module as the
  declaration. By default, most declarations are implicitly marked with
  the =internal= access-level modifier.

#+FINDEX: fileprivate

- =fileprivate= :: Apply this modifier to a declaration to indicate the
  declaration can be accessed only by code in the same source file as
  the declaration.

#+FINDEX: private

- =private= :: Apply this modifier to a declaration to indicate the
  declaration can be accessed only by code within the declaration's
  immediate enclosing scope.

For the purpose of access control, extensions to the same type that are
in the same file share an access-control scope. If the type they extend
is also in the same file, they share the type's access-control scope.
Private members declared in the type's declaration can be accessed from
extensions, and private members declared in one extension can be
accessed from other extensions and from the type's declaration.

Each access-level modifier above optionally accepts a single argument,
which consists of the =set= keyword enclosed in parentheses (for
example, =private(set)=). Use this form of an access-level modifier when
you want to specify an access level for the setter of a variable or
subscript that's less than or equal to the access level of the variable
or subscript itself, as discussed in
[[info:swift#Getters and Setters][Getters and Setters]].

Grammar of a declaration modifier

declaration-modifier
→ =class= | =convenience= | =dynamic= | =final= | =infix= | =lazy= |
=optional= | =override= | =postfix= | =prefix= | =required= | =static= |
=unowned= | =unowned= =(= =safe= =)= | =unowned= =(= =unsafe= =)= |
=weak=

declaration-modifier
→
access-level-modifier

declaration-modifier
→
mutation-modifier

declaration-modifiers
→
declaration-modifier
declaration-modifiers
_{opt}

access-level-modifier
→ =private= | =private= =(= =set= =)=

access-level-modifier
→ =fileprivate= | =fileprivate= =(= =set= =)=

access-level-modifier
→ =internal= | =internal= =(= =set= =)=

access-level-modifier
→ =public= | =public= =(= =set= =)=

access-level-modifier
→ =open= | =open= =(= =set= =)=

mutation-modifier →
=mutating= | =nonmutating=

* Attributes

There are two kinds of attributes in Swift---those that apply to
declarations and those that apply to types. An attribute provides
additional information about the declaration or type. For example, the
=discardableResult= attribute on a function declaration indicates that,
although the function returns a value, the compiler shouldn't generate a
warning if the return value is unused.

You specify an attribute by writing the =@= symbol followed by the
attribute's name and any arguments that the attribute accepts:

#+BEGIN_SRC swift
  @attribute name
  @attribute name(attribute arguments)
#+END_SRC   

Some declaration attributes accept arguments that specify more
information about the attribute and how it applies to a particular
declaration. These /attribute arguments/ are enclosed in parentheses,
and their format is defined by the attribute they belong to.


** Declaration Attributes

You can apply a declaration attribute to declarations only.


*** available

Apply this attribute to indicate a declaration's life cycle relative to
certain Swift language versions or certain platforms and operating
system versions.

The =available= attribute always appears with a list of two or more
comma-separated attribute arguments. These arguments begin with one of
the following platform or language names:

- =iOS=

- =iOSApplicationExtension=

- =macOS=

- =macOSApplicationExtension=

- =macCatalyst=

- =macCatalystApplicationExtension=

- =watchOS=

- =watchOSApplicationExtension=

- =tvOS=

- =tvOSApplicationExtension=

- =swift=

You can also use an asterisk (=*=) to indicate the availability of the
declaration on all of the platform names listed above. An =available=
attribute that specifies availability using a Swift version number can't
use the asterisk.

The remaining arguments can appear in any order and specify additional
information about the declaration's life cycle, including important
milestones.

- The =unavailable= argument indicates that the declaration isn't
  available on the specified platform. This argument can't be used when
  specifying Swift version availability.

- The =introduced= argument indicates the first version of the specified
  platform or language in which the declaration was introduced. It has
  the following form:

  #+BEGIN_SRC swift
    introduced: version number
  #+END_SRC     

  The /version number/ consists of one to three positive integers,
  separated by periods.

- The =deprecated= argument indicates the first version of the specified
  platform or language in which the declaration was deprecated. It has
  the following form:

  #+BEGIN_SRC swift
    deprecated: version number
  #+END_SRC

  The optional /version number/ consists of one to three positive
  integers, separated by periods. Omitting the version number indicates
  that the declaration is currently deprecated, without giving any
  information about when the deprecation occurred. If you omit the
  version number, omit the colon (=:=) as well.

- The =obsoleted= argument indicates the first version of the specified
  platform or language in which the declaration was obsoleted. When a
  declaration is obsoleted, it's removed from the specified platform or
  language and can no longer be used. It has the following form:

  #+BEGIN_SRC swift
    obsoleted: version number
  #+END_SRC     

  The /version number/ consists of one to three positive integers,
  separated by periods.

- The =message= argument provides a textual message that the compiler
  displays when emitting a warning or error about the use of a
  deprecated or obsoleted declaration. It has the following form:

  #+BEGIN_SRC swift
    message: message
  #+END_SRC     

  The /message/ consists of a string literal.

- The =renamed= argument provides a textual message that indicates the
  new name for a declaration that's been renamed. The compiler displays
  the new name when emitting an error about the use of a renamed
  declaration. It has the following form:

  #+BEGIN_SRC swift
    renamed: new name
  #+END_SRC     

  The /new name/ consists of a string literal.

  You can apply the =available= attribute with the =renamed= and
  =unavailable= arguments to a type alias declaration, as shown below,
  to indicate that the name of a declaration changed between releases of
  a framework or library. This combination results in a compile-time
  error that the declaration has been renamed.

  #+BEGIN_SRC swift
    // First release
    protocol MyProtocol {
        // protocol definition
    }

    // Subsequent release renames MyProtocol
    protocol MyRenamedProtocol {
        // protocol definition
    }

    @available(*, unavailable, renamed: "MyRenamedProtocol")
    typealias MyProtocol = MyRenamedProtocol
  #+END_SRC

You can apply multiple =available= attributes on a single declaration to
specify the declaration's availability on different platforms and
different versions of Swift. The declaration that the =available=
attribute applies to is ignored if the attribute specifies a platform or
language version that doesn't match the current target. If you use
multiple =available= attributes, the effective availability is the
combination of the platform and Swift availabilities.

If an =available= attribute only specifies an =introduced= argument in
addition to a platform or language name argument, you can use the
following shorthand syntax instead:

#+BEGIN_SRC swift
  @available(platform name version number, *)
  @available(swift version number)
#+END_SRC   

The shorthand syntax for =available= attributes concisely expresses
availability for multiple platforms. Although the two forms are
functionally equivalent, the shorthand form is preferred whenever
possible.

#+BEGIN_SRC swift
  @available(iOS 10.0, macOS 10.12, *)
  class MyClass {
      // class definition
  }
#+END_SRC   

An =available= attribute that specifies availability using a Swift
version number can't additionally specify a declaration's platform
availability. Instead, use separate =available= attributes to specify a
Swift version availability and one or more platform availabilities.

#+BEGIN_SRC swift
  @available(swift 3.0.2)
  @available(macOS 10.12, *)
  struct MyStruct {
      // struct definition
  }
#+END_SRC

*** discardableResult

#+FINDEX: @@discardableResult

Apply this attribute to a function or method declaration to suppress the
compiler warning when the function or method that returns a value is
called without using its result.


*** dynamicCallable

#+FINDEX: @@dynamicCallable

Apply this attribute to a class, structure, enumeration, or protocol to
treat instances of the type as callable functions. The type must
implement either a =dynamicallyCall(withArguments:)= method, a
=dynamicallyCall(withKeywordArguments:)= method, or both.

You can call an instance of a dynamically callable type as if it's a
function that takes any number of arguments.

#+BEGIN_SRC swift
  @dynamicCallable
  struct TelephoneExchange {
      func dynamicallyCall(withArguments phoneNumber: [Int]) {
          if phoneNumber == [4, 1, 1] {
              print("Get Swift help on forums.swift.org")
          } else {
              print("Unrecognized number")
          }
      }
  }

  let dial = TelephoneExchange()

  // Use a dynamic method call.
  dial(4, 1, 1)
  // Prints "Get Swift help on forums.swift.org"

  dial(8, 6, 7, 5, 3, 0, 9)
  // Prints "Unrecognized number"

  // Call the underlying method directly.
  dial.dynamicallyCall(withArguments: [4, 1, 1])
#+END_SRC    

The declaration of the =dynamicallyCall(withArguments:)= method must
have a single parameter that conforms to the
[[https://developer.apple.com/documentation/swift/expressiblebyarrayliteral][=ExpressibleByArrayLiteral=]]
[https://developer.apple.com/documentation/swift/expressiblebyarrayliteral]
protocol---like =[Int]= in the example above. The return type can be any
type.

You can include labels in a dynamic method call if you implement the
=dynamicallyCall(withKeywordArguments:)= method.

#+BEGIN_SRC swift
  @dynamicCallable
  struct Repeater {
      func dynamicallyCall(withKeywordArguments pairs:
                             KeyValuePairs<String, Int>) -> String {
          return pairs
            .map { label, count in
                repeatElement(label, count: count).joined(separator: " ")
            }
            .joined(separator: "\n")
      }
  }

  let repeatLabels = Repeater()
  print(repeatLabels(a: 1, b: 2, c: 3, b: 2, a: 1))
  // a
  // b b
  // c c c
  // b b
  // a
#+END_SRC    

The declaration of the =dynamicallyCall(withKeywordArguments:)= method
must have a single parameter that conforms to the
[[https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral][=ExpressibleByDictionaryLiteral=]]
[https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral]
protocol, and the return type can be any type. The parameter's
[[https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key][=Key=]]
[https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral/2294108-key]
must be
[[https://developer.apple.com/documentation/swift/expressiblebystringliteral][=ExpressibleByStringLiteral=]]
[https://developer.apple.com/documentation/swift/expressiblebystringliteral].
The previous example uses
[[https://developer.apple.com/documentation/swift/keyvaluepairs][=KeyValuePairs=]]
[https://developer.apple.com/documentation/swift/keyvaluepairs] as the
parameter type so that callers can include duplicate parameter
labels---=a= and =b= appear multiple times in the call to =repeat=.

If you implement both =dynamicallyCall= methods,
=dynamicallyCall(withKeywordArguments:)= is called when the method call
includes keyword arguments. In all other cases,
=dynamicallyCall(withArguments:)= is called.

You can only call a dynamically callable instance with arguments and a
return value that match the types you specify in one of your
=dynamicallyCall= method implementations. The call in the following
example doesn't compile because there isn't an implementation of
=dynamicallyCall(withArguments:)= that takes
=KeyValuePairs<String, String>=.

#+BEGIN_SRC swift
  repeatLabels(a: "four") // Error
#+END_SRC

*** dynamicMemberLookup

#+FINDEX: @@dynamicMemberLookup

Apply this attribute to a class, structure, enumeration, or protocol to
enable members to be looked up by name at runtime. The type must
implement a =subscript(dynamicMemberLookup:)= subscript.

In an explicit member expression, if there isn't a corresponding
declaration for the named member, the expression is understood as a call
to the type's =subscript(dynamicMemberLookup:)= subscript, passing
information about the member as the argument. The subscript can accept a
parameter that's either a key path or a member name; if you implement
both subscripts, the subscript that takes key path argument is used.

An implementation of =subscript(dynamicMemberLookup:)= can accept key
paths using an argument of type
[[https://developer.apple.com/documentation/swift/keypath][=KeyPath=]]
[https://developer.apple.com/documentation/swift/keypath],
[[https://developer.apple.com/documentation/swift/writablekeypath][=WritableKeyPath=]]
[https://developer.apple.com/documentation/swift/writablekeypath], or
[[https://developer.apple.com/documentation/swift/referencewritablekeypath][=ReferenceWritableKeyPath=]]
[https://developer.apple.com/documentation/swift/referencewritablekeypath].
It can accept member names using an argument of a type that conforms to
the
[[https://developer.apple.com/documentation/swift/expressiblebystringliteral][=ExpressibleByStringLiteral=]]
[https://developer.apple.com/documentation/swift/expressiblebystringliteral]
protocol---in most cases, =String=. The subscript's return type can be
any type.

Dynamic member lookup by member name can be used to create a wrapper
type around data that can't be type checked at compile time, such as
when bridging data from other languages into Swift. For example:

#+BEGIN_SRC swift
  @dynamicMemberLookup
  struct DynamicStruct {
      let dictionary = ["someDynamicMember": 325,
                        "someOtherMember": 787]
      subscript(dynamicMember member: String) -> Int {
          return dictionary[member] ?? 1054
      }
  }
  let s = DynamicStruct()

  // Use dynamic member lookup.
  let dynamic = s.someDynamicMember
  print(dynamic)
  // Prints "325"

  // Call the underlying subscript directly.
  let equivalent = s[dynamicMember: "someDynamicMember"]
  print(dynamic == equivalent)
  // Prints "true"
#+END_SRC    

Dynamic member lookup by key path can be used to implement a wrapper
type in a way that supports compile-time type checking. For example:

#+BEGIN_SRC swift
  struct Point { var x, y: Int }

  @dynamicMemberLookup
  struct PassthroughWrapper<Value> {
      var value: Value
      subscript<T>(dynamicMember member: KeyPath<Value, T>) -> T {
          get { return value[keyPath: member] }
      }
  }

  let point = Point(x: 381, y: 431)
  let wrapper = PassthroughWrapper(value: point)
  print(wrapper.x)
#+END_SRC    

*** frozen

#+FINDEX: @@frozen

Apply this attribute to a structure or enumeration declaration to
restrict the kinds of changes you can make to the type. This attribute
is allowed only when compiling in library evolution mode. Future
versions of the library can't change the declaration by adding,
removing, or reordering an enumeration's cases or a structure's stored
instance properties. These changes are allowed on nonfrozen types, but
they break ABI compatibility for frozen types.

Note

When the compiler isn't in library evolution mode, all structures and
enumerations are implicitly frozen, and this attribute is ignored.

In library evolution mode, code that interacts with members of nonfrozen
structures and enumerations is compiled in a way that allows it to
continue working without recompiling even if a future version of the
library adds, removes, or reorders some of that type's members. The
compiler makes this possible using techniques like looking up
information at runtime and adding a layer of indirection. Marking a
structure or enumeration as frozen gives up this flexibility to gain
performance: Future versions of the library can make only limited
changes to the type, but the compiler can make additional optimizations
in code that interacts with the type's members.

Frozen types, the types of the stored properties of frozen structures,
and the associated values of frozen enumeration cases must be public or
marked with the =usableFromInline= attribute. The properties of a frozen
structure can't have property observers, and expressions that provide
the initial value for stored instance properties must follow the same
restrictions as inlinable functions, as discussed in
[[inlinable][inlinable]].

To enable library evolution mode on the command line, pass the
=-enable-library-evolution= option to the Swift compiler. To enable it
in Xcode, set the “Build Libraries for Distribution” build setting
(=BUILD_LIBRARY_FOR_DISTRIBUTION=) to Yes, as described in
[[https://help.apple.com/xcode/mac/current/#/dev04b3a04ba][Xcode Help]]
[https://help.apple.com/xcode/mac/current/#/dev04b3a04ba].

A switch statement over a frozen enumeration doesn't require a =default=
case, as discussed in [[info:swift-reference#Switching %Over %Future Enumeration Cases][Switching Over Future
Enumeration Cases]]. Including a =default= or =@unknown default= case
when switching over a frozen enumeration produces a warning because that
code is never executed.

*** GKInspectable

#+FINDEX: @@GKInspectable

Apply this attribute to expose a custom GameplayKit component property
to the SpriteKit editor UI. Applying this attribute also implies the
=objc= attribute.

*** inlinable

#+FINDEX: @@inlinable

Apply this attribute to a function, method, computed property,
subscript, convenience initializer, or deinitializer declaration to
expose that declaration's implementation as part of the module's public
interface. The compiler is allowed to replace calls to an inlinable
symbol with a copy of the symbol's implementation at the call site.

Inlinable code can interact with =public= symbols declared in any
module, and it can interact with =internal= symbols declared in the same
module that are marked with the =usableFromInline= attribute. Inlinable
code can't interact with =private= or =fileprivate= symbols.

This attribute can't be applied to declarations that are nested inside
functions or to =fileprivate= or =private= declarations. Functions and
closures that are defined inside an inlinable function are implicitly
inlinable, even though they can't be marked with this attribute.

*** main

#+FINDEX: @@main

Apply this attribute to a structure, class, or enumeration declaration
to indicate that it contains the top-level entry point for program flow.
The type must provide a =main= type function that doesn't take any
arguments and returns =Void=. For example:

#+BEGIN_SRC swift
  @main
  struct MyTopLevel {
      static func main() {
          // Top-level code goes here
      }
  }
#+END_SRC   

Another way to describe the requirements of the =main= attribute is that
the type you write this attribute on must satisfy the same requirements
as types that conform to the following hypothetical protocol:

#+BEGIN_SRC swift
  protocol ProvidesMain {
      static func main() throws
  }
#+END_SRC   

The Swift code you compile to make an executable can contain at most one
top-level entry point, as discussed in
[[Top-Level Code][Top-Level Code]].


*** nonobjc

#+FINDEX: @@nonobjc

Apply this attribute to a method, property, subscript, or initializer
declaration to suppress an implicit =objc= attribute. The =nonobjc=
attribute tells the compiler to make the declaration unavailable in
Objective-C code, even though it's possible to represent it in
Objective-C.

Applying this attribute to an extension has the same effect as applying
it to every member of that extension that isn't explicitly marked with
the =objc= attribute.

You use the =nonobjc= attribute to resolve circularity for bridging
methods in a class marked with the =objc= attribute, and to allow
overloading of methods and initializers in a class marked with the
=objc= attribute.

A method marked with the =nonobjc= attribute can't override a method
marked with the =objc= attribute. However, a method marked with the
=objc= attribute can override a method marked with the =nonobjc=
attribute. Similarly, a method marked with the =nonobjc= attribute can't
satisfy a protocol requirement for a method marked with the =objc=
attribute.


*** NSApplicationMain

#+FINDEX: @@NSApplicationMain

Apply this attribute to a class to indicate that it's the application
delegate. Using this attribute is equivalent to calling the
=NSApplicationMain(_:_:)= function.

If you don't use this attribute, supply a =main.swift= file with code at
the top level that calls the =NSApplicationMain(_:_:)= function as
follows:

#+BEGIN_SRC swift
  import AppKit
  NSApplicationMain(CommandLine.argc, CommandLine.unsafeArgv)
#+END_SRC   


*** NSCopying

#+FINDEX: @@NSCopying

Apply this attribute to a stored variable property of a class. This
attribute causes the property's setter to be synthesized with a /copy/
of the property's value---returned by the =copyWithZone(_:)=
method---instead of the value of the property itself. The type of the
property must conform to the =NSCopying= protocol.

The =NSCopying= attribute behaves in a way similar to the Objective-C
=copy= property attribute.


*** NSManaged

#+FINDEX: @@dynamicCallable

Apply this attribute to an instance method or stored variable property
of a class that inherits from =NSManagedObject= to indicate that Core
Data dynamically provides its implementation at runtime, based on the
associated entity description. For a property marked with the
=NSManaged= attribute, Core Data also provides the storage at runtime.
Applying this attribute also implies the =objc= attribute.


*** objc

#+FINDEX: @@objc

Apply this attribute to any declaration that can be represented in
Objective-C---for example, nonnested classes, protocols, nongeneric
enumerations (constrained to integer raw-value types), properties and
methods (including getters and setters) of classes, protocols and
optional members of a protocol, initializers, and subscripts. The =objc=
attribute tells the compiler that a declaration is available to use in
Objective-C code.

Applying this attribute to an extension has the same effect as applying
it to every member of that extension that isn't explicitly marked with
the =nonobjc= attribute.

The compiler implicitly adds the =objc= attribute to subclasses of any
class defined in Objective-C. However, the subclass must not be generic,
and must not inherit from any generic classes. You can explicitly add
the =objc= attribute to a subclass that meets these criteria, to specify
its Objective-C name as discussed below. Protocols that are marked with
the =objc= attribute can't inherit from protocols that aren't marked
with this attribute.

The =objc= attribute is also implicitly added in the following cases:

- The declaration is an override in a subclass, and the superclass's
  declaration has the =objc= attribute.

- The declaration satisfies a requirement from a protocol that has the
  =objc= attribute.

- The declaration has the =IBAction=, =IBSegueAction=, =IBOutlet=,
  =IBDesignable=, =IBInspectable=, =NSManaged=, or =GKInspectable=
  attribute.

If you apply the =objc= attribute to an enumeration, each enumeration
case is exposed to Objective-C code as the concatenation of the
enumeration name and the case name. The first letter of the case name is
capitalized. For example, a case named =venus= in a Swift =Planet=
enumeration is exposed to Objective-C code as a case named
=PlanetVenus=.

The =objc= attribute optionally accepts a single attribute argument,
which consists of an identifier. The identifier specifies the name to be
exposed to Objective-C for the entity that the =objc= attribute applies
to. You can use this argument to name classes, enumerations, enumeration
cases, protocols, methods, getters, setters, and initializers. If you
specify the Objective-C name for a class, protocol, or enumeration,
include a three-letter prefix on the name, as described in
[[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1][Conventions]]
[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Conventions/Conventions.html#//apple_ref/doc/uid/TP40011210-CH10-SW1]
in
[[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210][Programming
with Objective-C]]
[https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011210].
The example below exposes the getter for the =enabled= property of the
=ExampleClass= to Objective-C code as =isEnabled= rather than just as
the name of the property itself.

#+BEGIN_SRC swift
  class ExampleClass: NSObject {
      @objc var enabled: Bool {
          @objc(isEnabled) get {
              // Return the appropriate value
          }
      }
  }
#+END_SRC   

For more information, see
[[https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c][Importing
Swift into Objective-C]]
[https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis/importing_swift_into_objective-c].

Note

The argument to the =objc= attribute can also change the runtime name
for that declaration. You use the runtime name when calling functions
that interact with the Objective-C runtime, like
[[https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring][=NSClassFromString=]]
[https://developer.apple.com/documentation/foundation/1395135-nsclassfromstring],
and when specifying class names in an app's Info.plist file. If you
specify a name by passing an argument, that name is used as the name in
Objective-C code and as the runtime name. If you omit the argument, the
name used in Objective-C code matches the name in Swift code, and the
runtime name follows the normal Swift compiler convention of name
mangling.

*** objcMembers

#+FINDEX: @@objcMembers

Apply this attribute to a class declaration, to implicitly apply the
=objc= attribute to all Objective-C compatible members of the class, its
extensions, its subclasses, and all of the extensions of its subclasses.

Most code should use the =objc= attribute instead, to expose only the
declarations that are needed. If you need to expose many declarations,
you can group them in an extension that has the =objc= attribute. The
=objcMembers= attribute is a convenience for libraries that make heavy
use of the introspection facilities of the Objective-C runtime. Applying
the =objc= attribute when it isn't needed can increase your binary size
and adversely affect performance.

*** propertyWrapper

#+FINDEX: @@propertyWrapper

Apply this attribute to a class, structure, or enumeration declaration
to use that type as a property wrapper. When you apply this attribute to
a type, you create a custom attribute with the same name as the type.
Apply that new attribute to a property of a class, structure, or
enumeration to wrap access to the property through an instance of the
wrapper type. Local and global variables can't use property wrappers.

The wrapper must define a =wrappedValue= instance property. The /wrapped
value/ of the property is the value that the getter and setter for this
property expose. In most cases, =wrappedValue= is a computed value, but
it can be a stored value instead. The wrapper is responsible for
defining and managing any underlying storage needed by its wrapped
value. The compiler synthesizes storage for the instance of the wrapper
type by prefixing the name of the wrapped property with an underscore
(=_=)---for example, the wrapper for =someProperty= is stored as
=_someProperty=. The synthesized storage for the wrapper has an access
control level of =private=.

A property that has a property wrapper can include =willSet= and
=didSet= blocks, but it can't override the compiler-synthesized =get= or
=set= blocks.

Swift provides two forms of syntactic sugar for initialization of a
property wrapper. You can use assignment syntax in the definition of a
wrapped value to pass the expression on the right-hand side of the
assignment as the argument to the =wrappedValue= parameter of the
property wrapper's initializer. You can also provide arguments to the
attribute when you apply it to a property, and those arguments are
passed to the property wrapper's initializer. For example, in the code
below, =SomeStruct= calls each of the initializers that =SomeWrapper=
defines.

#+BEGIN_SRC swift
  @propertyWrapper
  struct SomeWrapper {
      var wrappedValue: Int
      var someValue: Double
      init() {
          self.wrappedValue = 100
          self.someValue = 12.3
      }
      init(wrappedValue: Int) {
          self.wrappedValue = wrappedValue
          self.someValue = 45.6
      }
      init(wrappedValue value: Int, custom: Double) {
          self.wrappedValue = value
          self.someValue = custom
      }
  }

  struct SomeStruct {
      // Uses init()
      @SomeWrapper var a: Int

      // Uses init(wrappedValue:)
      @SomeWrapper var b = 10

      // Both use init(wrappedValue:custom:)
      @SomeWrapper(custom: 98.7) var c = 30
      @SomeWrapper(wrappedValue: 30, custom: 98.7) var d
  }
#+END_SRC    

The /projected value/ for a wrapped property is a second value that a
property wrapper can use to expose additional functionality. The author
of a property wrapper type is responsible for determining the meaning of
its projected value and defining the interface that the projected value
exposes. To project a value from a property wrapper, define a
=projectedValue= instance property on the wrapper type. The compiler
synthesizes an identifier for the projected value by prefixing the name
of the wrapped property with a dollar sign (=$=)---for example, the
projected value for =someProperty= is =$someProperty=. The projected
value has the same access control level as the original wrapped
property.

#+BEGIN_SRC swift
  @propertyWrapper
  struct WrapperWithProjection {
      var wrappedValue: Int
      var projectedValue: SomeProjection {
          return SomeProjection(wrapper: self)
      }
  }
  struct SomeProjection {
      var wrapper: WrapperWithProjection
  }

  struct SomeStruct {
      @WrapperWithProjection var x = 123
  }
  let s = SomeStruct()
  s.x // Int value
  s.$x // SomeProjection value
  s.$x.wrapper // WrapperWithProjection value
#+END_SRC    

*** resultBuilder

#+FINDEX: @@resultBuilder

Apply this attribute to a class, structure, enumeration to use that type
as a result builder. A /result builder/ is a type that builds a nested
data structure step by step. You use result builders to implement a
domain-specific language (DSL) for creating nested data structures in a
natural, declarative way. For an example of how to use the
=resultBuilder= attribute, see
[[info:swift#Result Builders][Result Builders]].

**** Result-Building Methods
A result builder implements static methods described below. Because all
of the result builder's functionality is exposed through static methods,
you don't ever initialize an instance of that type. The =buildBlock(_:)=
method is required; the other methods---which enable additional
functionality in the DSL---are optional. The declaration of a result
builder type doesn't actually have to include any protocol conformance.

The description of the static methods uses three types as placeholders.
The type =Expression= is a placeholder for the type of the result
builder's input, =Component= is a placeholder for the type of a partial
result, and =FinalResult= is a placeholder for the type of the result
that the result builder produces. You replace these types with the
actual types that your result builder uses. If your result-building
methods don't specify a type for =Expression= or =FinalResult=, they
default to being the same as =Component=.

The result-building methods are as follows:

- =static func buildBlock(_ components: Component...) -> Component= :: Combines
  an array of partial results into a single partial result. A result
  builder must implement this method.

- =static func buildOptional(_ component: Component?) -> Component= :: Builds
  a partial result from a partial result that can be =nil=. Implement
  this method to support =if= statements that don't include an =else=
  clause.

- =static func buildEither(first: Component) -> Component= :: Builds a
  partial result whose value varies depending on some condition.
  Implement both this method and =buildEither(second:)= to support
  =switch= statements and =if= statements that include an =else= clause.

- =static func buildEither(second: Component) -> Component= :: Builds a
  partial result whose value varies depending on some condition.
  Implement both this method and =buildEither(first:)= to support
  =switch= statements and =if= statements that include an =else= clause.

- =static func buildArray(_ components: [Component]) -> Component= :: Builds
  a partial result from an array of partial results. Implement this
  method to support =for= loops.

- =static func buildExpression(_ expression: Expression) -> Component= :: Builds
  a partial result from an expression. You can implement this method to
  perform preprocessing---for example, converting expressions to an
  internal type---or to provide additional information for type
  inference at use sites.

- =static func buildFinalResult(_ component: Component) -> FinalResult= :: Builds
  a final result from a partial result. You can implement this method as
  part of a result builder that uses a different type for partial and
  final results, or to perform other postprocessing on a result before
  returning it.

- =static func buildLimitedAvailability(_ component: Component) -> Component= :: Builds
  a partial result that propagates or erases type information outside a
  compiler-control statement that performs an availability check. You
  can use this to erase type information that varies between the
  conditional branches.

For example, the code below defines a simple result builder that builds
an array of integers. This code defines =Compontent= and =Expression= as
type aliases, to make it easier to match the examples below to the list
of methods above.

#+BEGIN_SRC swift
  @resultBuilder
  struct ArrayBuilder {
      typealias Component = [Int]
      typealias Expression = Int
      static func buildExpression(_ element: Expression) -> Component {
          return [element]
      }
      static func buildOptional(_ component: Component?) -> Component {
          guard let component = component else { return [] }
          return component
      }
      static func buildEither(first component: Component) -> Component {
          return component
      }
      static func buildEither(second component: Component) -> Component {
          return component
      }
      static func buildArray(_ components: [Component]) -> Component {
          return Array(components.joined())
      }
      static func buildBlock(_ components: Component...) -> Component {
          return Array(components.joined())
      }
  }
#+END_SRC    

**** Result Transformations

The following syntactic transformations are applied recursively to turn
code that uses result-builder syntax into code that calls the static
methods of the result builder type:

- If the result builder has a =buildExpression(_:)= method, each
  expression becomes a call to that method. This transformation is
  always first. For example, the following declarations are equivalent:

  #+BEGIN_SRC swift
    @ArrayBuilder var builderNumber: [Int] { 10 }
    var manualNumber = ArrayBuilder.buildExpression(10)
  #+END_SRC

- An assignment statement is transformed like an expression, but is
  understood to evaluate to =()=. You can define an overload of
  =buildExpression(_:)= that takes an argument of type =()= to handle
  assignments specifically.

- A branch statement that checks an availability condition becomes a
  call to the =buildLimitedAvailability(_:)= method. This transformation
  happens before the transformation into a call to
  =buildEither(first:)=, =buildEither(second:)=, or =buildOptional(_:)=.
  You use the =buildLimitedAvailability(_:)= method to erase type
  information that changes depending on which branch is taken. For
  example, the =buildEither(first:)= and =buildEither(second:)= methods
  below use a generic type that captures type information about both
  branches.

  #+BEGIN_SRC swift
    protocol Drawable {
        func draw() -> String
    }
    struct Text: Drawable {
        var content: String
        init(_ content: String) { self.content = content }
        func draw() -> String { return content }
    }
    struct Line<D: Drawable>: Drawable {
        var elements: [D]
        func draw() -> String {
            return elements.map { $0.draw() }.joined(separator: "")
        }
    }
    struct DrawEither<First: Drawable, Second: Drawable>: Drawable {
        var content: Drawable
        func draw() -> String { return content.draw() }
    }

    @resultBuilder
    struct DrawingBuilder {
        static func buildBlock<D: Drawable>(_ components: D...) -> Line<D>
        {
            return Line(elements: components)
        }
        static func buildEither<First, Second>(first: First)
          -> DrawEither<First, Second> {
            return DrawEither(content: first)
        }
        static func buildEither<First, Second>(second: Second)
          -> DrawEither<First, Second> {
            return DrawEither(content: second)
        }
    }
  #+END_SRC

  However, this approach causes a problem in code that has availability
  checks:

  #+BEGIN_SRC swift
    @available(macOS 99, *)
    struct FutureText: Drawable {
        var content: String
        init(_ content: String) { self.content = content }
        func draw() -> String { return content }
    }
    @DrawingBuilder var brokenDrawing: Drawable {
        if #available(macOS 99, *) {
            FutureText("Inside.future") // Problem
        } else {
            Text("Inside.present")
        }
    }
    // The type of brokenDrawing is Line<DrawEither<Line<FutureText>, Line<Text>>>
  #+END_SRC

  In the code above, =FutureText= appears as part of the type of
  =brokenDrawing= because it's one of the types in the =DrawEither=
  generic type. This could cause your program to crash if =FutureText=
  isn't available at runtime, even in the case where that type is
  explicitly not being used.

  To solve this problem, implement a =buildLimitedAvailability(_:)=
  method to erase type information. For example, the code below builds
  an =AnyDrawable= value from its availability check.

  #+BEGIN_SRC swift
    struct AnyDrawable: Drawable {
        var content: Drawable
        func draw() -> String { return content.draw() }
    }
    extension DrawingBuilder {
        static func buildLimitedAvailability(_ content: Drawable) ->
          AnyDrawable {
            return AnyDrawable(content: content)
        }
    }


    @DrawingBuilder var typeErasedDrawing: Drawable {
        if #available(macOS 99, *) {
            FutureText("Inside.future")
        } else {
            Text("Inside.present")
        }
    }
    // The type of typeErasedDrawing is Line<DrawEither<AnyDrawable, Line<Text>>>
  #+END_SRC

- A branch statement becomes a series of nested calls to the
  =buildEither(first:)= and =buildEither(second:)= methods. The
  statements' conditions and cases are mapped onto the leaf nodes of a
  binary tree, and the statement becomes a nested call to the
  =buildEither= methods following the path to that leaf node from the
  root node.

  For example, if you write a switch statement that has three cases, the
  compiler uses a binary tree with three leaf nodes. Likewise, because
  the path from the root node to the second case is “second child” and
  then “first child”, that case becomes a nested call like
  =buildEither(first: buildEither(second: ... ))=. The following
  declarations are equivalent:

  #+BEGIN_SRC swift
    let someNumber = 19
    @ArrayBuilder var builderConditional: [Int] {
        if someNumber < 12 {
            31
        } else if someNumber == 19 {
            32
        } else {
            33
        }
    }

    var manualConditional: [Int]
    if someNumber < 12 {
        let partialResult = ArrayBuilder.buildExpression(31)
        let outerPartialResult = ArrayBuilder.buildEither(first: partialResult)
        manualConditional = ArrayBuilder.buildEither(first: outerPartialResult)
    } else if someNumber == 19 {
        let partialResult = ArrayBuilder.buildExpression(32)
        let outerPartialResult = ArrayBuilder.buildEither(second: partialResult)
        manualConditional = ArrayBuilder.buildEither(first: outerPartialResult)
    } else {
        let partialResult = ArrayBuilder.buildExpression(33)
        manualConditional = ArrayBuilder.buildEither(second: partialResult)
    }
  #+END_SRC    

- A branch statement that might not produce a value, like an =if=
  statement without an =else= clause, becomes a call to
  =buildOptional(_:)=. If the =if= statement's condition is satisfied,
  its code block is transformed and passed as the argument; otherwise,
  =buildOptional(_:)= is called with =nil= as its argument. For example,
  the following declarations are equivalent:

  #+BEGIN_SRC swift
    @ArrayBuilder var builderOptional: [Int] {
        if (someNumber % 2) == 1 { 20 }
    }

    var partialResult: [Int]? = nil
    if (someNumber % 2) == 1 {
        partialResult = ArrayBuilder.buildExpression(20)
    }
    var manualOptional = ArrayBuilder.buildOptional(partialResult)
  #+END_SRC   

- A code block or =do= statement becomes a call to the =buildBlock(_:)=
  method. Each of the statements inside of the block is transformed, one
  at a time, and they become the arguments to the =buildBlock(_:)=
  method. For example, the following declarations are equivalent:

  #+BEGIN_SRC swift
    @ArrayBuilder var builderBlock: [Int] {
        100
        200
        300
    }

    var manualBlock = ArrayBuilder.buildBlock(
      ArrayBuilder.buildExpression(100),
      ArrayBuilder.buildExpression(200),
      ArrayBuilder.buildExpression(300)
    )
  #+END_SRC

- A =for= loop becomes a temporary variable, a =for= loop, and call to
  the =buildArray(_:)= method. The new =for= loop iterates over the
  sequence and appends each partial result to that array. The temporary
  array is passed as the argument in the =buildArray(_:)= call. For
  example, the following declarations are equivalent:

  #+BEGIN_SRC swift
    @ArrayBuilder var builderArray: [Int] {
        for i in 5...7 {
            100 + i
        }
    }

    var temporary: \[\[Int\]\] = []
    for i in 5...7 {
        let partialResult = ArrayBuilder.buildExpression(100 + i)
        temporary.append(partialResult)
    }
    let manualArray = ArrayBuilder.buildArray(temporary)
  #+END_SRC    

- If the result builder has a =buildFinalResult(_:)= method, the final
  result becomes a call to that method. This transformation is always
  last.

Although the transformation behavior is described in terms of temporary
variables, using a result builder doesn't actually create any new
declarations that are visible from the rest of your code.

You can't use =break=, =continue=, =defer=, =guard=, or =return=
statements, =while= statements, or =do=-=catch= statements in the code
that a result builder transforms.

The transformation process doesn't change declarations in the code,
which lets you use temporary constants and variables to build up
expressions piece by piece. It also doesn't change =throw= statements,
compile-time diagnostic statements, or closures that contain a =return=
statement.

Whenever possible, transformations are coalesced. For example, the
expression =4 + 5 * 6= becomes =buildExpression(4 + 5 * 6)= rather
multiple calls to that function. Likewise, nested branch statements
become a single binary tree of calls to the =buildEither= methods.

**** Custom Result-Builder Attributes
Creating a result builder type creates a custom attribute with the same
name. You can apply that attribute in the following places:

- On a function declaration, the result builder builds the body of the
  function.

- On a variable or subscript declaration that includes a getter, the
  result builder builds the body of the getter.

- On a parameter in a function declaration, the result builder builds
  the body of a closure that's passed as the corresponding argument.

Applying a result builder attribute doesn't impact ABI compatibility.
Applying a result builder attribute to a parameter makes that attribute
part of the function's interface, which can effect source compatibility.

*** requires_stored_property_inits

#+FINDEX: @@requires_stored_property_inits

Apply this attribute to a class declaration to require all stored
properties within the class to provide default values as part of their
definitions. This attribute is inferred for any class that inherits from
=NSManagedObject=.


*** testable

#+FINDEX: @@testable

Apply this attribute to an =import= declaration to import that module
with changes to its access control that simplify testing the module's
code. Entities in the imported module that are marked with the
=internal= access-level modifier are imported as if they were declared
with the =public= access-level modifier. Classes and class members that
are marked with the =internal= or =public= access-level modifier are
imported as if they were declared with the =open= access-level modifier.
The imported module must be compiled with testing enabled.


*** UIApplicationMain

#+FINDEX: @@UIApplicationMain

Apply this attribute to a class to indicate that it's the application
delegate. Using this attribute is equivalent to calling the
=UIApplicationMain= function and passing this class's name as the name
of the delegate class.

If you don't use this attribute, supply a =main.swift= file with code at
the top level that calls the
[[https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain][=UIApplicationMain(_:_:_:_:)=]]
[https://developer.apple.com/documentation/uikit/1622933-uiapplicationmain]
function. For example, if your app uses a custom subclass of
=UIApplication= as its principal class, call the
=UIApplicationMain(_:_:_:_:)= function instead of using this attribute.


*** usableFromInline

#+FINDEX: @@usableFromInline

Apply this attribute to a function, method, computed property,
subscript, initializer, or deinitializer declaration to allow that
symbol to be used in inlinable code that's defined in the same module as
the declaration. The declaration must have the =internal= access level
modifier. A structure or class marked =usableFromInline= can use only
types that are public or =usableFromInline= for its properties. An
enumeration marked =usableFromInline= can use only types that are public
or =usableFromInline= for the raw values and associated values of its
cases.

Like the =public= access level modifier, this attribute exposes the
declaration as part of the module's public interface. Unlike =public=,
the compiler doesn't allow declarations marked with =usableFromInline=
to be referenced by name in code outside the module, even though the
declaration's symbol is exported. However, code outside the module might
still be able to interact with the declaration's symbol by using runtime
behavior.

Declarations marked with the =inlinable= attribute are implicitly usable
from inlinable code. Although either =inlinable= or =usableFromInline=
can be applied to =internal= declarations, applying both attributes is
an error.


*** warn_unqualified_access

#+FINDEX: @@warn_unqualified_access

Apply this attribute to a top-level function, instance method, or class
or static method to trigger warnings when that function or method is
used without a preceding qualifier, such as a module name, type name, or
instance variable or constant. Use this attribute to help discourage
ambiguity between functions with the same name that are accessible from
the same scope.

For example, the Swift standard library includes both a top-level
[[https://developer.apple.com/documentation/swift/1538339-min/][=min(_:_:)=]]
[https://developer.apple.com/documentation/swift/1538339-min/] function
and a
[[https://developer.apple.com/documentation/swift/sequence/1641174-min][=min()=]]
[https://developer.apple.com/documentation/swift/sequence/1641174-min]
method for sequences with comparable elements. The sequence method is
declared with the =warn_unqualified_access= attribute to help reduce
confusion when attempting to use one or the other from within a
=Sequence= extension.


*** Declaration Attributes Used by Interface Builder

Interface Builder attributes are declaration attributes used by
Interface Builder to synchronize with Xcode. Swift provides the
following Interface Builder attributes: =IBAction=, =IBSegueAction=,
=IBOutlet=, =IBDesignable=, and =IBInspectable=. These attributes are
conceptually the same as their Objective-C counterparts.

You apply the =IBOutlet= and =IBInspectable= attributes to property
declarations of a class. You apply the =IBAction= and =IBSegueAction=
attribute to method declarations of a class and the =IBDesignable=
attribute to class declarations.

Applying the =IBAction=, =IBSegueAction=, =IBOutlet=, =IBDesignable=, or
=IBInspectable= attribute also implies the =objc= attribute.


** Type Attributes

You can apply type attributes to types only.


*** autoclosure

Apply this attribute to delay the evaluation of an expression by
automatically wrapping that expression in a closure with no arguments.
You apply it to a parameter's type in a method or function declaration,
for a parameter whose type is a function type that takes no arguments
and that returns a value of the type of the expression. For an example
of how to use the =autoclosure= attribute, see
[[info:swift#Autoclosures][Autoclosures]] and
[[Function Type][Function Type]].


*** convention

Apply this attribute to the type of a function to indicate its calling
conventions.

The =convention= attribute always appears with one of the following
arguments:

- The =swift= argument indicates a Swift function reference. This is the
  standard calling convention for function values in Swift.

- The =block= argument indicates an Objective-C compatible block
  reference. The function value is represented as a reference to the
  block object, which is an =id=-compatible Objective-C object that
  embeds its invocation function within the object. The invocation
  function uses the C calling convention.

- The =c= argument indicates a C function reference. The function value
  carries no context and uses the C calling convention.

With a few exceptions, a function of any calling convention can be used
when a function any other calling convention is needed. A nongeneric
global function, a local function that doesn't capture any local
variables or a closure that doesn't capture any local variables can be
converted to the C calling convention. Other Swift functions can't be
converted to the C calling convention. A function with the Objective-C
block calling convention can't be converted to the C calling convention.


*** escaping

Apply this attribute to a parameter's type in a method or function
declaration to indicate that the parameter's value can be stored for
later execution. This means that the value is allowed to outlive the
lifetime of the call. Function type parameters with the =escaping= type
attribute require explicit use of =self.= for properties or methods. For
an example of how to use the =escaping= attribute, see
[[info:swift#Escaping Closures][Escaping Closures]].


** Switch Case Attributes

You can apply switch case attributes to switch cases only.


*** unknown

Apply this attribute to a switch case to indicate that it isn't expected
to be matched by any case of the enumeration that's known at the time
the code is compiled. For an example of how to use the =unknown=
attribute, see Switching Over Future
Enumeration Cases.

Grammar of an attribute

attribute → =@=
attribute-name
attribute-argument-clause
_{opt}

attribute-name →
identifier

attribute-argument-clause
→ =(=
balanced-tokens
_{opt} =)=

attributes →
attribute
attributes
_{opt}

balanced-tokens →
balanced-token
balanced-tokens
_{opt}

balanced-token → =(=
balanced-tokens
_{opt} =)=

balanced-token → =[=
balanced-tokens
_{opt} =]=

balanced-token → ={=
balanced-tokens
_{opt} =}=

balanced-token → Any
identifier, keyword, literal, or operator

balanced-token → Any
punctuation except =(=, =)=, =[=, =]=, ={=, or =}=

* Patterns

A /pattern/ represents the structure of a single value or a composite
value. For example, the structure of a tuple =(1, 2)= is a
comma-separated list of two elements. Because patterns represent the
structure of a value rather than any one particular value, you can match
them with a variety of values. For instance, the pattern =(x, y)=
matches the tuple =(1, 2)= and any other two-element tuple. In addition
to matching a pattern with a value, you can extract part or all of a
composite value and bind each part to a constant or variable name.

In Swift, there are two basic kinds of patterns: those that successfully
match any kind of value, and those that may fail to match a specified
value at runtime.

The first kind of pattern is used for destructuring values in simple
variable, constant, and optional bindings. These include wildcard
patterns, identifier patterns, and any value binding or tuple patterns
containing them. You can specify a type annotation for these patterns to
constrain them to match only values of a certain type.

The second kind of pattern is used for full pattern matching, where the
values you're trying to match against may not be there at runtime. These
include enumeration case patterns, optional patterns, expression
patterns, and type-casting patterns. You use these patterns in a case
label of a =switch= statement, a =catch= clause of a =do= statement, or
in the case condition of an =if=, =while=, =guard=, or =for=-=in=
statement.

Grammar of a pattern

pattern →
wildcard-pattern
type-annotation
_{opt}

pattern →
identifier-pattern
type-annotation
_{opt}

pattern →
value-binding-pattern

pattern →
tuple-pattern
type-annotation
_{opt}

pattern →
enum-case-pattern

pattern →
optional-pattern

pattern →
type-casting-pattern

pattern →
expression-pattern


** Wildcard Pattern

A /wildcard pattern/ matches and ignores any value and consists of an
underscore (=_=). Use a wildcard pattern when you don't care about the
values being matched against. For example, the following code iterates
through the closed range =1...3=, ignoring the current value of the
range on each iteration of the loop:

#+BEGIN_SRC swift
  for _ in 1...3 {
      // Do something three times.
  }
#+END_SRC   

Grammar of a wildcard pattern

wildcard-pattern → =_=


** Identifier Pattern

An /identifier pattern/ matches any value and binds the matched value to
a variable or constant name. For example, in the following constant
declaration, =someValue= is an identifier pattern that matches the value
=42= of type =Int=:

#+BEGIN_SRC swift
  let someValue = 42
#+END_SRC   

When the match succeeds, the value =42= is bound (assigned) to the
constant name =someValue=.

When the pattern on the left-hand side of a variable or constant
declaration is an identifier pattern, the identifier pattern is
implicitly a subpattern of a value-binding pattern.

Grammar of an identifier pattern

identifier-pattern →
identifier


** Value-Binding Pattern

A /value-binding pattern/ binds matched values to variable or constant
names. Value-binding patterns that bind a matched value to the name of a
constant begin with the =let= keyword; those that bind to the name of
variable begin with the =var= keyword.

Identifiers patterns within a value-binding pattern bind new named
variables or constants to their matching values. For example, you can
decompose the elements of a tuple and bind the value of each element to
a corresponding identifier pattern.

#+BEGIN_SRC swift
  let point = (3, 2)
  switch point {
      // Bind x and y to the elements of point.
  case let (x, y):
      print("The point is at (\(x), \(y)).")
  }
  // Prints "The point is at (3, 2)."
#+END_SRC   

In the example above, =let= distributes to each identifier pattern in
the tuple pattern =(x, y)=. Because of this behavior, the =switch= cases
=case let (x, y):= and =case (let x, let y):= match the same values.

Grammar of a value-binding pattern

value-binding-pattern →
=var= pattern |
=let= pattern


** Tuple Pattern

A /tuple pattern/ is a comma-separated list of zero or more patterns,
enclosed in parentheses. Tuple patterns match values of corresponding
tuple types.

You can constrain a tuple pattern to match certain kinds of tuple types
by using type annotations. For example, the tuple pattern
=(x, y): (Int, Int)= in the constant declaration
=let (x, y): (Int, Int) = (1, 2)= matches only tuple types in which both
elements are of type =Int=.

When a tuple pattern is used as the pattern in a =for=-=in= statement or
in a variable or constant declaration, it can contain only wildcard
patterns, identifier patterns, optional patterns, or other tuple
patterns that contain those. For example, the following code isn't valid
because the element =0= in the tuple pattern =(x, 0)= is an expression
pattern:

#+BEGIN_SRC swift
  let points = [(0, 0), (1, 0), (1, 1), (2, 0), (2, 1)]
  // This code isn't valid.
  for (x, 0) in points {
      /* ... */
  }
#+END_SRC   

The parentheses around a tuple pattern that contains a single element
have no effect. The pattern matches values of that single element's
type. For example, the following are equivalent:

#+BEGIN_SRC swift
  let a = 2 // a: Int = 2
  let (a) = 2 // a: Int = 2
  let (a): Int = 2 // a: Int = 2
#+END_SRC   

Grammar of a tuple pattern

tuple-pattern → =(=
tuple-pattern-element-list
_{opt} =)=

tuple-pattern-element-list
→
tuple-pattern-element
|
tuple-pattern-element
=,=
tuple-pattern-element-list

tuple-pattern-element →
pattern |
identifier
=:= pattern


** Enumeration Case Pattern

An /enumeration case pattern/ matches a case of an existing enumeration
type. Enumeration case patterns appear in =switch= statement case labels
and in the case conditions of =if=, =while=, =guard=, and =for=-=in=
statements.

If the enumeration case you're trying to match has any associated
values, the corresponding enumeration case pattern must specify a tuple
pattern that contains one element for each associated value. For an
example that uses a =switch= statement to match enumeration cases
containing associated values, see
[[info:swift#Associated Values][Associated Values]].

An enumeration case pattern also matches values of that case wrapped in
an optional. This simplified syntax lets you omit an optional pattern.
Note that, because =Optional= is implemented as an enumeration, =.none=
and =.some= can appear in the same switch as the cases of the
enumeration type.

#+BEGIN_SRC swift
  enum SomeEnum { case left, right }
  let x: SomeEnum? = .left
  switch x {
  case .left:
      print("Turn left")
  case .right:
      print("Turn right")
  case nil:
      print("Keep going straight")
  }
  // Prints "Turn left"
#+END_SRC    

Grammar of an enumeration case pattern

enum-case-pattern →
type-identifier
_{opt} =.=
enum-case-name
tuple-pattern
_{opt}


** Optional Pattern

An /optional pattern/ matches values wrapped in a =some(Wrapped)= case
of an =Optional<Wrapped>= enumeration. Optional patterns consist of an
identifier pattern followed immediately by a question mark and appear in
the same places as enumeration case patterns.

Because optional patterns are syntactic sugar for =Optional= enumeration
case patterns, the following are equivalent:

#+BEGIN_SRC swift
  let someOptional: Int? = 42
  // Match using an enumeration case pattern.
  if case .some(let x) = someOptional {
      print(x)
  }

  // Match using an optional pattern.
  if case let x? = someOptional {
      print(x)
  }
#+END_SRC    

The optional pattern provides a convenient way to iterate over an array
of optional values in a =for=-=in= statement, executing the body of the
loop only for non-=nil= elements.

#+BEGIN_SRC swift
  let arrayOfOptionalInts: [Int?] = [nil, 2, 3, nil, 5]
  // Match only non-nil values.
  for case let number? in arrayOfOptionalInts {
      print("Found a \(number)")
  }
  // Found a 2
  // Found a 3
  // Found a 5
#+END_SRC

Grammar of an optional pattern

optional-pattern →
identifier-pattern
=?=


** Type-Casting Patterns

There are two type-casting patterns, the =is= pattern and the =as=
pattern. The =is= pattern appears only in =switch= statement case
labels. The =is= and =as= patterns have the following form:

#+BEGIN_SRC swift
  is type
  pattern as type
#+END_SRC   

The =is= pattern matches a value if the type of that value at runtime is
the same as the type specified in the right-hand side of the =is=
pattern---or a subclass of that type. The =is= pattern behaves like the
=is= operator in that they both perform a type cast but discard the
returned type.

The =as= pattern matches a value if the type of that value at runtime is
the same as the type specified in the right-hand side of the =as=
pattern---or a subclass of that type. If the match succeeds, the type of
the matched value is cast to the /pattern/ specified in the right-hand
side of the =as= pattern.

For an example that uses a =switch= statement to match values with =is=
and =as= patterns, see [[info:swift#Type Casting for Any and  AnyObject][Type
Casting for Any and AnyObject]].

Grammar of a type casting pattern

type-casting-pattern →
is-pattern |
as-pattern

is-pattern → =is=
type

as-pattern →
pattern =as=
type


** Expression Pattern

An /expression pattern/ represents the value of an expression.
Expression patterns appear only in =switch= statement case labels.

The expression represented by the expression pattern is compared with
the value of an input expression using the Swift standard library =~==
operator. The matches succeeds if the =~== operator returns =true=. By
default, the =~== operator compares two values of the same type using
the ==== operator. It can also match a value with a range of values, by
checking whether the value is contained within the range, as the
following example shows.

#+BEGIN_SRC swift
  let point = (1, 2)
  switch point {
  case (0, 0):
      print("(0, 0) is at the origin.")
  case (-2...2, -2...2):
      print("(\(point.0), \(point.1)) is near the origin.")
  default:
      print("The point is at (\(point.0), \(point.1)).")
  }
  // Prints "(1, 2) is near the origin."
#+END_SRC    

You can overload the =~== operator to provide custom expression matching
behavior. For example, you can rewrite the above example to compare the
=point= expression with a string representations of points.

#+BEGIN_SRC swift
  // Overload the ~= operator to match a string with an integer.
  func ~= (pattern: String, value: Int) -> Bool {
      return pattern == "\(value)"
  }
  switch point {
  case ("0", "0"):
      print("(0, 0) is at the origin.")
  default:
      print("The point is at (\(point.0), \(point.1)).")
  }
  // Prints "The point is at (1, 2)."
#+END_SRC    

Grammar of an expression pattern

expression-pattern →
expression

* Generic Parameters and Arguments

This chapter describes parameters and arguments for generic types,
functions, and initializers. When you declare a generic type, function,
subscript, or initializer, you specify the type parameters that the
generic type, function, or initializer can work with. These type
parameters act as placeholders that are replaced by actual concrete type
arguments when an instance of a generic type is created or a generic
function or initializer is called.

For an overview of generics in Swift, see
[[info:swift#Generics][Generics]].


** Generic Parameter Clause

A /generic parameter clause/ specifies the type parameters of a generic
type or function, along with any associated constraints and requirements
on those parameters. A generic parameter clause is enclosed in angle
brackets (<>) and has the following form:

#+BEGIN_SRC swift
  <generic parameter list>
#+END_SRC   

The /generic parameter list/ is a comma-separated list of generic
parameters, each of which has the following form:

#+BEGIN_SRC swift
  type parameter: constraint
#+END_SRC   

A generic parameter consists of a /type parameter/ followed by an
optional /constraint/. A /type parameter/ is simply the name of a
placeholder type (for example, =T=, =U=, =V=, =Key=, =Value=, and so
on). You have access to the type parameters (and any of their associated
types) in the rest of the type, function, or initializer declaration,
including in the signature of the function or initializer.

The /constraint/ specifies that a type parameter inherits from a
specific class or conforms to a protocol or protocol composition. For
example, in the generic function below, the generic parameter
=T: Comparable= indicates that any type argument substituted for the
type parameter =T= must conform to the =Comparable= protocol.

#+BEGIN_SRC swift
  func simpleMax<T: Comparable>(_ x: T, _ y: T) -> T {
      if x < y {
          return y
      }
      return x
  }
#+END_SRC   

Because =Int= and =Double=, for example, both conform to the
=Comparable= protocol, this function accepts arguments of either type.
In contrast with generic types, you don't specify a generic argument
clause when you use a generic function or initializer. The type
arguments are instead inferred from the type of the arguments passed to
the function or initializer.

#+BEGIN_SRC swift
  simpleMax(17, 42) // T is inferred to be Int
  simpleMax(3.14159, 2.71828) // T is inferred to be Double
#+END_SRC

*** Generic Where Clauses

You can specify additional requirements on type parameters and their
associated types by including a generic =where= clause right before the
opening curly brace of a type or function's body. A generic =where=
clause consists of the =where= keyword, followed by a comma-separated
list of one or more /requirements/.

#+BEGIN_SRC swift
  where requirements
#+END_SRC   

The /requirements/ in a generic =where= clause specify that a type
parameter inherits from a class or conforms to a protocol or protocol
composition. Although the generic =where= clause provides syntactic
sugar for expressing simple constraints on type parameters (for example,
=<T: Comparable>= is equivalent to =<T> where T: Comparable= and so on),
you can use it to provide more complex constraints on type parameters
and their associated types. For example, you can constrain the
associated types of type parameters to conform to protocols. For
example, =<S: Sequence> where S.Iterator.Element: Equatable= specifies
that =S= conforms to the =Sequence= protocol and that the associated
type =S.Iterator.Element= conforms to the =Equatable= protocol. This
constraint ensures that each element of the sequence is equatable.

You can also specify the requirement that two types be identical, using
the ==== operator. For example,
=<S1: Sequence, S2: Sequence> where S1.Iterator.Element == S2.Iterator.Element=
expresses the constraints that =S1= and =S2= conform to the =Sequence=
protocol and that the elements of both sequences must be of the same
type.

Any type argument substituted for a type parameter must meet all the
constraints and requirements placed on the type parameter.

A generic =where= clause can appear as part of a declaration that
includes type parameters, or as part of a declaration that's nested
inside of a declaration that includes type parameters. The generic
=where= clause for a nested declaration can still refer to the type
parameters of the enclosing declaration; however, the requirements from
that =where= clause apply only to the declaration where it's written.

If the enclosing declaration also has a =where= clause, the requirements
from both clauses are combined. In the example below, =startsWithZero()=
is available only if =Element= conforms to both =SomeProtocol= and
=Numeric=.

#+BEGIN_SRC swift
  extension Collection where Element: SomeProtocol {
      func startsWithZero() -> Bool where Element: Numeric {
          return first == .zero
      }
  }
#+END_SRC   

You can overload a generic function or initializer by providing
different constraints, requirements, or both on the type parameters.
When you call an overloaded generic function or initializer, the
compiler uses these constraints to resolve which overloaded function or
initializer to invoke.

For more information about generic =where= clauses and to see an example
of one in a generic function declaration, see
[[Generic Where Clauses][Generic Where Clauses]].

Grammar of a generic parameter clause

generic-parameter-clause
→ =<=
generic-parameter-list
=>=

generic-parameter-list
→
generic-parameter
|
generic-parameter
=,=
generic-parameter-list

generic-parameter
→ type-name

generic-parameter
→ type-name =:=
type-identifier

generic-parameter
→ type-name =:=
protocol-composition-type

generic-where-clause
→ =where=
requirement-list

requirement-list
→
requirement
|
requirement
=,=
requirement-list

requirement →
conformance-requirement
|
same-type-requirement

conformance-requirement
→
type-identifier
=:=
type-identifier

conformance-requirement
→
type-identifier
=:=
protocol-composition-type

same-type-requirement
→
type-identifier
==== type


** Generic Argument Clause

A /generic argument clause/ specifies the type arguments of a generic
type. A generic argument clause is enclosed in angle brackets (<>) and
has the following form:

#+BEGIN_SRC swift
  <generic argument list>
#+END_SRC   

The /generic argument list/ is a comma-separated list of type arguments.
A /type argument/ is the name of an actual concrete type that replaces a
corresponding type parameter in the generic parameter clause of a
generic type. The result is a specialized version of that generic type.
The example below shows a simplified version of the Swift standard
library's generic dictionary type.

#+BEGIN_SRC swift
  struct Dictionary<Key: Hashable, Value>: Collection,
                                           ExpressibleByDictionaryLiteral {
      /* ... */
  }
#+END_SRC   

The specialized version of the generic =Dictionary= type,
=Dictionary<String, Int>= is formed by replacing the generic parameters
=Key: Hashable= and =Value= with the concrete type arguments =String=
and =Int=. Each type argument must satisfy all the constraints of the
generic parameter it replaces, including any additional requirements
specified in a generic =where= clause. In the example above, the =Key=
type parameter is constrained to conform to the =Hashable= protocol and
therefore =String= must also conform to the =Hashable= protocol.

You can also replace a type parameter with a type argument that's
itself a specialized version of a generic type (provided it satisfies
the appropriate constraints and requirements). For example, you can
replace the type parameter =Element= in =Array<Element>= with a
specialized version of an array, =Array<Int>=, to form an array whose
elements are themselves arrays of integers.

#+BEGIN_SRC swift
  let arrayOfArrays: Array<Array<Int>> = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
#+END_SRC

As mentioned in [[Generic Parameter Clause][Generic
Parameter Clause]], you don't use a generic argument clause to specify
the type arguments of a generic function or initializer.

Grammar of a generic argument clause

generic-argument-clause
→ =<=
generic-argument-list
=>=

generic-argument-list
→
generic-argument
|
generic-argument
=,=
generic-argument-list

generic-argument
→ type

* Summary of the Grammar


** Lexical Structure

Grammar of whitespace

whitespace →
whitespace-item
whitespace
_{opt}

whitespace-item
→
line-break

whitespace-item
→
inline-space

whitespace-item
→ comment

whitespace-item
→
multiline-comment

whitespace-item
→ U+0000, U+000B, or U+000C

line-break →
U+000A

line-break →
U+000D

line-break →
U+000D followed by U+000A

inline-spaces
→
inline-space
inline-spaces
_{opt}

inline-space →
U+0009 or U+0020

comment → =//=
comment-text
line-break

multiline-comment
→ =/*=
multiline-comment-text
=*/=

comment-text →
comment-text-item
comment-text
_{opt}

comment-text-item
→ Any Unicode scalar value except U+000A or U+000D

multiline-comment-text
→
multiline-comment-text-item
multiline-comment-text
_{opt}

multiline-comment-text-item
→
multiline-comment

multiline-comment-text-item
→
comment-text-item

multiline-comment-text-item
→ Any Unicode scalar value except =/*= or =*/=

Grammar of an identifier

identifier →
identifier-head
identifier-characters
_{opt}

identifier → =`=
identifier-head
identifier-characters
_{opt} =`=

identifier →
implicit-parameter-name

identifier →
property-wrapper-projection

identifier-list
→
identifier
|
identifier
=,=
identifier-list

identifier-head
→ Upper- or lowercase letter A through Z

identifier-head
→ =_=

identifier-head
→ U+00A8, U+00AA, U+00AD, U+00AF, U+00B2--U+00B5, or U+00B7--U+00BA

identifier-head
→ U+00BC--U+00BE, U+00C0--U+00D6, U+00D8--U+00F6, or U+00F8--U+00FF

identifier-head
→ U+0100--U+02FF, U+0370--U+167F, U+1681--U+180D, or U+180F--U+1DBF

identifier-head
→ U+1E00--U+1FFF

identifier-head
→ U+200B--U+200D, U+202A--U+202E, U+203F--U+2040, U+2054, or
U+2060--U+206F

identifier-head
→ U+2070--U+20CF, U+2100--U+218F, U+2460--U+24FF, or U+2776--U+2793

identifier-head
→ U+2C00--U+2DFF or U+2E80--U+2FFF

identifier-head
→ U+3004--U+3007, U+3021--U+302F, U+3031--U+303F, or U+3040--U+D7FF

identifier-head
→ U+F900--U+FD3D, U+FD40--U+FDCF, U+FDF0--U+FE1F, or U+FE30--U+FE44

identifier-head
→ U+FE47--U+FFFD

identifier-head
→ U+10000--U+1FFFD, U+20000--U+2FFFD, U+30000--U+3FFFD, or
U+40000--U+4FFFD

identifier-head
→ U+50000--U+5FFFD, U+60000--U+6FFFD, U+70000--U+7FFFD, or
U+80000--U+8FFFD

identifier-head
→ U+90000--U+9FFFD, U+A0000--U+AFFFD, U+B0000--U+BFFFD, or
U+C0000--U+CFFFD

identifier-head
→ U+D0000--U+DFFFD or U+E0000--U+EFFFD

identifier-character
→ Digit 0 through 9

identifier-character
→ U+0300--U+036F, U+1DC0--U+1DFF, U+20D0--U+20FF, or U+FE20--U+FE2F

identifier-character
→
identifier-head

identifier-characters
→
identifier-character
identifier-characters
_{opt}

implicit-parameter-name
→ =$=
decimal-digits

Grammar of a literal

literal →
numeric-literal
|
string-literal
|
boolean-literal
|
nil-literal

numeric-literal
→ =-=_{opt}
integer-literal
| =-=_{opt}
floating-point-literal

boolean-literal
→ =true= | =false=

nil-literal →
=nil=

Grammar of an integer literal

integer-literal
→
binary-literal

integer-literal
→
octal-literal

integer-literal
→
decimal-literal

integer-literal
→
hexadecimal-literal

binary-literal
→ =0b=
binary-digit
binary-literal-characters
_{opt}

binary-digit →
Digit 0 or 1

binary-literal-character
→
binary-digit
| =_=

binary-literal-characters
→
binary-literal-character
binary-literal-characters
_{opt}

octal-literal
→ =0o=
octal-digit
octal-literal-characters
_{opt}

octal-digit →
Digit 0 through 7

octal-literal-character
→
octal-digit
| =_=

octal-literal-characters
→
octal-literal-character
octal-literal-characters
_{opt}

decimal-literal
→
decimal-digit
decimal-literal-characters
_{opt}

decimal-digit
→ Digit 0 through 9

decimal-digits
→
decimal-digit
decimal-digits
_{opt}

decimal-literal-character
→
decimal-digit
| =_=

decimal-literal-characters
→
decimal-literal-character
decimal-literal-characters
_{opt}

hexadecimal-literal
→ =0x=
hexadecimal-digit
hexadecimal-literal-characters
_{opt}

hexadecimal-digit
→ Digit 0 through 9, a through f, or A through F

hexadecimal-literal-character
→
hexadecimal-digit
| =_=

hexadecimal-literal-characters
→
hexadecimal-literal-character
hexadecimal-literal-characters
_{opt}

Grammar of a floating-point literal

floating-point-literal
→
decimal-literal
decimal-fraction
_{opt}
decimal-exponent
_{opt}

floating-point-literal
→
hexadecimal-literal
hexadecimal-fraction
_{opt}
hexadecimal-exponent

decimal-fraction
→ =.=
decimal-literal

decimal-exponent
→
floating-point-e
sign _{opt}
decimal-literal

hexadecimal-fraction
→ =.=
hexadecimal-digit
hexadecimal-literal-characters
_{opt}

hexadecimal-exponent
→
floating-point-p
sign _{opt}
decimal-literal

floating-point-e
→ =e= | =E=

floating-point-p
→ =p= | =P=

sign → =+= | =-=

Grammar of a string literal

string-literal
→
static-string-literal
|
interpolated-string-literal

string-literal-opening-delimiter
→
extended-string-literal-delimiter
_{opt} ="=

string-literal-closing-delimiter
→ ="=
extended-string-literal-delimiter
_{opt}

static-string-literal
→
string-literal-opening-delimiter
quoted-text
_{opt}
string-literal-closing-delimiter

static-string-literal
→
multiline-string-literal-opening-delimiter
multiline-quoted-text
_{opt}
multiline-string-literal-closing-delimiter

multiline-string-literal-opening-delimiter
→
extended-string-literal-delimiter
="""=

multiline-string-literal-closing-delimiter
→ ="""=
extended-string-literal-delimiter

extended-string-literal-delimiter
→ =#=
extended-string-literal-delimiter
_{opt}

quoted-text →
quoted-text-item
quoted-text
_{opt}

quoted-text-item
→
escaped-character

quoted-text-item
→ Any Unicode scalar value except ="=, =\=, U+000A, or U+000D

multiline-quoted-text
→
multiline-quoted-text-item
multiline-quoted-text
_{opt}

multiline-quoted-text-item
→
escaped-character

multiline-quoted-text-item
→ Any Unicode scalar value except =\=

multiline-quoted-text-item
→
escaped-newline

interpolated-string-literal
→
string-literal-opening-delimiter
interpolated-text
_{opt}
string-literal-closing-delimiter

interpolated-string-literal
→
multiline-string-literal-opening-delimiter
multiline-interpolated-text
_{opt}
multiline-string-literal-closing-delimiter

interpolated-text
→
interpolated-text-item
interpolated-text
_{opt}

interpolated-text-item
→ =\(=
expression
=)= |
quoted-text-item

multiline-interpolated-text
→
multiline-interpolated-text-item
multiline-interpolated-text
_{opt}

multiline-interpolated-text-item
→ =\(=
expression
=)= |
multiline-quoted-text-item

escape-sequence
→ =\=
extended-string-literal-delimiter

escaped-character
→
escape-sequence
=0= |
escape-sequence
=\= |
escape-sequence
=t= |
escape-sequence
=n= |
escape-sequence
=r= |
escape-sequence
="= |
escape-sequence
='=

escaped-character
→
escape-sequence
=u= ={=
unicode-scalar-digits
=}=

unicode-scalar-digits
→ Between one and eight hexadecimal digits

escaped-newline
→
escape-sequence
inline-spaces
_{opt}
line-break

Grammar of operators

operator →
operator-head
operator-characters
_{opt}

operator →
dot-operator-head
dot-operator-characters

operator-head
→ =/= | === | =-= | =+= | =!= | =*= | =%= | =<= | =>= | =&= | =|= | =^=
| =~= | =?=

operator-head
→ U+00A1--U+00A7

operator-head
→ U+00A9 or U+00AB

operator-head
→ U+00AC or U+00AE

operator-head
→ U+00B0--U+00B1

operator-head
→ U+00B6, U+00BB, U+00BF, U+00D7, or U+00F7

operator-head
→ U+2016--U+2017

operator-head
→ U+2020--U+2027

operator-head
→ U+2030--U+203E

operator-head
→ U+2041--U+2053

operator-head
→ U+2055--U+205E

operator-head
→ U+2190--U+23FF

operator-head
→ U+2500--U+2775

operator-head
→ U+2794--U+2BFF

operator-head
→ U+2E00--U+2E7F

operator-head
→ U+3001--U+3003

operator-head
→ U+3008--U+3020

operator-head
→ U+3030

operator-character
→
operator-head

operator-character
→ U+0300--U+036F

operator-character
→ U+1DC0--U+1DFF

operator-character
→ U+20D0--U+20FF

operator-character
→ U+FE00--U+FE0F

operator-character
→ U+FE20--U+FE2F

operator-character
→ U+E0100--U+E01EF

operator-characters
→
operator-character
operator-characters
_{opt}

dot-operator-head
→ =.=

dot-operator-character
→ =.= |
operator-character

dot-operator-characters
→
dot-operator-character
dot-operator-characters
_{opt}

binary-operator
→
operator

prefix-operator
→
operator

postfix-operator
→
operator


** Types

Grammar of a type

type →
function-type

type →
array-type

type →
dictionary-type

type →
type-identifier

type →
tuple-type

type →
optional-type

type →
implicitly-unwrapped-optional-type

type →
protocol-composition-type

type →
opaque-type

type →
metatype-type

type →
any-type

type →
self-type

type → =(=
type =)=

Grammar of a type annotation

type-annotation
→ =:=
attributes
_{opt} =inout=_{opt}
type

Grammar of a type identifier

type-identifier
→ type-name
generic-argument-clause
_{opt} | type-name
generic-argument-clause
_{opt} =.=
type-identifier

type-name →
identifier

Grammar of a tuple type

tuple-type → =(=
=)= | =(=
tuple-type-element
=,=
tuple-type-element-list
=)=

tuple-type-element-list
→
tuple-type-element
|
tuple-type-element
=,=
tuple-type-element-list

tuple-type-element
→ element-name
type-annotation
| type

element-name →
identifier

Grammar of a function type

function-type
→ attributes
_{opt}
function-type-argument-clause
=throws=_{opt} =->=
type

function-type-argument-clause
→ =(= =)=

function-type-argument-clause
→ =(=
function-type-argument-list
=...=_{opt} =)=

function-type-argument-list
→
function-type-argument
|
function-type-argument
=,=
function-type-argument-list

function-type-argument
→ attributes
_{opt} =inout=_{opt}
type |
argument-label
type-annotation

argument-label
→
identifier

Grammar of an array type

array-type → =[=
type =]=

Grammar of a dictionary type

dictionary-type
→ =[= type =:=
type =]=

Grammar of an optional type

optional-type
→ type =?=

Grammar of an implicitly unwrapped optional type

implicitly-unwrapped-optional-type
→ type =!=

Grammar of a protocol composition type

protocol-composition-type
→
type-identifier
=&=
protocol-composition-continuation

protocol-composition-continuation
→
type-identifier
|
protocol-composition-type

Grammar of an opaque type

opaque-type →
=some= type

Grammar of a metatype type

metatype-type
→ type =.= =Type= |
type =.= =Protocol=

Grammar of an Any type

any-type → =Any=

Grammar of a Self type

self-type → =Self=

Grammar of a type inheritance clause

type-inheritance-clause
→ =:=
type-inheritance-list

type-inheritance-list
→
type-identifier
|
type-identifier
=,=
type-inheritance-list


** Expressions

Grammar of an expression

expression →
try-operator
_{opt}
prefix-expression
binary-expressions
_{opt}

expression-list
→
expression
|
expression
=,=
expression-list

Grammar of a prefix expression

prefix-expression
→
prefix-operator
_{opt}
postfix-expression

prefix-expression
→
in-out-expression

in-out-expression
→ =&=
identifier

Grammar of a try expression

try-operator →
=try= | =try= =?= | =try= =!=

Grammar of a binary expression

binary-expression
→
binary-operator
prefix-expression

binary-expression
→
assignment-operator
try-operator
_{opt}
prefix-expression

binary-expression
→
conditional-operator
try-operator
_{opt}
prefix-expression

binary-expression
→
type-casting-operator

binary-expressions
→
binary-expression
binary-expressions
_{opt}

Grammar of an assignment operator

assignment-operator
→ ===

Grammar of a conditional operator

conditional-operator
→ =?=
expression
=:=

Grammar of a type-casting operator

type-casting-operator
→ =is= type

type-casting-operator
→ =as= type

type-casting-operator
→ =as= =?= type

type-casting-operator
→ =as= =!= type

Grammar of a primary expression

primary-expression
→
identifier
generic-argument-clause
_{opt}

primary-expression
→
literal-expression

primary-expression
→
self-expression

primary-expression
→
superclass-expression

primary-expression
→
closure-expression

primary-expression
→
parenthesized-expression

primary-expression
→
tuple-expression

primary-expression
→
implicit-member-expression

primary-expression
→
wildcard-expression

primary-expression
→
key-path-expression

primary-expression
→
selector-expression

primary-expression
→
key-path-string-expression

Grammar of a literal expression

literal-expression
→ literal

literal-expression
→
array-literal
|
dictionary-literal
|
playground-literal

literal-expression
→ =#file= | =#fileID= | =#filePath=

literal-expression
→ =#line= | =#column= | =#function= | =#dsohandle=

array-literal
→ =[=
array-literal-items
_{opt} =]=

array-literal-items
→
array-literal-item
=,=_{opt} |
array-literal-item
=,=
array-literal-items

array-literal-item
→
expression

dictionary-literal
→ =[=
dictionary-literal-items
=]= | =[= =:= =]=

dictionary-literal-items
→
dictionary-literal-item
=,=_{opt} |
dictionary-literal-item
=,=
dictionary-literal-items

dictionary-literal-item
→
expression
=:=
expression

playground-literal
→ =#colorLiteral= =(= =red= =:=
expression
=,= =green= =:=
expression
=,= =blue= =:=
expression
=,= =alpha= =:=
expression
=)=

playground-literal
→ =#fileLiteral= =(= =resourceName= =:=
expression
=)=

playground-literal
→ =#imageLiteral= =(= =resourceName= =:=
expression
=)=

Grammar of a self expression

self-expression
→ =self= |
self-method-expression
|
self-subscript-expression
|
self-initializer-expression

self-method-expression
→ =self= =.=
identifier

self-subscript-expression
→ =self= =[=
function-call-argument-list
=]=

self-initializer-expression
→ =self= =.= =init=

Grammar of a superclass expression

superclass-expression
→
superclass-method-expression
|
superclass-subscript-expression
|
superclass-initializer-expression

superclass-method-expression
→ =super= =.=
identifier

superclass-subscript-expression
→ =super= =[=
function-call-argument-list
=]=

superclass-initializer-expression
→ =super= =.= =init=

Grammar of a closure expression

closure-expression
→ ={=
closure-signature
_{opt}
statements
_{opt} =}=

closure-signature
→
capture-list
_{opt}
closure-parameter-clause
=throws=_{opt}
function-result
_{opt} =in=

closure-signature
→
capture-list
=in=

closure-parameter-clause
→ =(= =)= | =(=
closure-parameter-list
=)= |
identifier-list

closure-parameter-list
→
closure-parameter
|
closure-parameter
=,=
closure-parameter-list

closure-parameter
→
closure-parameter-name
type-annotation
_{opt}

closure-parameter
→
closure-parameter-name
type-annotation
=...=

closure-parameter-name
→
identifier

capture-list →
=[=
capture-list-items
=]=

capture-list-items
→
capture-list-item
|
capture-list-item
=,=
capture-list-items

capture-list-item
→
capture-specifier
_{opt}
expression

capture-list-item
→
capture-specifier
_{opt}
identifier
===
expression

capture-list-item
→
capture-specifier
_{opt}
self-expression

capture-specifier
→ =weak= | =unowned= | =unowned(safe)= | =unowned(unsafe)=

Grammar of a implicit member expression

implicit-member-expression
→ =.=
identifier

Grammar of a parenthesized expression

parenthesized-expression
→ =(=
expression
=)=

Grammar of a tuple expression

tuple-expression
→ =(= =)= | =(=
tuple-element
=,=
tuple-element-list
=)=

tuple-element-list
→
tuple-element
|
tuple-element
=,=
tuple-element-list

tuple-element
→
expression
|
identifier
=:=
expression

Grammar of a wildcard expression

wildcard-expression
→ =_=

Grammar of a key-path expression

key-path-expression
→ =\= type _{opt} =.=
key-path-components

key-path-components
→
key-path-component
|
key-path-component
=.=
key-path-components

key-path-component
→
identifier
key-path-postfixes
_{opt} |
key-path-postfixes

key-path-postfixes
→
key-path-postfix
key-path-postfixes
_{opt}

key-path-postfix
→ =?= | =!= | =self= | =[=
function-call-argument-list
=]=

Grammar of a selector expression

selector-expression
→ =#selector= =(=
expression
=)=

selector-expression
→ =#selector= =(= =getter:=
expression
=)=

selector-expression
→ =#selector= =(= =setter:=
expression
=)=

Grammar of a key-path string expression

key-path-string-expression
→ =#keyPath= =(=
expression
=)=

Grammar of a postfix expression

postfix-expression
→
primary-expression

postfix-expression
→
postfix-expression
postfix-operator

postfix-expression
→
function-call-expression

postfix-expression
→
initializer-expression

postfix-expression
→
explicit-member-expression

postfix-expression
→
postfix-self-expression

postfix-expression
→
subscript-expression

postfix-expression
→
forced-value-expression

postfix-expression
→
optional-chaining-expression

Grammar of a function call expression

function-call-expression
→
postfix-expression
function-call-argument-clause

function-call-expression
→
postfix-expression
function-call-argument-clause
_{opt}
trailing-closures

function-call-argument-clause
→ =(= =)= | =(=
function-call-argument-list
=)=

function-call-argument-list
→
function-call-argument
|
function-call-argument
=,=
function-call-argument-list

function-call-argument
→
expression
|
identifier
=:=
expression

function-call-argument
→
operator
|
identifier
=:=
operator

trailing-closures → closure-expression labeled-trailing-closures _{opt}

labeled-trailing-closures → labeled-trailing-closure labeled-trailing-closures _{opt}

labeled-trailing-closure → identifier =:= closure-expression

Grammar of an initializer expression

initializer-expression
→
postfix-expression
=.= =init=

initializer-expression
→
postfix-expression
=.= =init= =(=
argument-names
=)=

Grammar of an explicit member expression

explicit-member-expression
→
postfix-expression
=.=
decimal-digits

explicit-member-expression
→
postfix-expression
=.=
identifier
generic-argument-clause
_{opt}

explicit-member-expression
→
postfix-expression
=.=
identifier
=(=
argument-names
=)=

argument-names
→
argument-name
argument-names
_{opt}

argument-name
→
identifier
=:=

Grammar of a postfix self expression

postfix-self-expression
→
postfix-expression
=.= =self=

Grammar of a subscript expression

subscript-expression
→
postfix-expression
=[=
function-call-argument-list
=]=

Grammar of a forced-value expression

forced-value-expression
→
postfix-expression
=!=

Grammar of an optional-chaining expression

optional-chaining-expression
→
postfix-expression
=?=


** Statements

Grammar of a statement

statement →
expression
=;=_{opt}

statement →
declaration
=;=_{opt}

statement →
loop-statement
=;=_{opt}

statement →
branch-statement
=;=_{opt}

statement →
labeled-statement
=;=_{opt}

statement →
control-transfer-statement
=;=_{opt}

statement →
defer-statement
=;=_{opt}

statement →
do-statement
=;=_{opt}

statement →
compiler-control-statement

statements →
statement
statements
_{opt}

Grammar of a loop statement

loop-statement
→
for-in-statement

loop-statement
→
while-statement

loop-statement
→
repeat-while-statement

Grammar of a for-in statement

for-in-statement
→ =for= =case=_{opt}
pattern =in=
expression
where-clause
_{opt}
code-block

Grammar of a while statement

while-statement
→ =while=
condition-list
code-block

condition-list
→ condition |
condition =,=
condition-list

condition →
expression
|
availability-condition
|
case-condition
|
optional-binding-condition

case-condition
→ =case= pattern
initializer

optional-binding-condition
→ =let= pattern
initializer
| =var= pattern
initializer

Grammar of a repeat-while statement

repeat-while-statement
→ =repeat=
code-block
=while=
expression

Grammar of a branch statement

branch-statement
→
if-statement

branch-statement
→
guard-statement

branch-statement
→
switch-statement

Grammar of an if statement

if-statement →
=if=
condition-list
code-block
else-clause
_{opt}

else-clause →
=else=
code-block
| =else=
if-statement

Grammar of a guard statement

guard-statement
→ =guard=
condition-list
=else=
code-block

Grammar of a switch statement

switch-statement
→ =switch=
expression
={=
switch-cases
_{opt} =}=

switch-cases →
switch-case
switch-cases
_{opt}

switch-case →
case-label
statements

switch-case →
default-label
statements

switch-case →
conditional-switch-case

case-label →
attributes
_{opt} =case=
case-item-list
=:=

case-item-list
→ pattern
where-clause
_{opt} | pattern
where-clause
_{opt} =,=
case-item-list

default-label
→ attributes
_{opt} =default= =:=

where-clause →
=where=
where-expression

where-expression
→
expression

conditional-switch-case
→
switch-if-directive-clause
switch-elseif-directive-clauses
_{opt}
switch-else-directive-clause
_{opt}
endif-directive

switch-if-directive-clause
→
if-directive
compilation-condition
switch-cases
_{opt}

switch-elseif-directive-clauses
→
elseif-directive-clause
switch-elseif-directive-clauses
_{opt}

switch-elseif-directive-clause
→
elseif-directive
compilation-condition
switch-cases
_{opt}

switch-else-directive-clause
→
else-directive
switch-cases
_{opt}

Grammar of a labeled statement

labeled-statement
→
statement-label
loop-statement

labeled-statement
→
statement-label
if-statement

labeled-statement
→
statement-label
switch-statement

labeled-statement
→
statement-label
do-statement

statement-label
→ label-name
=:=

label-name →
identifier

Grammar of a control transfer statement

control-transfer-statement
→
break-statement

control-transfer-statement
→
continue-statement

control-transfer-statement
→
fallthrough-statement

control-transfer-statement
→
return-statement

control-transfer-statement
→
throw-statement

Grammar of a break statement

break-statement
→ =break=
label-name
_{opt}

Grammar of a continue statement

continue-statement
→ =continue=
label-name
_{opt}

Grammar of a fallthrough statement

fallthrough-statement
→ =fallthrough=

Grammar of a return statement

return-statement
→ =return=
expression
_{opt}

Grammar of a throw statement

throw-statement
→ =throw=
expression

Grammar of a defer statement

defer-statement
→ =defer=
code-block

Grammar of a do statement

do-statement →
=do=
code-block
catch-clauses
_{opt}

catch-clauses
→
catch-clause
catch-clauses
_{opt}

catch-clause →
=catch=
catch-pattern-list
_{opt}
code-block

catch-pattern-list → catch-pattern | catch-pattern =,= catch-pattern-list
catch-pattern → pattern where-clause _{opt}

Grammar of a compiler control statement

compiler-control-statement
→
conditional-compilation-block

compiler-control-statement
→
line-control-statement

compiler-control-statement
→
diagnostic-statement

Grammar of a conditional compilation block

conditional-compilation-block
→
if-directive-clause
elseif-directive-clauses
_{opt}
else-directive-clause
_{opt}
endif-directive

if-directive-clause
→
if-directive
compilation-condition
statements
_{opt}

elseif-directive-clauses
→
elseif-directive-clause
elseif-directive-clauses
_{opt}

elseif-directive-clause
→
elseif-directive
compilation-condition
statements
_{opt}

else-directive-clause
→
else-directive
statements
_{opt}

if-directive →
=#if=

elseif-directive
→ =#elseif=

else-directive
→ =#else=

endif-directive
→ =#endif=

compilation-condition
→
platform-condition

compilation-condition
→
identifier

compilation-condition
→
boolean-literal

compilation-condition
→ =(=
compilation-condition
=)=

compilation-condition
→ =!=
compilation-condition

compilation-condition
→
compilation-condition
=&&=
compilation-condition

compilation-condition
→
compilation-condition
=||=
compilation-condition

platform-condition
→ =os= =(=
operating-system
=)=

platform-condition
→ =arch= =(=
architecture
=)=

platform-condition
→ =swift= =(= =>==
swift-version
=)= | =swift= =(= =<=
swift-version
=)=

platform-condition
→ =compiler= =(= =>==
swift-version
=)= | =compiler= =(= =<=
swift-version
=)=

platform-condition
→ =canImport= =(=
module-name
=)=

platform-condition
→ =targetEnvironment= =(=
environment
=)=

operating-system
→ =macOS= | =iOS= | =watchOS= | =tvOS= | =Linux= | =Windows=

architecture →
=i386= | =x86_64= | =arm= | =arm64=

swift-version
→
decimal-digits
swift-version-continuation
_{opt}

swift-version-continuation
→ =.=
decimal-digits
swift-version-continuation
_{opt}

module-name →
identifier

environment →
=simulator= | =macCatalyst=

Grammar of a line control statement

line-control-statement
→ =#sourceLocation= =(= =file:=
file-path =,=
=line:=
line-number
=)=

line-control-statement
→ =#sourceLocation= =(= =)=

line-number → A
decimal integer greater than zero

file-path →
static-string-literal

Grammar of a compile-time diagnostic statement

diagnostic-statement
→ =#error= =(=
diagnostic-message
=)=

diagnostic-statement
→ =#warning= =(=
diagnostic-message
=)=

diagnostic-message
→
static-string-literal

Grammar of an availability condition

availability-condition
→ =#available= =(=
availability-arguments
=)=

availability-arguments
→
availability-argument
|
availability-argument
=,=
availability-arguments

availability-argument
→
platform-name
platform-version

availability-argument
→ =*=

platform-name
→ =iOS= | =iOSApplicationExtension=

platform-name
→ =macOS= | =macOSApplicationExtension=

platform-name
→ =watchOS=

platform-name
→ =tvOS=

platform-version
→
decimal-digits

platform-version
→
decimal-digits
=.=
decimal-digits

platform-version
→
decimal-digits
=.=
decimal-digits
=.=
decimal-digits


** Declarations

Grammar of a declaration

declaration →
import-declaration

declaration →
constant-declaration

declaration →
variable-declaration

declaration →
typealias-declaration

declaration →
function-declaration

declaration →
enum-declaration

declaration →
struct-declaration

declaration →
class-declaration

declaration →
protocol-declaration

declaration →
initializer-declaration

declaration →
deinitializer-declaration

declaration →
extension-declaration

declaration →
subscript-declaration

declaration →
operator-declaration

declaration →
precedence-group-declaration

declarations →
declaration
declarations
_{opt}

Grammar of a top-level declaration

top-level-declaration
→ statements
_{opt}

Grammar of a code block

code-block → ={=
statements
_{opt} =}=

Grammar of an import declaration

import-declaration
→ attributes
_{opt} =import=
import-kind
_{opt}
import-path

import-kind →
=typealias= | =struct= | =class= | =enum= | =protocol= | =let= | =var= |
=func=

import-path →
import-path-identifier
|
import-path-identifier
=.=
import-path

import-path-identifier
→
identifier
|
operator

Grammar of a constant declaration

constant-declaration
→ attributes
_{opt}
declaration-modifiers
_{opt} =let=
pattern-initializer-list

pattern-initializer-list
→
pattern-initializer
|
pattern-initializer
=,=
pattern-initializer-list

pattern-initializer
→ pattern
initializer
_{opt}

initializer →
===
expression

Grammar of a variable declaration

variable-declaration
→
variable-declaration-head
pattern-initializer-list

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
code-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-keyword-block

variable-declaration
→
variable-declaration-head
variable-name
initializer
willSet-didSet-block

variable-declaration
→
variable-declaration-head
variable-name
type-annotation
initializer
_{opt}
willSet-didSet-block

variable-declaration-head
→ attributes
_{opt}
declaration-modifiers
_{opt} =var=

variable-name
→
identifier

getter-setter-block
→
code-block

getter-setter-block
→ ={=
getter-clause
setter-clause
_{opt} =}=

getter-setter-block
→ ={=
setter-clause
getter-clause
=}=

getter-clause
→ attributes
_{opt}
mutation-modifier
_{opt} =get=
code-block

setter-clause
→ attributes
_{opt}
mutation-modifier
_{opt} =set=
setter-name
_{opt}
code-block

setter-name →
=(=
identifier
=)=

getter-setter-keyword-block
→ ={=
getter-keyword-clause
setter-keyword-clause
_{opt} =}=

getter-setter-keyword-block
→ ={=
setter-keyword-clause
getter-keyword-clause
=}=

getter-keyword-clause
→ attributes
_{opt}
mutation-modifier
_{opt} =get=

setter-keyword-clause
→ attributes
_{opt}
mutation-modifier
_{opt} =set=

willSet-didSet-block
→ ={=
willSet-clause
didSet-clause
_{opt} =}=

willSet-didSet-block
→ ={=
didSet-clause
willSet-clause
_{opt} =}=

willSet-clause
→ attributes
_{opt} =willSet=
setter-name
_{opt}
code-block

didSet-clause
→ attributes
_{opt} =didSet=
setter-name
_{opt}
code-block

Grammar of a type alias declaration

typealias-declaration
→ attributes
_{opt}
access-level-modifier
_{opt} =typealias=
typealias-name
generic-parameter-clause
_{opt}
typealias-assignment

typealias-name
→
identifier

typealias-assignment
→ === type

Grammar of a function declaration

function-declaration
→
function-head
function-name
generic-parameter-clause
_{opt}
function-signature
generic-where-clause
_{opt}
function-body
_{opt}

function-head
→ attributes
_{opt}
declaration-modifiers
_{opt} =func=

function-name
→
identifier
|
operator

function-signature
→
parameter-clause
=throws=_{opt}
function-result
_{opt}

function-signature
→
parameter-clause
=rethrows=
function-result
_{opt}

function-result
→ =->=
attributes
_{opt} type

function-body
→
code-block

parameter-clause
→ =(= =)= | =(=
parameter-list
=)=

parameter-list
→ parameter
| parameter
=,=
parameter-list

parameter →
external-parameter-name
_{opt}
local-parameter-name
type-annotation
default-argument-clause
_{opt}

parameter →
external-parameter-name
_{opt}
local-parameter-name
type-annotation

parameter →
external-parameter-name
_{opt}
local-parameter-name
type-annotation
=...=

external-parameter-name
→
identifier

local-parameter-name
→
identifier

default-argument-clause
→ ===
expression

Grammar of an enumeration declaration

enum-declaration
→ attributes
_{opt}
access-level-modifier
_{opt}
union-style-enum

enum-declaration
→ attributes
_{opt}
access-level-modifier
_{opt}
raw-value-style-enum

union-style-enum
→ =indirect=_{opt} =enum=
enum-name
generic-parameter-clause
_{opt}
type-inheritance-clause
_{opt}
generic-where-clause
_{opt} ={=
union-style-enum-members
_{opt} =}=

union-style-enum-members
→
union-style-enum-member
union-style-enum-members
_{opt}

union-style-enum-member
→
declaration
|
union-style-enum-case-clause
|
compiler-control-statement

union-style-enum-case-clause
→ attributes
_{opt} =indirect=_{opt} =case=
union-style-enum-case-list

union-style-enum-case-list
→
union-style-enum-case
|
union-style-enum-case
=,=
union-style-enum-case-list

union-style-enum-case
→
enum-case-name
tuple-type _{opt}

enum-name →
identifier

enum-case-name
→
identifier

raw-value-style-enum
→ =enum=
enum-name
generic-parameter-clause
_{opt}
type-inheritance-clause
generic-where-clause
_{opt} ={=
raw-value-style-enum-members
=}=

raw-value-style-enum-members
→
raw-value-style-enum-member
raw-value-style-enum-members
_{opt}

raw-value-style-enum-member
→
declaration
|
raw-value-style-enum-case-clause
|
compiler-control-statement

raw-value-style-enum-case-clause
→ attributes
_{opt} =case=
raw-value-style-enum-case-list

raw-value-style-enum-case-list
→
raw-value-style-enum-case
|
raw-value-style-enum-case
=,=
raw-value-style-enum-case-list

raw-value-style-enum-case
→
enum-case-name
raw-value-assignment
_{opt}

raw-value-assignment
→ ===
raw-value-literal

raw-value-literal
→
numeric-literal
|
static-string-literal
|
boolean-literal

Grammar of a structure declaration

struct-declaration
→ attributes
_{opt}
access-level-modifier
_{opt} =struct=
struct-name
generic-parameter-clause
_{opt}
type-inheritance-clause
_{opt}
generic-where-clause
_{opt}
struct-body

struct-name →
identifier

struct-body →
={=
struct-members
_{opt} =}=

struct-members
→
struct-member
struct-members
_{opt}

struct-member
→
declaration
|
compiler-control-statement

Grammar of a class declaration

class-declaration
→ attributes
_{opt}
access-level-modifier
_{opt} =final=_{opt} =class=
class-name
generic-parameter-clause
_{opt}
type-inheritance-clause
_{opt}
generic-where-clause
_{opt}
class-body

class-declaration
→ attributes
_{opt} =final=
access-level-modifier
_{opt} =class=
class-name
generic-parameter-clause
_{opt}
type-inheritance-clause
_{opt}
generic-where-clause
_{opt}
class-body

class-name →
identifier

class-body → ={=
class-members
_{opt} =}=

class-members
→
class-member
class-members
_{opt}

class-member →
declaration
|
compiler-control-statement

Grammar of a protocol declaration

protocol-declaration
→ attributes
_{opt}
access-level-modifier
_{opt} =protocol=
protocol-name
type-inheritance-clause
_{opt}
generic-where-clause
_{opt}
protocol-body

protocol-name
→
identifier

protocol-body
→ ={=
protocol-members
_{opt} =}=

protocol-members
→
protocol-member
protocol-members
_{opt}

protocol-member
→
protocol-member-declaration
|
compiler-control-statement

protocol-member-declaration
→
protocol-property-declaration

protocol-member-declaration
→
protocol-method-declaration

protocol-member-declaration
→
protocol-initializer-declaration

protocol-member-declaration
→
protocol-subscript-declaration

protocol-member-declaration
→
protocol-associated-type-declaration

protocol-member-declaration
→
typealias-declaration

Grammar of a protocol property declaration

protocol-property-declaration
→
variable-declaration-head
variable-name
type-annotation
getter-setter-keyword-block

Grammar of a protocol method declaration

protocol-method-declaration
→
function-head
function-name
generic-parameter-clause
_{opt}
function-signature
generic-where-clause
_{opt}

Grammar of a protocol initializer declaration

protocol-initializer-declaration
→
initializer-head
generic-parameter-clause
_{opt}
parameter-clause
=throws=_{opt}
generic-where-clause
_{opt}

protocol-initializer-declaration
→
initializer-head
generic-parameter-clause
_{opt}
parameter-clause
=rethrows=
generic-where-clause
_{opt}

Grammar of a protocol subscript declaration

protocol-subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_{opt}
getter-setter-keyword-block

Grammar of a protocol associated type declaration

protocol-associated-type-declaration
→ attributes
_{opt}
access-level-modifier
_{opt} =associatedtype=
typealias-name
type-inheritance-clause
_{opt}
typealias-assignment
_{opt}
generic-where-clause
_{opt}

Grammar of an initializer declaration

initializer-declaration
→
initializer-head
generic-parameter-clause
_{opt}
parameter-clause
=throws=_{opt}
generic-where-clause
_{opt}
initializer-body

initializer-declaration
→
initializer-head
generic-parameter-clause
_{opt}
parameter-clause
=rethrows=
generic-where-clause
_{opt}
initializer-body

initializer-head
→ attributes
_{opt}
declaration-modifiers
_{opt} =init=

initializer-head
→ attributes
_{opt}
declaration-modifiers
_{opt} =init= =?=

initializer-head
→ attributes
_{opt}
declaration-modifiers
_{opt} =init= =!=

initializer-body
→
code-block

Grammar of a deinitializer declaration

deinitializer-declaration
→ attributes
_{opt} =deinit=
code-block

Grammar of an extension declaration

extension-declaration
→ attributes
_{opt}
access-level-modifier
_{opt} =extension=
type-identifier
type-inheritance-clause
_{opt}
generic-where-clause
_{opt}
extension-body

extension-body
→ ={=
extension-members
_{opt} =}=

extension-members
→
extension-member
extension-members
_{opt}

extension-member
→
declaration
|
compiler-control-statement

Grammar of a subscript declaration

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_{opt}
code-block

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_{opt}
getter-setter-block

subscript-declaration
→
subscript-head
subscript-result
generic-where-clause
_{opt}
getter-setter-keyword-block

subscript-head
→ attributes
_{opt}
declaration-modifiers
_{opt} =subscript=
generic-parameter-clause
_{opt}
parameter-clause

subscript-result
→ =->=
attributes
_{opt} type

Grammar of an operator declaration

operator-declaration
→
prefix-operator-declaration
|
postfix-operator-declaration
|
infix-operator-declaration

prefix-operator-declaration
→ =prefix= =operator=
operator

postfix-operator-declaration
→ =postfix= =operator=
operator

infix-operator-declaration
→ =infix= =operator=
operator
infix-operator-group
_{opt}

infix-operator-group
→ =:=
precedence-group-name

Grammar of a precedence group declaration

precedence-group-declaration
→ =precedencegroup=
precedence-group-name
={=
precedence-group-attributes
_{opt} =}=

precedence-group-attributes
→
precedence-group-attribute
precedence-group-attributes
_{opt}

precedence-group-attribute
→
precedence-group-relation

precedence-group-attribute
→
precedence-group-assignment

precedence-group-attribute
→
precedence-group-associativity

precedence-group-relation
→ =higherThan= =:=
precedence-group-names

precedence-group-relation
→ =lowerThan= =:=
precedence-group-names

precedence-group-assignment
→ =assignment= =:=
boolean-literal

precedence-group-associativity
→ =associativity= =:= =left=

precedence-group-associativity
→ =associativity= =:= =right=

precedence-group-associativity
→ =associativity= =:= =none=

precedence-group-names
→
precedence-group-name
|
precedence-group-name
=,=
precedence-group-names

precedence-group-name
→
identifier

Grammar of a declaration modifier

declaration-modifier
→ =class= | =convenience= | =dynamic= | =final= | =infix= | =lazy= |
=optional= | =override= | =postfix= | =prefix= | =required= | =static= |
=unowned= | =unowned= =(= =safe= =)= | =unowned= =(= =unsafe= =)= |
=weak=

declaration-modifier
→
access-level-modifier

declaration-modifier
→
mutation-modifier

declaration-modifiers
→
declaration-modifier
declaration-modifiers
_{opt}

access-level-modifier
→ =private= | =private= =(= =set= =)=

access-level-modifier
→ =fileprivate= | =fileprivate= =(= =set= =)=

access-level-modifier
→ =internal= | =internal= =(= =set= =)=

access-level-modifier
→ =public= | =public= =(= =set= =)=

access-level-modifier
→ =open= | =open= =(= =set= =)=

mutation-modifier
→ =mutating= | =nonmutating=


** Attributes

Grammar of an attribute

attribute → =@=
attribute-name
attribute-argument-clause
_{opt}

attribute-name
→
identifier

attribute-argument-clause
→ =(=
balanced-tokens
_{opt} =)=

attributes →
attribute
attributes
_{opt}

balanced-tokens
→
balanced-token
balanced-tokens
_{opt}

balanced-token
→ =(=
balanced-tokens
_{opt} =)=

balanced-token
→ =[=
balanced-tokens
_{opt} =]=

balanced-token
→ ={=
balanced-tokens
_{opt} =}=

balanced-token
→ Any identifier, keyword, literal, or operator

balanced-token
→ Any punctuation except =(=, =)=, =[=, =]=, ={=, or =}=


** Patterns

Grammar of a pattern

pattern →
wildcard-pattern
type-annotation
_{opt}

pattern →
identifier-pattern
type-annotation
_{opt}

pattern →
value-binding-pattern

pattern →
tuple-pattern
type-annotation
_{opt}

pattern →
enum-case-pattern

pattern →
optional-pattern

pattern →
type-casting-pattern

pattern →
expression-pattern

Grammar of a wildcard pattern

wildcard-pattern
→ =_=

Grammar of an identifier pattern

identifier-pattern
→
identifier

Grammar of a value-binding pattern

value-binding-pattern
→ =var= pattern |
=let= pattern

Grammar of a tuple pattern

tuple-pattern
→ =(=
tuple-pattern-element-list
_{opt} =)=

tuple-pattern-element-list
→
tuple-pattern-element
|
tuple-pattern-element
=,=
tuple-pattern-element-list

tuple-pattern-element
→ pattern |
identifier
=:= pattern

Grammar of an enumeration case pattern

enum-case-pattern
→
type-identifier
_{opt} =.=
enum-case-name
tuple-pattern
_{opt}

Grammar of an optional pattern

optional-pattern
→
identifier-pattern
=?=

Grammar of a type casting pattern

type-casting-pattern
→ is-pattern |
as-pattern

is-pattern → =is=
type

as-pattern →
pattern =as=
type

Grammar of an expression pattern

expression-pattern
→
expression


** Generic Parameters and Arguments

Grammar of a generic parameter clause

generic-parameter-clause
→ =<=
generic-parameter-list
=>=

generic-parameter-list
→
generic-parameter
|
generic-parameter
=,=
generic-parameter-list

generic-parameter
→ type-name

generic-parameter
→ type-name =:=
type-identifier

generic-parameter
→ type-name =:=
protocol-composition-type

generic-where-clause
→ =where=
requirement-list

requirement-list
→
requirement
|
requirement
=,=
requirement-list

requirement →
conformance-requirement
|
same-type-requirement

conformance-requirement
→
type-identifier
=:=
type-identifier

conformance-requirement
→
type-identifier
=:=
protocol-composition-type

same-type-requirement
→
type-identifier
==== type

Grammar of a generic argument clause

generic-argument-clause
→ =<=
generic-argument-list
=>=

generic-argument-list
→
generic-argument
|
generic-argument
=,=
generic-argument-list

generic-argument
→ type
* Index
:PROPERTIES:
:INDEX:    cp
:END:
